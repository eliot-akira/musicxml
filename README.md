# musicxml

![example workflow](https://github.com/stringsync/musicxml/actions/workflows/test.yml/badge.svg)

`musicxml` is a JavaScript library that makes it easy to parse and edit [musicXML](https://www.w3.org/2021/06/musicxml40/) documents.

## üî® Usage

### Parse and serialize a MusicXML document

```ts
const xml = `<?xml version="1.0" encoding="UTF-8"?>
<score-partwise version="4.0">
  <part-list>
    <score-part id="P1">
      <part-name></part-name>
    </score-part>
  </part-list>
  <part id="P1">
    <measure number="1"/>
  </part>
</score-partwise>`;

// parse
const musicXml = MusicXML.parse(xml);

// serialize
console.log(musicXml.serialize() === xml); // true
```

### Create a MusicXML object

[`<score-partwise>`](https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/score-partwise/) root

```ts
const musicXml = MusicXML.createPartwise();
const root = musicXml.getRoot();
console.log(MusicXML.isScorePartwise(root)); // true
```

[`<score-timewise>`](https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/score-timewise/) root

```ts
const musicXml = MusicXML.createTimewise();
const root = musicXml.getRoot();
console.log(MusicXML.isScoreTimewise(root)); // true
```

### Narrow types

Some types can be complex unions. For example, take the `elements.Note` class, which corresponds to the [`<note>`](https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/note/) element (see the content). The first content can be one of several different choices. This library expresses the choices in terms of a union.

```ts
// truncated elements.Note class

type BasicNoteValue = [Chord | null, Pitch | Unpitched | Rest, Duration, [] | [Tie] | [Tie, Tie]];

type CueNoteValue = [Cue, Chord | null, Pitch | Unpitched | Rest, Duration];

type GraceNoteValue = [Grace, TiedGraceNoteValueSpec | CueGraceNoteValueSpec];

class Note {
  getValue(): BasicNoteValue | CueNoteValue | GraceNoteValue {
    return this.contents[0];
  }
}
```

It is very cumbersome to manually validate which choice is being used. Also, the lack of overlap of some choices can make it difficult to use with TypeScript. **Classes that contain choices nested in its <ins>contents</ins> will have static [type predicates](https://www.typescriptlang.org/docs/handbook/2/narrowing.html#using-type-predicates) corresponding to those choices.**

For example, to work with an `elements.Note` value:

```ts
const note = new elements.Note();
const value = note.getValue();

if (elements.Note.isBasicNoteValue(value)) {
  // value: BasicNoteValue
} else if (elements.Note.isCueNoteValue(value)) {
  // value: CueNoteValue
} else if (elements.Note.isGraceNoteValue(value)) {
  // value: GraceNoteValue
} else {
  // value: never
}
```

## üíª Development

### Prerequisites

`musicxml` uses Docker and Docker Compose to create the test environment. The tests will not pass if you try to run them locally.

- [install Docker](https://docs.docker.com/get-docker/)
- [install docker-compose](https://docs.docker.com/compose/install/)

### Testing

`musicxml` uses [xsdvalidate](https://pkg.go.dev/github.com/terminalstatic/go-xsd-validate) to validate XML against an xsd schema. This library is exposed as an HTTP service in the [xmlvalidator](https://github.com/stringsync/musicxml/tree/master/xmlvalidator) directory. The schema was adapted directly from [w3](https://www.w3.org/2021/06/musicxml40/listings/musicxml.xsd/).

To run the tests, run the following in the project directory:

```
yarn test
```

`musicxml` uses the `jest` testing framework. You can pass any of the `jest` CLI options to the test command. For example, to run the tests in watch mode (recommended), run:

```
yarn test --watchAll
```

A complete list of options are in the [jest docs](https://jestjs.io/docs/cli).

## üìù Design

**What's the difference between [src/lib/elements/\*](src/lib/elements) and [src/generated/elements.ts](src/generated/elements.ts)?**

The `elements.*` classes are generated by running:

```
yarn generate
```

This script transforms the schema ([src/lib/elements/\*](src/lib/elements)) into the usable classes ([src/generated/elements.ts](src/generated/elements.ts)).

The reason why there is a layer of indirection is because TypeScript does not support typing dynamic classes _well_, especially when there are 100s of classes involved.

Initially, this library dynamically computed the typings, attribute values, and content values of all the elements, but I frequently ran into ["Type instantiation is excessively deep and possibly infinite"](https://github.com/microsoft/TypeScript/issues/34933) compiler errors (even though it wasn't infinite). When I did work around that issue, compilation was very slow, and the type hints had a lot of noise in them such that they weren't very human readable.

I decided to address the performance issue by transforming the schema into static classes, so that the heavy compilation work is only done once. This also gave me an oppotunity to tone down the type noise in each class, further helping with usability.

**Where did the schema data come from?**

TL;DR - I manually copied the schema from https://www.w3.org/2021/06/musicxml40/musicxml-reference/ using my schema language.

The machine readable schema can be found in the [w3c/musicxml](https://github.com/w3c/musicxml) repository as [musicxml.xsd](https://github.com/w3c/musicxml/blob/49f2fd5b757f2ca251a3f5448a11e386e5dd42a9/schema/musicxml.xsd). At the time of writing, [npm did not have any great tools](https://www.npmjs.com/search?q=xsd) that made it easy to manipulate an XML document while guaranteeing validity against a XSD schema. This was incompatible with my constraints and goals:

- the tool must make it _difficult_ to mutate an XML document such that it becomes invalid
- the tool must be usable in server and browser environments
- the tool must allow me to read and write an XML document in a type-safe manner
- the tool must have an expressive API, that makes it easy to understand what objects I'm working with

All of the tools that I found could only tell me if something was invalid and a human-readable description of what the validation errors were. They also leveraged the [libxml](http://xmlsoft.org/), which is not available in a browser environment.

The machine readable schema was also partitioned in a manner that didn't map 1:1 between elements and logical groupings. For example, the `<score-partwise>` element was defined like this:

```xml
<xs:element name="score-partwise" block="extension substitution" final="#all">
  <xs:annotation>
    <xs:documentation
    >The score-partwise element is the root element for a partwise MusicXML score. It includes a score-header group followed by a series of parts with measures inside. The document-attributes attribute group includes the version attribute.</xs:documentation>
  </xs:annotation>
  <xs:complexType>
    <xs:sequence>
      <xs:group ref="score-header" />
      <xs:element name="part" maxOccurs="unbounded">
        <xs:complexType>
          <xs:sequence>
            <xs:element name="measure" maxOccurs="unbounded">
              <xs:complexType>
                <xs:group ref="music-data" />
                <xs:attributeGroup ref="measure-attributes" />
              </xs:complexType>
            </xs:element>
          </xs:sequence>
          <xs:attributeGroup ref="part-attributes" />
        </xs:complexType>
      </xs:element>
    </xs:sequence>
    <xs:attributeGroup ref="document-attributes" />
  </xs:complexType>
</xs:element>
```

but a `<score-partwise>` element looks like this:

```xml
<score-partwise version="4.0">
  <part-list>
    <score-part id="P1">
      <part-name>Music</part-name>
    </score-part>
  </part-list>
  <part id="P1">
    <measure number="1">
      <attributes>
        <divisions>1</divisions>
        <key>
          <fifths>0</fifths>
        </key>
        <time>
          <beats>4</beats>
          <beat-type>4</beat-type>
        </time>
        <clef>
          <sign>G</sign>
          <line>2</line>
        </clef>
      </attributes>
      <note>
        <pitch>
          <step>C</step>
          <octave>4</octave>
        </pitch>
        <duration>4</duration>
        <type>whole</type>
      </note>
    </measure>
  </part>
</score-partwise>
```

It is not easy as a human to look at the XML document and see how it lines up with the schema. However, the [HTML element definitions](https://www.w3.org/2021/06/musicxml40/musicxml-reference/element-tree/) are easy to match against, and the logical groupings do not require extra mental computation.

[charto/cxsd](https://github.com/charto/cxsd) is a library that can transform XSD to TypeScript, but it has a limitation with ordering choices, which makes it incompatible with MusicXML (charto/cxsd#29).

[highscore/jsonix](highsource/jsonix) is a similar XSD to TypeScript library, but it is not actively maintained. I also suspect that I might lose the expressiveness of the current API.
