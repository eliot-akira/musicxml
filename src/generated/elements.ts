/* eslint-disable @typescript-eslint/ban-types */
import * as operations from '../lib/operations';
import { XMLElement } from '../lib/schema';

export type WorkNumberAttributes = Record<string, unknown>;

export type WorkNumberContents = [string];

export class WorkNumber implements XMLElement<'work-number', WorkNumberAttributes, WorkNumberContents> {
  static readonly schema = { name: 'work-number', attributes: {}, contents: [{ type: 'string' }] } as const;

  readonly schema = WorkNumber.schema;

  attributes: WorkNumberAttributes;
  contents: WorkNumberContents;

  constructor(opts?: { attributes?: Partial<WorkNumberAttributes>; contents?: WorkNumberContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, WorkNumber.schema);
    this.contents = opts?.contents ?? operations.zero(WorkNumber.schema.contents);
  }

  getText(): string {
    return this.contents[0];
  }
  setText(text: string): WorkNumber {
    this.contents[0] = text;
    return this;
  }
}

export type WorkTitleAttributes = Record<string, unknown>;

export type WorkTitleContents = [string];

export class WorkTitle implements XMLElement<'work-title', WorkTitleAttributes, WorkTitleContents> {
  static readonly schema = { name: 'work-title', attributes: {}, contents: [{ type: 'string' }] } as const;

  readonly schema = WorkTitle.schema;

  attributes: WorkTitleAttributes;
  contents: WorkTitleContents;

  constructor(opts?: { attributes?: Partial<WorkTitleAttributes>; contents?: WorkTitleContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, WorkTitle.schema);
    this.contents = opts?.contents ?? operations.zero(WorkTitle.schema.contents);
  }

  getText(): string {
    return this.contents[0];
  }
  setText(text: string): WorkTitle {
    this.contents[0] = text;
    return this;
  }
}

export type OpusAttributes = {
  'xlink:href': string;
  'xlink:actuate': 'none' | 'onRequest' | 'onLoad' | 'other' | null;
  'xlink:role': string | null;
  'xlink:show': 'none' | 'new' | 'replace' | 'embed' | 'other' | null;
  'xlink:title': string | null;
  'xlink:type': 'simple' | null;
};

export type OpusContents = [];

export class Opus implements XMLElement<'opus', OpusAttributes, OpusContents> {
  static readonly schema = {
    name: 'opus',
    attributes: {
      'xlink:href': { type: 'required', value: { type: 'string' } },
      'xlink:actuate': {
        type: 'optional',
        value: { type: 'choices', choices: ['none', 'onRequest', 'onLoad', 'other'] },
      },
      'xlink:role': { type: 'optional', value: { type: 'string' } },
      'xlink:show': {
        type: 'optional',
        value: { type: 'choices', choices: ['none', 'new', 'replace', 'embed', 'other'] },
      },
      'xlink:title': { type: 'optional', value: { type: 'string' } },
      'xlink:type': { type: 'optional', value: { type: 'choices', choices: ['simple'] } },
    },
    contents: [],
  } as const;

  readonly schema = Opus.schema;

  attributes: OpusAttributes;
  contents: OpusContents;

  constructor(opts?: { attributes?: Partial<OpusAttributes>; contents?: OpusContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Opus.schema);
    this.contents = opts?.contents ?? operations.zero(Opus.schema.contents);
  }
  getXlinkHref(): string {
    return this.attributes['xlink:href'];
  }
  setXlinkHref(xlinkHref: string): Opus {
    this.attributes['xlink:href'] = xlinkHref;
    return this;
  }
  getXlinkActuate(): 'none' | 'onRequest' | 'onLoad' | 'other' | null {
    return this.attributes['xlink:actuate'];
  }
  setXlinkActuate(xlinkActuate: 'none' | 'onRequest' | 'onLoad' | 'other' | null): Opus {
    this.attributes['xlink:actuate'] = xlinkActuate;
    return this;
  }
  getXlinkRole(): string | null {
    return this.attributes['xlink:role'];
  }
  setXlinkRole(xlinkRole: string | null): Opus {
    this.attributes['xlink:role'] = xlinkRole;
    return this;
  }
  getXlinkShow(): 'none' | 'new' | 'replace' | 'embed' | 'other' | null {
    return this.attributes['xlink:show'];
  }
  setXlinkShow(xlinkShow: 'none' | 'new' | 'replace' | 'embed' | 'other' | null): Opus {
    this.attributes['xlink:show'] = xlinkShow;
    return this;
  }
  getXlinkTitle(): string | null {
    return this.attributes['xlink:title'];
  }
  setXlinkTitle(xlinkTitle: string | null): Opus {
    this.attributes['xlink:title'] = xlinkTitle;
    return this;
  }
  getXlinkType(): 'simple' | null {
    return this.attributes['xlink:type'];
  }
  setXlinkType(xlinkType: 'simple' | null): Opus {
    this.attributes['xlink:type'] = xlinkType;
    return this;
  }
}

export type WorkAttributes = Record<string, unknown>;

export type WorkContents = [WorkNumber | null, WorkTitle | null, Opus | null];

export class Work implements XMLElement<'work', WorkAttributes, WorkContents> {
  static readonly schema = {
    name: 'work',
    attributes: {},
    contents: [
      { type: 'optional', value: WorkNumber },
      { type: 'optional', value: WorkTitle },
      { type: 'optional', value: Opus },
    ],
  } as const;

  readonly schema = Work.schema;

  attributes: WorkAttributes;
  contents: WorkContents;

  constructor(opts?: { attributes?: Partial<WorkAttributes>; contents?: WorkContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Work.schema);
    this.contents = opts?.contents ?? operations.zero(Work.schema.contents);
  }

  getWorkNumber(): WorkNumber | null {
    return this.contents[0];
  }
  setWorkNumber(workNumber: WorkNumber | null): Work {
    this.contents[0] = workNumber;
    return this;
  }
  getWorkTitle(): WorkTitle | null {
    return this.contents[1];
  }
  setWorkTitle(workTitle: WorkTitle | null): Work {
    this.contents[1] = workTitle;
    return this;
  }
  getOpus(): Opus | null {
    return this.contents[2];
  }
  setOpus(opus: Opus | null): Work {
    this.contents[2] = opus;
    return this;
  }
}

export type MovementNumberAttributes = Record<string, unknown>;

export type MovementNumberContents = [string];

export class MovementNumber implements XMLElement<'movement-number', MovementNumberAttributes, MovementNumberContents> {
  static readonly schema = { name: 'movement-number', attributes: {}, contents: [{ type: 'string' }] } as const;

  readonly schema = MovementNumber.schema;

  attributes: MovementNumberAttributes;
  contents: MovementNumberContents;

  constructor(opts?: { attributes?: Partial<MovementNumberAttributes>; contents?: MovementNumberContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, MovementNumber.schema);
    this.contents = opts?.contents ?? operations.zero(MovementNumber.schema.contents);
  }

  getText(): string {
    return this.contents[0];
  }
  setText(text: string): MovementNumber {
    this.contents[0] = text;
    return this;
  }
}

export type MovementTitleAttributes = Record<string, unknown>;

export type MovementTitleContents = [string];

export class MovementTitle implements XMLElement<'movement-title', MovementTitleAttributes, MovementTitleContents> {
  static readonly schema = { name: 'movement-title', attributes: {}, contents: [{ type: 'string' }] } as const;

  readonly schema = MovementTitle.schema;

  attributes: MovementTitleAttributes;
  contents: MovementTitleContents;

  constructor(opts?: { attributes?: Partial<MovementTitleAttributes>; contents?: MovementTitleContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, MovementTitle.schema);
    this.contents = opts?.contents ?? operations.zero(MovementTitle.schema.contents);
  }

  getText(): string {
    return this.contents[0];
  }
  setText(text: string): MovementTitle {
    this.contents[0] = text;
    return this;
  }
}

export type CreatorAttributes = { type: string | null };

export type CreatorContents = [string];

export class Creator implements XMLElement<'creator', CreatorAttributes, CreatorContents> {
  static readonly schema = {
    name: 'creator',
    attributes: { type: { type: 'optional', value: { type: 'string' } } },
    contents: [{ type: 'required', value: { type: 'string' } }],
  } as const;

  readonly schema = Creator.schema;

  attributes: CreatorAttributes;
  contents: CreatorContents;

  constructor(opts?: { attributes?: Partial<CreatorAttributes>; contents?: CreatorContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Creator.schema);
    this.contents = opts?.contents ?? operations.zero(Creator.schema.contents);
  }
  getType(): string | null {
    return this.attributes['type'];
  }
  setType(type: string | null): Creator {
    this.attributes['type'] = type;
    return this;
  }
  getText(): string {
    return this.contents[0];
  }
  setText(text: string): Creator {
    this.contents[0] = text;
    return this;
  }
}

export type RightsAttributes = { type: string | null };

export type RightsContents = [string];

export class Rights implements XMLElement<'rights', RightsAttributes, RightsContents> {
  static readonly schema = {
    name: 'rights',
    attributes: { type: { type: 'optional', value: { type: 'string' } } },
    contents: [{ type: 'required', value: { type: 'string' } }],
  } as const;

  readonly schema = Rights.schema;

  attributes: RightsAttributes;
  contents: RightsContents;

  constructor(opts?: { attributes?: Partial<RightsAttributes>; contents?: RightsContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Rights.schema);
    this.contents = opts?.contents ?? operations.zero(Rights.schema.contents);
  }
  getType(): string | null {
    return this.attributes['type'];
  }
  setType(type: string | null): Rights {
    this.attributes['type'] = type;
    return this;
  }
  getText(): string {
    return this.contents[0];
  }
  setText(text: string): Rights {
    this.contents[0] = text;
    return this;
  }
}

export type EncodingDateAttributes = Record<string, unknown>;

export type EncodingDateContents = [Date];

export class EncodingDate implements XMLElement<'encoding-date', EncodingDateAttributes, EncodingDateContents> {
  static readonly schema = {
    name: 'encoding-date',
    attributes: {},
    contents: [{ type: 'required', value: { type: 'label', label: 'yyyy-mm-dd', value: { type: 'date' } } }],
  } as const;

  readonly schema = EncodingDate.schema;

  attributes: EncodingDateAttributes;
  contents: EncodingDateContents;

  constructor(opts?: { attributes?: Partial<EncodingDateAttributes>; contents?: EncodingDateContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, EncodingDate.schema);
    this.contents = opts?.contents ?? operations.zero(EncodingDate.schema.contents);
  }

  getYyyyMmDd(): Date {
    return this.contents[0];
  }
  setYyyyMmDd(yyyyMmDd: Date): EncodingDate {
    this.contents[0] = yyyyMmDd;
    return this;
  }
}

export type EncoderAttributes = { type: string | null };

export type EncoderContents = [string];

export class Encoder implements XMLElement<'encoder', EncoderAttributes, EncoderContents> {
  static readonly schema = {
    name: 'encoder',
    attributes: { type: { type: 'optional', value: { type: 'string' } } },
    contents: [{ type: 'required', value: { type: 'string' } }],
  } as const;

  readonly schema = Encoder.schema;

  attributes: EncoderAttributes;
  contents: EncoderContents;

  constructor(opts?: { attributes?: Partial<EncoderAttributes>; contents?: EncoderContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Encoder.schema);
    this.contents = opts?.contents ?? operations.zero(Encoder.schema.contents);
  }
  getType(): string | null {
    return this.attributes['type'];
  }
  setType(type: string | null): Encoder {
    this.attributes['type'] = type;
    return this;
  }
  getText(): string {
    return this.contents[0];
  }
  setText(text: string): Encoder {
    this.contents[0] = text;
    return this;
  }
}

export type SoftwareAttributes = Record<string, unknown>;

export type SoftwareContents = [string];

export class Software implements XMLElement<'software', SoftwareAttributes, SoftwareContents> {
  static readonly schema = { name: 'software', attributes: {}, contents: [{ type: 'string' }] } as const;

  readonly schema = Software.schema;

  attributes: SoftwareAttributes;
  contents: SoftwareContents;

  constructor(opts?: { attributes?: Partial<SoftwareAttributes>; contents?: SoftwareContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Software.schema);
    this.contents = opts?.contents ?? operations.zero(Software.schema.contents);
  }

  getText(): string {
    return this.contents[0];
  }
  setText(text: string): Software {
    this.contents[0] = text;
    return this;
  }
}

export type EncodingDescriptionAttributes = Record<string, unknown>;

export type EncodingDescriptionContents = [string];

export class EncodingDescription
  implements XMLElement<'encoding-description', EncodingDescriptionAttributes, EncodingDescriptionContents>
{
  static readonly schema = {
    name: 'encoding-description',
    attributes: {},
    contents: [{ type: 'required', value: { type: 'string' } }],
  } as const;

  readonly schema = EncodingDescription.schema;

  attributes: EncodingDescriptionAttributes;
  contents: EncodingDescriptionContents;

  constructor(opts?: { attributes?: Partial<EncodingDescriptionAttributes>; contents?: EncodingDescriptionContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, EncodingDescription.schema);
    this.contents = opts?.contents ?? operations.zero(EncodingDescription.schema.contents);
  }

  getText(): string {
    return this.contents[0];
  }
  setText(text: string): EncodingDescription {
    this.contents[0] = text;
    return this;
  }
}

export type SupportsAttributes = {
  element: string;
  type: 'yes' | 'no';
  attribute: string | null;
  value: string | null;
};

export type SupportsContents = [];

export class Supports implements XMLElement<'supports', SupportsAttributes, SupportsContents> {
  static readonly schema = {
    name: 'supports',
    attributes: {
      element: { type: 'required', value: { type: 'string' } },
      type: { type: 'required', value: { type: 'choices', choices: ['yes', 'no'] } },
      attribute: { type: 'optional', value: { type: 'string' } },
      value: { type: 'optional', value: { type: 'string' } },
    },
    contents: [],
  } as const;

  readonly schema = Supports.schema;

  attributes: SupportsAttributes;
  contents: SupportsContents;

  constructor(opts?: { attributes?: Partial<SupportsAttributes>; contents?: SupportsContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Supports.schema);
    this.contents = opts?.contents ?? operations.zero(Supports.schema.contents);
  }
  getElement(): string {
    return this.attributes['element'];
  }
  setElement(element: string): Supports {
    this.attributes['element'] = element;
    return this;
  }
  getType(): 'yes' | 'no' {
    return this.attributes['type'];
  }
  setType(type: 'yes' | 'no'): Supports {
    this.attributes['type'] = type;
    return this;
  }
  getAttribute(): string | null {
    return this.attributes['attribute'];
  }
  setAttribute(attribute: string | null): Supports {
    this.attributes['attribute'] = attribute;
    return this;
  }
  getValue(): string | null {
    return this.attributes['value'];
  }
  setValue(value: string | null): Supports {
    this.attributes['value'] = value;
    return this;
  }
}

export type EncodingAttributes = Record<string, unknown>;

export type EncodingContents = [
  Array<[EncodingDate | null, Encoder | null, Software | null, EncodingDescription | null, Supports | null]>
];

export class Encoding implements XMLElement<'encoding', EncodingAttributes, EncodingContents> {
  static readonly schema = {
    name: 'encoding',
    attributes: {},
    contents: [
      {
        type: 'label',
        label: 'encodings',
        value: {
          type: 'zeroOrMore',
          value: [
            { type: 'optional', value: EncodingDate },
            { type: 'optional', value: Encoder },
            { type: 'optional', value: Software },
            { type: 'optional', value: EncodingDescription },
            { type: 'optional', value: Supports },
          ],
        },
      },
    ],
  } as const;

  readonly schema = Encoding.schema;

  attributes: EncodingAttributes;
  contents: EncodingContents;

  constructor(opts?: { attributes?: Partial<EncodingAttributes>; contents?: EncodingContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Encoding.schema);
    this.contents = opts?.contents ?? operations.zero(Encoding.schema.contents);
  }

  getEncodings(): Array<
    [EncodingDate | null, Encoder | null, Software | null, EncodingDescription | null, Supports | null]
  > {
    return this.contents[0];
  }
  setEncodings(
    encodings: Array<
      [EncodingDate | null, Encoder | null, Software | null, EncodingDescription | null, Supports | null]
    >
  ): Encoding {
    this.contents[0] = encodings;
    return this;
  }
}

export type SourceAttributes = Record<string, unknown>;

export type SourceContents = [string | null];

export class Source implements XMLElement<'source', SourceAttributes, SourceContents> {
  static readonly schema = {
    name: 'source',
    attributes: {},
    contents: [{ type: 'optional', value: { type: 'string' } }],
  } as const;

  readonly schema = Source.schema;

  attributes: SourceAttributes;
  contents: SourceContents;

  constructor(opts?: { attributes?: Partial<SourceAttributes>; contents?: SourceContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Source.schema);
    this.contents = opts?.contents ?? operations.zero(Source.schema.contents);
  }

  getText(): string | null {
    return this.contents[0];
  }
  setText(text: string | null): Source {
    this.contents[0] = text;
    return this;
  }
}

export type RelationAttributes = { type: string | null };

export type RelationContents = [string];

export class Relation implements XMLElement<'relation', RelationAttributes, RelationContents> {
  static readonly schema = {
    name: 'relation',
    attributes: { type: { type: 'optional', value: { type: 'string' } } },
    contents: [{ type: 'required', value: { type: 'string' } }],
  } as const;

  readonly schema = Relation.schema;

  attributes: RelationAttributes;
  contents: RelationContents;

  constructor(opts?: { attributes?: Partial<RelationAttributes>; contents?: RelationContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Relation.schema);
    this.contents = opts?.contents ?? operations.zero(Relation.schema.contents);
  }
  getType(): string | null {
    return this.attributes['type'];
  }
  setType(type: string | null): Relation {
    this.attributes['type'] = type;
    return this;
  }
  getText(): string {
    return this.contents[0];
  }
  setText(text: string): Relation {
    this.contents[0] = text;
    return this;
  }
}

export type MiscellaneousFieldAttributes = { name: string };

export type MiscellaneousFieldContents = [string];

export class MiscellaneousField
  implements XMLElement<'miscellaneous-field', MiscellaneousFieldAttributes, MiscellaneousFieldContents>
{
  static readonly schema = {
    name: 'miscellaneous-field',
    attributes: { name: { type: 'required', value: { type: 'string' } } },
    contents: [{ type: 'required', value: { type: 'string' } }],
  } as const;

  readonly schema = MiscellaneousField.schema;

  attributes: MiscellaneousFieldAttributes;
  contents: MiscellaneousFieldContents;

  constructor(opts?: { attributes?: Partial<MiscellaneousFieldAttributes>; contents?: MiscellaneousFieldContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, MiscellaneousField.schema);
    this.contents = opts?.contents ?? operations.zero(MiscellaneousField.schema.contents);
  }
  getName(): string {
    return this.attributes['name'];
  }
  setName(name: string): MiscellaneousField {
    this.attributes['name'] = name;
    return this;
  }
  getText(): string {
    return this.contents[0];
  }
  setText(text: string): MiscellaneousField {
    this.contents[0] = text;
    return this;
  }
}

export type MiscellaneousAttributes = Record<string, unknown>;

export type MiscellaneousContents = [Array<MiscellaneousField>];

export class Miscellaneous implements XMLElement<'miscellaneous', MiscellaneousAttributes, MiscellaneousContents> {
  static readonly schema = {
    name: 'miscellaneous',
    attributes: {},
    contents: [
      { type: 'label', label: 'miscellaneous-fields', value: { type: 'zeroOrMore', value: MiscellaneousField } },
    ],
  } as const;

  readonly schema = Miscellaneous.schema;

  attributes: MiscellaneousAttributes;
  contents: MiscellaneousContents;

  constructor(opts?: { attributes?: Partial<MiscellaneousAttributes>; contents?: MiscellaneousContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Miscellaneous.schema);
    this.contents = opts?.contents ?? operations.zero(Miscellaneous.schema.contents);
  }

  getMiscellaneousFields(): Array<MiscellaneousField> {
    return this.contents[0];
  }
  setMiscellaneousFields(miscellaneousFields: Array<MiscellaneousField>): Miscellaneous {
    this.contents[0] = miscellaneousFields;
    return this;
  }
}

export type IdentificationAttributes = Record<string, unknown>;

export type IdentificationContents = [
  Array<Creator>,
  Array<Rights>,
  Encoding | null,
  Source | null,
  Array<Relation>,
  Miscellaneous | null
];

export class Identification implements XMLElement<'identification', IdentificationAttributes, IdentificationContents> {
  static readonly schema = {
    name: 'identification',
    attributes: {},
    contents: [
      { type: 'label', label: 'creators', value: { type: 'zeroOrMore', value: Creator } },
      { type: 'label', label: 'rights', value: { type: 'zeroOrMore', value: Rights } },
      { type: 'optional', value: Encoding },
      { type: 'optional', value: Source },
      { type: 'label', label: 'relations', value: { type: 'zeroOrMore', value: Relation } },
      { type: 'optional', value: Miscellaneous },
    ],
  } as const;

  readonly schema = Identification.schema;

  attributes: IdentificationAttributes;
  contents: IdentificationContents;

  constructor(opts?: { attributes?: Partial<IdentificationAttributes>; contents?: IdentificationContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Identification.schema);
    this.contents = opts?.contents ?? operations.zero(Identification.schema.contents);
  }

  getCreators(): Array<Creator> {
    return this.contents[0];
  }
  setCreators(creators: Array<Creator>): Identification {
    this.contents[0] = creators;
    return this;
  }
  getRights(): Array<Rights> {
    return this.contents[1];
  }
  setRights(rights: Array<Rights>): Identification {
    this.contents[1] = rights;
    return this;
  }
  getEncoding(): Encoding | null {
    return this.contents[2];
  }
  setEncoding(encoding: Encoding | null): Identification {
    this.contents[2] = encoding;
    return this;
  }
  getSource(): Source | null {
    return this.contents[3];
  }
  setSource(source: Source | null): Identification {
    this.contents[3] = source;
    return this;
  }
  getRelations(): Array<Relation> {
    return this.contents[4];
  }
  setRelations(relations: Array<Relation>): Identification {
    this.contents[4] = relations;
    return this;
  }
  getMiscellaneous(): Miscellaneous | null {
    return this.contents[5];
  }
  setMiscellaneous(miscellaneous: Miscellaneous | null): Identification {
    this.contents[5] = miscellaneous;
    return this;
  }
}

export type MillimetersAttributes = Record<string, unknown>;

export type MillimetersContents = [number];

export class Millimeters implements XMLElement<'millimeters', MillimetersAttributes, MillimetersContents> {
  static readonly schema = {
    name: 'millimeters',
    attributes: {},
    contents: [
      {
        type: 'required',
        value: { type: 'label', label: 'millimeters', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
    ],
  } as const;

  readonly schema = Millimeters.schema;

  attributes: MillimetersAttributes;
  contents: MillimetersContents;

  constructor(opts?: { attributes?: Partial<MillimetersAttributes>; contents?: MillimetersContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Millimeters.schema);
    this.contents = opts?.contents ?? operations.zero(Millimeters.schema.contents);
  }

  getMillimeters(): number {
    return this.contents[0];
  }
  setMillimeters(millimeters: number): Millimeters {
    this.contents[0] = millimeters;
    return this;
  }
}

export type TenthsAttributes = Record<string, unknown>;

export type TenthsContents = [number];

export class Tenths implements XMLElement<'tenths', TenthsAttributes, TenthsContents> {
  static readonly schema = {
    name: 'tenths',
    attributes: {},
    contents: [
      {
        type: 'label',
        label: 'tenths-value',
        value: { type: 'required', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
    ],
  } as const;

  readonly schema = Tenths.schema;

  attributes: TenthsAttributes;
  contents: TenthsContents;

  constructor(opts?: { attributes?: Partial<TenthsAttributes>; contents?: TenthsContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Tenths.schema);
    this.contents = opts?.contents ?? operations.zero(Tenths.schema.contents);
  }

  getTenthsValue(): number {
    return this.contents[0];
  }
  setTenthsValue(tenthsValue: number): Tenths {
    this.contents[0] = tenthsValue;
    return this;
  }
}

export type ScalingAttributes = Record<string, unknown>;

export type ScalingContents = [Millimeters, Tenths];

export class Scaling implements XMLElement<'scaling', ScalingAttributes, ScalingContents> {
  static readonly schema = {
    name: 'scaling',
    attributes: {},
    contents: [
      { type: 'required', value: Millimeters },
      { type: 'required', value: Tenths },
    ],
  } as const;

  readonly schema = Scaling.schema;

  attributes: ScalingAttributes;
  contents: ScalingContents;

  constructor(opts?: { attributes?: Partial<ScalingAttributes>; contents?: ScalingContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Scaling.schema);
    this.contents = opts?.contents ?? operations.zero(Scaling.schema.contents);
  }

  getMillimeters(): Millimeters {
    return this.contents[0];
  }
  setMillimeters(millimeters: Millimeters): Scaling {
    this.contents[0] = millimeters;
    return this;
  }
  getTenths(): Tenths {
    return this.contents[1];
  }
  setTenths(tenths: Tenths): Scaling {
    this.contents[1] = tenths;
    return this;
  }
}

export type ConcertScoreAttributes = Record<string, unknown>;

export type ConcertScoreContents = [];

export class ConcertScore implements XMLElement<'concert-score', ConcertScoreAttributes, ConcertScoreContents> {
  static readonly schema = { name: 'concert-score', attributes: {}, contents: [] } as const;

  readonly schema = ConcertScore.schema;

  attributes: ConcertScoreAttributes;
  contents: ConcertScoreContents;

  constructor(opts?: { attributes?: Partial<ConcertScoreAttributes>; contents?: ConcertScoreContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, ConcertScore.schema);
    this.contents = opts?.contents ?? operations.zero(ConcertScore.schema.contents);
  }
}

export type PageHeightAttributes = Record<string, unknown>;

export type PageHeightContents = [number];

export class PageHeight implements XMLElement<'page-height', PageHeightAttributes, PageHeightContents> {
  static readonly schema = {
    name: 'page-height',
    attributes: {},
    contents: [
      {
        type: 'label',
        label: 'page-height-value',
        value: { type: 'required', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
    ],
  } as const;

  readonly schema = PageHeight.schema;

  attributes: PageHeightAttributes;
  contents: PageHeightContents;

  constructor(opts?: { attributes?: Partial<PageHeightAttributes>; contents?: PageHeightContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, PageHeight.schema);
    this.contents = opts?.contents ?? operations.zero(PageHeight.schema.contents);
  }

  getPageHeightValue(): number {
    return this.contents[0];
  }
  setPageHeightValue(pageHeightValue: number): PageHeight {
    this.contents[0] = pageHeightValue;
    return this;
  }
}

export type PageWidthAttributes = Record<string, unknown>;

export type PageWidthContents = [number];

export class PageWidth implements XMLElement<'page-width', PageWidthAttributes, PageWidthContents> {
  static readonly schema = {
    name: 'page-width',
    attributes: {},
    contents: [
      {
        type: 'label',
        label: 'page-width-value',
        value: { type: 'required', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
    ],
  } as const;

  readonly schema = PageWidth.schema;

  attributes: PageWidthAttributes;
  contents: PageWidthContents;

  constructor(opts?: { attributes?: Partial<PageWidthAttributes>; contents?: PageWidthContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, PageWidth.schema);
    this.contents = opts?.contents ?? operations.zero(PageWidth.schema.contents);
  }

  getPageWidthValue(): number {
    return this.contents[0];
  }
  setPageWidthValue(pageWidthValue: number): PageWidth {
    this.contents[0] = pageWidthValue;
    return this;
  }
}

export type LeftMarginAttributes = Record<string, unknown>;

export type LeftMarginContents = [number];

export class LeftMargin implements XMLElement<'left-margin', LeftMarginAttributes, LeftMarginContents> {
  static readonly schema = {
    name: 'left-margin',
    attributes: {},
    contents: [
      {
        type: 'label',
        label: 'left-margin',
        value: { type: 'required', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
    ],
  } as const;

  readonly schema = LeftMargin.schema;

  attributes: LeftMarginAttributes;
  contents: LeftMarginContents;

  constructor(opts?: { attributes?: Partial<LeftMarginAttributes>; contents?: LeftMarginContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, LeftMargin.schema);
    this.contents = opts?.contents ?? operations.zero(LeftMargin.schema.contents);
  }

  getLeftMargin(): number {
    return this.contents[0];
  }
  setLeftMargin(leftMargin: number): LeftMargin {
    this.contents[0] = leftMargin;
    return this;
  }
}

export type RightMarginAttributes = Record<string, unknown>;

export type RightMarginContents = [number];

export class RightMargin implements XMLElement<'right-margin', RightMarginAttributes, RightMarginContents> {
  static readonly schema = {
    name: 'right-margin',
    attributes: {},
    contents: [{ type: 'label', label: 'right-margin-value', value: { type: 'float', min: -Infinity, max: Infinity } }],
  } as const;

  readonly schema = RightMargin.schema;

  attributes: RightMarginAttributes;
  contents: RightMarginContents;

  constructor(opts?: { attributes?: Partial<RightMarginAttributes>; contents?: RightMarginContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, RightMargin.schema);
    this.contents = opts?.contents ?? operations.zero(RightMargin.schema.contents);
  }

  getRightMarginValue(): number {
    return this.contents[0];
  }
  setRightMarginValue(rightMarginValue: number): RightMargin {
    this.contents[0] = rightMarginValue;
    return this;
  }
}

export type TopMarginAttributes = Record<string, unknown>;

export type TopMarginContents = [number];

export class TopMargin implements XMLElement<'top-margin', TopMarginAttributes, TopMarginContents> {
  static readonly schema = {
    name: 'top-margin',
    attributes: {},
    contents: [
      {
        type: 'label',
        label: 'top-margin-value',
        value: { type: 'required', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
    ],
  } as const;

  readonly schema = TopMargin.schema;

  attributes: TopMarginAttributes;
  contents: TopMarginContents;

  constructor(opts?: { attributes?: Partial<TopMarginAttributes>; contents?: TopMarginContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, TopMargin.schema);
    this.contents = opts?.contents ?? operations.zero(TopMargin.schema.contents);
  }

  getTopMarginValue(): number {
    return this.contents[0];
  }
  setTopMarginValue(topMarginValue: number): TopMargin {
    this.contents[0] = topMarginValue;
    return this;
  }
}

export type BottomMarginAttributes = Record<string, unknown>;

export type BottomMarginContents = [number];

export class BottomMargin implements XMLElement<'bottom-margin', BottomMarginAttributes, BottomMarginContents> {
  static readonly schema = {
    name: 'bottom-margin',
    attributes: {},
    contents: [
      {
        type: 'label',
        label: 'bottom-margin',
        value: { type: 'required', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
    ],
  } as const;

  readonly schema = BottomMargin.schema;

  attributes: BottomMarginAttributes;
  contents: BottomMarginContents;

  constructor(opts?: { attributes?: Partial<BottomMarginAttributes>; contents?: BottomMarginContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, BottomMargin.schema);
    this.contents = opts?.contents ?? operations.zero(BottomMargin.schema.contents);
  }

  getBottomMargin(): number {
    return this.contents[0];
  }
  setBottomMargin(bottomMargin: number): BottomMargin {
    this.contents[0] = bottomMargin;
    return this;
  }
}

export type PageMarginsAttributes = { type: 'both' | 'even' | 'odd' | null };

export type PageMarginsContents = [LeftMargin, RightMargin, TopMargin, BottomMargin];

export class PageMargins implements XMLElement<'page-margins', PageMarginsAttributes, PageMarginsContents> {
  static readonly schema = {
    name: 'page-margins',
    attributes: { type: { type: 'optional', value: { type: 'choices', choices: ['both', 'even', 'odd'] } } },
    contents: [
      { type: 'required', value: LeftMargin },
      { type: 'required', value: RightMargin },
      { type: 'required', value: TopMargin },
      { type: 'required', value: BottomMargin },
    ],
  } as const;

  readonly schema = PageMargins.schema;

  attributes: PageMarginsAttributes;
  contents: PageMarginsContents;

  constructor(opts?: { attributes?: Partial<PageMarginsAttributes>; contents?: PageMarginsContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, PageMargins.schema);
    this.contents = opts?.contents ?? operations.zero(PageMargins.schema.contents);
  }
  getType(): 'both' | 'even' | 'odd' | null {
    return this.attributes['type'];
  }
  setType(type: 'both' | 'even' | 'odd' | null): PageMargins {
    this.attributes['type'] = type;
    return this;
  }
  getLeftMargin(): LeftMargin {
    return this.contents[0];
  }
  setLeftMargin(leftMargin: LeftMargin): PageMargins {
    this.contents[0] = leftMargin;
    return this;
  }
  getRightMargin(): RightMargin {
    return this.contents[1];
  }
  setRightMargin(rightMargin: RightMargin): PageMargins {
    this.contents[1] = rightMargin;
    return this;
  }
  getTopMargin(): TopMargin {
    return this.contents[2];
  }
  setTopMargin(topMargin: TopMargin): PageMargins {
    this.contents[2] = topMargin;
    return this;
  }
  getBottomMargin(): BottomMargin {
    return this.contents[3];
  }
  setBottomMargin(bottomMargin: BottomMargin): PageMargins {
    this.contents[3] = bottomMargin;
    return this;
  }
}

export type PageLayoutAttributes = Record<string, unknown>;

export type PageLayoutContents = [PageHeight | null, PageWidth | null, [] | [PageMargins] | [PageMargins, PageMargins]];

export class PageLayout implements XMLElement<'page-layout', PageLayoutAttributes, PageLayoutContents> {
  static readonly schema = {
    name: 'page-layout',
    attributes: {},
    contents: [
      { type: 'optional', value: PageHeight },
      { type: 'optional', value: PageWidth },
      {
        type: 'label',
        label: 'page-margins',
        value: { type: 'choices', choices: [[], [PageMargins], [PageMargins, PageMargins]] },
      },
    ],
  } as const;

  readonly schema = PageLayout.schema;

  attributes: PageLayoutAttributes;
  contents: PageLayoutContents;

  constructor(opts?: { attributes?: Partial<PageLayoutAttributes>; contents?: PageLayoutContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, PageLayout.schema);
    this.contents = opts?.contents ?? operations.zero(PageLayout.schema.contents);
  }

  getPageHeight(): PageHeight | null {
    return this.contents[0];
  }
  setPageHeight(pageHeight: PageHeight | null): PageLayout {
    this.contents[0] = pageHeight;
    return this;
  }
  getPageWidth(): PageWidth | null {
    return this.contents[1];
  }
  setPageWidth(pageWidth: PageWidth | null): PageLayout {
    this.contents[1] = pageWidth;
    return this;
  }
  getPageMargins(): [] | [PageMargins] | [PageMargins, PageMargins] {
    return this.contents[2];
  }
  setPageMargins(pageMargins: [] | [PageMargins] | [PageMargins, PageMargins]): PageLayout {
    this.contents[2] = pageMargins;
    return this;
  }
}

export type SystemMarginsAttributes = Record<string, unknown>;

export type SystemMarginsContents = [LeftMargin, RightMargin];

export class SystemMargins implements XMLElement<'system-margins', SystemMarginsAttributes, SystemMarginsContents> {
  static readonly schema = {
    name: 'system-margins',
    attributes: {},
    contents: [
      { type: 'required', value: LeftMargin },
      { type: 'required', value: RightMargin },
    ],
  } as const;

  readonly schema = SystemMargins.schema;

  attributes: SystemMarginsAttributes;
  contents: SystemMarginsContents;

  constructor(opts?: { attributes?: Partial<SystemMarginsAttributes>; contents?: SystemMarginsContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, SystemMargins.schema);
    this.contents = opts?.contents ?? operations.zero(SystemMargins.schema.contents);
  }

  getLeftMargin(): LeftMargin {
    return this.contents[0];
  }
  setLeftMargin(leftMargin: LeftMargin): SystemMargins {
    this.contents[0] = leftMargin;
    return this;
  }
  getRightMargin(): RightMargin {
    return this.contents[1];
  }
  setRightMargin(rightMargin: RightMargin): SystemMargins {
    this.contents[1] = rightMargin;
    return this;
  }
}

export type SystemDistanceAttributes = Record<string, unknown>;

export type SystemDistanceContents = [number];

export class SystemDistance implements XMLElement<'system-distance', SystemDistanceAttributes, SystemDistanceContents> {
  static readonly schema = {
    name: 'system-distance',
    attributes: {},
    contents: [
      {
        type: 'label',
        label: 'system-distance-value',
        value: { type: 'required', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
    ],
  } as const;

  readonly schema = SystemDistance.schema;

  attributes: SystemDistanceAttributes;
  contents: SystemDistanceContents;

  constructor(opts?: { attributes?: Partial<SystemDistanceAttributes>; contents?: SystemDistanceContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, SystemDistance.schema);
    this.contents = opts?.contents ?? operations.zero(SystemDistance.schema.contents);
  }

  getSystemDistanceValue(): number {
    return this.contents[0];
  }
  setSystemDistanceValue(systemDistanceValue: number): SystemDistance {
    this.contents[0] = systemDistanceValue;
    return this;
  }
}

export type TopSystemDistanceAttributes = Record<string, unknown>;

export type TopSystemDistanceContents = [number];

export class TopSystemDistance
  implements XMLElement<'top-system-distance', TopSystemDistanceAttributes, TopSystemDistanceContents>
{
  static readonly schema = {
    name: 'top-system-distance',
    attributes: {},
    contents: [
      {
        type: 'label',
        label: 'top-system-distance-value',
        value: { type: 'required', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
    ],
  } as const;

  readonly schema = TopSystemDistance.schema;

  attributes: TopSystemDistanceAttributes;
  contents: TopSystemDistanceContents;

  constructor(opts?: { attributes?: Partial<TopSystemDistanceAttributes>; contents?: TopSystemDistanceContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, TopSystemDistance.schema);
    this.contents = opts?.contents ?? operations.zero(TopSystemDistance.schema.contents);
  }

  getTopSystemDistanceValue(): number {
    return this.contents[0];
  }
  setTopSystemDistanceValue(topSystemDistanceValue: number): TopSystemDistance {
    this.contents[0] = topSystemDistanceValue;
    return this;
  }
}

export type SystemLayoutAttributes = Record<string, unknown>;

export type SystemLayoutContents = [SystemMargins | null, SystemDistance | null, TopSystemDistance | null];

export class SystemLayout implements XMLElement<'system-layout', SystemLayoutAttributes, SystemLayoutContents> {
  static readonly schema = {
    name: 'system-layout',
    attributes: {},
    contents: [
      { type: 'optional', value: SystemMargins },
      { type: 'optional', value: SystemDistance },
      { type: 'optional', value: TopSystemDistance },
    ],
  } as const;

  readonly schema = SystemLayout.schema;

  attributes: SystemLayoutAttributes;
  contents: SystemLayoutContents;

  constructor(opts?: { attributes?: Partial<SystemLayoutAttributes>; contents?: SystemLayoutContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, SystemLayout.schema);
    this.contents = opts?.contents ?? operations.zero(SystemLayout.schema.contents);
  }

  getSystemMargins(): SystemMargins | null {
    return this.contents[0];
  }
  setSystemMargins(systemMargins: SystemMargins | null): SystemLayout {
    this.contents[0] = systemMargins;
    return this;
  }
  getSystemDistance(): SystemDistance | null {
    return this.contents[1];
  }
  setSystemDistance(systemDistance: SystemDistance | null): SystemLayout {
    this.contents[1] = systemDistance;
    return this;
  }
  getTopSystemDistance(): TopSystemDistance | null {
    return this.contents[2];
  }
  setTopSystemDistance(topSystemDistance: TopSystemDistance | null): SystemLayout {
    this.contents[2] = topSystemDistance;
    return this;
  }
}

export type StaffDistanceAttributes = Record<string, unknown>;

export type StaffDistanceContents = [number];

export class StaffDistance implements XMLElement<'staff-distance', StaffDistanceAttributes, StaffDistanceContents> {
  static readonly schema = {
    name: 'staff-distance',
    attributes: {},
    contents: [
      {
        type: 'label',
        label: 'staff-distance-value',
        value: { type: 'required', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
    ],
  } as const;

  readonly schema = StaffDistance.schema;

  attributes: StaffDistanceAttributes;
  contents: StaffDistanceContents;

  constructor(opts?: { attributes?: Partial<StaffDistanceAttributes>; contents?: StaffDistanceContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, StaffDistance.schema);
    this.contents = opts?.contents ?? operations.zero(StaffDistance.schema.contents);
  }

  getStaffDistanceValue(): number {
    return this.contents[0];
  }
  setStaffDistanceValue(staffDistanceValue: number): StaffDistance {
    this.contents[0] = staffDistanceValue;
    return this;
  }
}

export type StaffLayoutAttributes = { number: number | null };

export type StaffLayoutContents = [StaffDistance | null];

export class StaffLayout implements XMLElement<'staff-layout', StaffLayoutAttributes, StaffLayoutContents> {
  static readonly schema = {
    name: 'staff-layout',
    attributes: { number: { type: 'optional', value: { type: 'int', min: 1, max: Infinity } } },
    contents: [{ type: 'optional', value: StaffDistance }],
  } as const;

  readonly schema = StaffLayout.schema;

  attributes: StaffLayoutAttributes;
  contents: StaffLayoutContents;

  constructor(opts?: { attributes?: Partial<StaffLayoutAttributes>; contents?: StaffLayoutContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, StaffLayout.schema);
    this.contents = opts?.contents ?? operations.zero(StaffLayout.schema.contents);
  }
  getNumber(): number | null {
    return this.attributes['number'];
  }
  setNumber(number: number | null): StaffLayout {
    this.attributes['number'] = number;
    return this;
  }
  getStaffDistance(): StaffDistance | null {
    return this.contents[0];
  }
  setStaffDistance(staffDistance: StaffDistance | null): StaffLayout {
    this.contents[0] = staffDistance;
    return this;
  }
}

export type LineWidthAttributes = {
  type:
    | 'beam'
    | 'bracket'
    | 'dashes'
    | 'enclosure'
    | 'ending'
    | 'extend'
    | 'heavy barline'
    | 'leger'
    | 'light barline'
    | 'octave shift'
    | 'pedal'
    | 'slur middle'
    | 'slur tip'
    | 'staff'
    | 'stem'
    | 'tie middle'
    | 'tie tip'
    | 'tuplet bracket'
    | 'wedge';
};

export type LineWidthContents = [number];

export class LineWidth implements XMLElement<'line-width', LineWidthAttributes, LineWidthContents> {
  static readonly schema = {
    name: 'line-width',
    attributes: {
      type: {
        type: 'required',
        value: {
          type: 'choices',
          choices: [
            'beam',
            'bracket',
            'dashes',
            'enclosure',
            'ending',
            'extend',
            'heavy barline',
            'leger',
            'light barline',
            'octave shift',
            'pedal',
            'slur middle',
            'slur tip',
            'staff',
            'stem',
            'tie middle',
            'tie tip',
            'tuplet bracket',
            'wedge',
          ],
        },
      },
    },
    contents: [
      {
        type: 'label',
        label: 'line-width',
        value: { type: 'required', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
    ],
  } as const;

  readonly schema = LineWidth.schema;

  attributes: LineWidthAttributes;
  contents: LineWidthContents;

  constructor(opts?: { attributes?: Partial<LineWidthAttributes>; contents?: LineWidthContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, LineWidth.schema);
    this.contents = opts?.contents ?? operations.zero(LineWidth.schema.contents);
  }
  getType():
    | 'beam'
    | 'bracket'
    | 'dashes'
    | 'enclosure'
    | 'ending'
    | 'extend'
    | 'heavy barline'
    | 'leger'
    | 'light barline'
    | 'octave shift'
    | 'pedal'
    | 'slur middle'
    | 'slur tip'
    | 'staff'
    | 'stem'
    | 'tie middle'
    | 'tie tip'
    | 'tuplet bracket'
    | 'wedge' {
    return this.attributes['type'];
  }
  setType(
    type:
      | 'beam'
      | 'bracket'
      | 'dashes'
      | 'enclosure'
      | 'ending'
      | 'extend'
      | 'heavy barline'
      | 'leger'
      | 'light barline'
      | 'octave shift'
      | 'pedal'
      | 'slur middle'
      | 'slur tip'
      | 'staff'
      | 'stem'
      | 'tie middle'
      | 'tie tip'
      | 'tuplet bracket'
      | 'wedge'
  ): LineWidth {
    this.attributes['type'] = type;
    return this;
  }
  getLineWidth(): number {
    return this.contents[0];
  }
  setLineWidth(lineWidth: number): LineWidth {
    this.contents[0] = lineWidth;
    return this;
  }
}

export type NoteSizeAttributes = { type: 'cue' | 'grace' | 'grace-cue' | 'large' };

export type NoteSizeContents = [number];

export class NoteSize implements XMLElement<'note-size', NoteSizeAttributes, NoteSizeContents> {
  static readonly schema = {
    name: 'note-size',
    attributes: {
      type: { type: 'required', value: { type: 'choices', choices: ['cue', 'grace', 'grace-cue', 'large'] } },
    },
    contents: [{ type: 'label', label: 'note-size', value: { type: 'float', min: 0, max: Infinity } }],
  } as const;

  readonly schema = NoteSize.schema;

  attributes: NoteSizeAttributes;
  contents: NoteSizeContents;

  constructor(opts?: { attributes?: Partial<NoteSizeAttributes>; contents?: NoteSizeContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, NoteSize.schema);
    this.contents = opts?.contents ?? operations.zero(NoteSize.schema.contents);
  }
  getType(): 'cue' | 'grace' | 'grace-cue' | 'large' {
    return this.attributes['type'];
  }
  setType(type: 'cue' | 'grace' | 'grace-cue' | 'large'): NoteSize {
    this.attributes['type'] = type;
    return this;
  }
  getNoteSize(): number {
    return this.contents[0];
  }
  setNoteSize(noteSize: number): NoteSize {
    this.contents[0] = noteSize;
    return this;
  }
}

export type DistanceAttributes = { type: 'beam' | 'hyphen' };

export type DistanceContents = [number];

export class Distance implements XMLElement<'distance', DistanceAttributes, DistanceContents> {
  static readonly schema = {
    name: 'distance',
    attributes: { type: { type: 'required', value: { type: 'choices', choices: ['beam', 'hyphen'] } } },
    contents: [
      {
        type: 'label',
        label: 'distance',
        value: { type: 'required', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
    ],
  } as const;

  readonly schema = Distance.schema;

  attributes: DistanceAttributes;
  contents: DistanceContents;

  constructor(opts?: { attributes?: Partial<DistanceAttributes>; contents?: DistanceContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Distance.schema);
    this.contents = opts?.contents ?? operations.zero(Distance.schema.contents);
  }
  getType(): 'beam' | 'hyphen' {
    return this.attributes['type'];
  }
  setType(type: 'beam' | 'hyphen'): Distance {
    this.attributes['type'] = type;
    return this;
  }
  getDistance(): number {
    return this.contents[0];
  }
  setDistance(distance: number): Distance {
    this.contents[0] = distance;
    return this;
  }
}

export type GlyphAttributes = {
  type:
    | 'quarter-rest'
    | 'g-clef-ottava-bassa'
    | 'c-clef'
    | 'f-clef'
    | 'percussion-clef'
    | 'octave-shift-up-8'
    | 'octave-shift-down-8'
    | 'octave-shift-down-15'
    | 'octave-shift-continue-15'
    | 'octave-shift-down-22'
    | 'octave-shift-up-22'
    | 'octave-shift-continue-22';
};

export type GlyphContents = [string];

export class Glyph implements XMLElement<'glyph', GlyphAttributes, GlyphContents> {
  static readonly schema = {
    name: 'glyph',
    attributes: {
      type: {
        type: 'required',
        value: {
          type: 'choices',
          choices: [
            'quarter-rest',
            'g-clef-ottava-bassa',
            'c-clef',
            'f-clef',
            'percussion-clef',
            'octave-shift-up-8',
            'octave-shift-down-8',
            'octave-shift-down-15',
            'octave-shift-continue-15',
            'octave-shift-down-22',
            'octave-shift-up-22',
            'octave-shift-continue-22',
          ],
        },
      },
    },
    contents: [{ type: 'required', value: { type: 'string' } }],
  } as const;

  readonly schema = Glyph.schema;

  attributes: GlyphAttributes;
  contents: GlyphContents;

  constructor(opts?: { attributes?: Partial<GlyphAttributes>; contents?: GlyphContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Glyph.schema);
    this.contents = opts?.contents ?? operations.zero(Glyph.schema.contents);
  }
  getType():
    | 'quarter-rest'
    | 'g-clef-ottava-bassa'
    | 'c-clef'
    | 'f-clef'
    | 'percussion-clef'
    | 'octave-shift-up-8'
    | 'octave-shift-down-8'
    | 'octave-shift-down-15'
    | 'octave-shift-continue-15'
    | 'octave-shift-down-22'
    | 'octave-shift-up-22'
    | 'octave-shift-continue-22' {
    return this.attributes['type'];
  }
  setType(
    type:
      | 'quarter-rest'
      | 'g-clef-ottava-bassa'
      | 'c-clef'
      | 'f-clef'
      | 'percussion-clef'
      | 'octave-shift-up-8'
      | 'octave-shift-down-8'
      | 'octave-shift-down-15'
      | 'octave-shift-continue-15'
      | 'octave-shift-down-22'
      | 'octave-shift-up-22'
      | 'octave-shift-continue-22'
  ): Glyph {
    this.attributes['type'] = type;
    return this;
  }
  getText(): string {
    return this.contents[0];
  }
  setText(text: string): Glyph {
    this.contents[0] = text;
    return this;
  }
}

export type OtherAppearanceAttributes = { type: string };

export type OtherAppearanceContents = [string];

export class OtherAppearance
  implements XMLElement<'other-appearance', OtherAppearanceAttributes, OtherAppearanceContents>
{
  static readonly schema = {
    name: 'other-appearance',
    attributes: { type: { type: 'required', value: { type: 'string' } } },
    contents: [{ type: 'required', value: { type: 'string' } }],
  } as const;

  readonly schema = OtherAppearance.schema;

  attributes: OtherAppearanceAttributes;
  contents: OtherAppearanceContents;

  constructor(opts?: { attributes?: Partial<OtherAppearanceAttributes>; contents?: OtherAppearanceContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, OtherAppearance.schema);
    this.contents = opts?.contents ?? operations.zero(OtherAppearance.schema.contents);
  }
  getType(): string {
    return this.attributes['type'];
  }
  setType(type: string): OtherAppearance {
    this.attributes['type'] = type;
    return this;
  }
  getText(): string {
    return this.contents[0];
  }
  setText(text: string): OtherAppearance {
    this.contents[0] = text;
    return this;
  }
}

export type AppearanceAttributes = Record<string, unknown>;

export type AppearanceContents = [
  Array<LineWidth>,
  Array<NoteSize>,
  Array<Distance>,
  Array<Glyph>,
  Array<OtherAppearance>
];

export class Appearance implements XMLElement<'appearance', AppearanceAttributes, AppearanceContents> {
  static readonly schema = {
    name: 'appearance',
    attributes: {},
    contents: [
      { type: 'label', label: 'line-widths', value: { type: 'zeroOrMore', value: LineWidth } },
      { type: 'label', label: 'note-sizes', value: { type: 'zeroOrMore', value: NoteSize } },
      { type: 'label', label: 'distances', value: { type: 'zeroOrMore', value: Distance } },
      { type: 'label', label: 'glyphs', value: { type: 'zeroOrMore', value: Glyph } },
      { type: 'label', label: 'other-appearances', value: { type: 'zeroOrMore', value: OtherAppearance } },
    ],
  } as const;

  readonly schema = Appearance.schema;

  attributes: AppearanceAttributes;
  contents: AppearanceContents;

  constructor(opts?: { attributes?: Partial<AppearanceAttributes>; contents?: AppearanceContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Appearance.schema);
    this.contents = opts?.contents ?? operations.zero(Appearance.schema.contents);
  }

  getLineWidths(): Array<LineWidth> {
    return this.contents[0];
  }
  setLineWidths(lineWidths: Array<LineWidth>): Appearance {
    this.contents[0] = lineWidths;
    return this;
  }
  getNoteSizes(): Array<NoteSize> {
    return this.contents[1];
  }
  setNoteSizes(noteSizes: Array<NoteSize>): Appearance {
    this.contents[1] = noteSizes;
    return this;
  }
  getDistances(): Array<Distance> {
    return this.contents[2];
  }
  setDistances(distances: Array<Distance>): Appearance {
    this.contents[2] = distances;
    return this;
  }
  getGlyphs(): Array<Glyph> {
    return this.contents[3];
  }
  setGlyphs(glyphs: Array<Glyph>): Appearance {
    this.contents[3] = glyphs;
    return this;
  }
  getOtherAppearances(): Array<OtherAppearance> {
    return this.contents[4];
  }
  setOtherAppearances(otherAppearances: Array<OtherAppearance>): Appearance {
    this.contents[4] = otherAppearances;
    return this;
  }
}

export type MusicFontAttributes = {
  'font-family': string | null;
  'font-size': 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null;
  'font-style': 'normal' | 'italic' | null;
  'font-weight': 'normal' | 'bold' | null;
};

export type MusicFontContents = [];

export class MusicFont implements XMLElement<'music-font', MusicFontAttributes, MusicFontContents> {
  static readonly schema = {
    name: 'music-font',
    attributes: {
      'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
      'font-size': {
        type: 'optional',
        value: {
          type: 'choices',
          choices: [
            { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
            { type: 'float', min: -Infinity, max: Infinity },
          ],
        },
      },
      'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
      'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
    },
    contents: [],
  } as const;

  readonly schema = MusicFont.schema;

  attributes: MusicFontAttributes;
  contents: MusicFontContents;

  constructor(opts?: { attributes?: Partial<MusicFontAttributes>; contents?: MusicFontContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, MusicFont.schema);
    this.contents = opts?.contents ?? operations.zero(MusicFont.schema.contents);
  }
  getFontFamily(): string | null {
    return this.attributes['font-family'];
  }
  setFontFamily(fontFamily: string | null): MusicFont {
    this.attributes['font-family'] = fontFamily;
    return this;
  }
  getFontSize(): 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null {
    return this.attributes['font-size'];
  }
  setFontSize(
    fontSize: 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null
  ): MusicFont {
    this.attributes['font-size'] = fontSize;
    return this;
  }
  getFontStyle(): 'normal' | 'italic' | null {
    return this.attributes['font-style'];
  }
  setFontStyle(fontStyle: 'normal' | 'italic' | null): MusicFont {
    this.attributes['font-style'] = fontStyle;
    return this;
  }
  getFontWeight(): 'normal' | 'bold' | null {
    return this.attributes['font-weight'];
  }
  setFontWeight(fontWeight: 'normal' | 'bold' | null): MusicFont {
    this.attributes['font-weight'] = fontWeight;
    return this;
  }
}

export type WordFontAttributes = {
  'font-family': string | null;
  'font-size': 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null;
  'font-style': 'normal' | 'italic' | null;
  'font-weight': 'normal' | 'bold' | null;
};

export type WordFontContents = [];

export class WordFont implements XMLElement<'word-font', WordFontAttributes, WordFontContents> {
  static readonly schema = {
    name: 'word-font',
    attributes: {
      'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
      'font-size': {
        type: 'optional',
        value: {
          type: 'choices',
          choices: [
            { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
            { type: 'float', min: -Infinity, max: Infinity },
          ],
        },
      },
      'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
      'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
    },
    contents: [],
  } as const;

  readonly schema = WordFont.schema;

  attributes: WordFontAttributes;
  contents: WordFontContents;

  constructor(opts?: { attributes?: Partial<WordFontAttributes>; contents?: WordFontContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, WordFont.schema);
    this.contents = opts?.contents ?? operations.zero(WordFont.schema.contents);
  }
  getFontFamily(): string | null {
    return this.attributes['font-family'];
  }
  setFontFamily(fontFamily: string | null): WordFont {
    this.attributes['font-family'] = fontFamily;
    return this;
  }
  getFontSize(): 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null {
    return this.attributes['font-size'];
  }
  setFontSize(
    fontSize: 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null
  ): WordFont {
    this.attributes['font-size'] = fontSize;
    return this;
  }
  getFontStyle(): 'normal' | 'italic' | null {
    return this.attributes['font-style'];
  }
  setFontStyle(fontStyle: 'normal' | 'italic' | null): WordFont {
    this.attributes['font-style'] = fontStyle;
    return this;
  }
  getFontWeight(): 'normal' | 'bold' | null {
    return this.attributes['font-weight'];
  }
  setFontWeight(fontWeight: 'normal' | 'bold' | null): WordFont {
    this.attributes['font-weight'] = fontWeight;
    return this;
  }
}

export type LyricFontAttributes = {
  'font-family': string | null;
  'font-size': 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null;
  'font-style': 'normal' | 'italic' | null;
  'font-weight': 'normal' | 'bold' | null;
  name: string | null;
  number: string | null;
};

export type LyricFontContents = [];

export class LyricFont implements XMLElement<'lyric-font', LyricFontAttributes, LyricFontContents> {
  static readonly schema = {
    name: 'lyric-font',
    attributes: {
      'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
      'font-size': {
        type: 'optional',
        value: {
          type: 'choices',
          choices: [
            { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
            { type: 'float', min: -Infinity, max: Infinity },
          ],
        },
      },
      'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
      'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
      name: { type: 'optional', value: { type: 'string' } },
      number: { type: 'optional', value: { type: 'string' } },
    },
    contents: [],
  } as const;

  readonly schema = LyricFont.schema;

  attributes: LyricFontAttributes;
  contents: LyricFontContents;

  constructor(opts?: { attributes?: Partial<LyricFontAttributes>; contents?: LyricFontContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, LyricFont.schema);
    this.contents = opts?.contents ?? operations.zero(LyricFont.schema.contents);
  }
  getFontFamily(): string | null {
    return this.attributes['font-family'];
  }
  setFontFamily(fontFamily: string | null): LyricFont {
    this.attributes['font-family'] = fontFamily;
    return this;
  }
  getFontSize(): 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null {
    return this.attributes['font-size'];
  }
  setFontSize(
    fontSize: 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null
  ): LyricFont {
    this.attributes['font-size'] = fontSize;
    return this;
  }
  getFontStyle(): 'normal' | 'italic' | null {
    return this.attributes['font-style'];
  }
  setFontStyle(fontStyle: 'normal' | 'italic' | null): LyricFont {
    this.attributes['font-style'] = fontStyle;
    return this;
  }
  getFontWeight(): 'normal' | 'bold' | null {
    return this.attributes['font-weight'];
  }
  setFontWeight(fontWeight: 'normal' | 'bold' | null): LyricFont {
    this.attributes['font-weight'] = fontWeight;
    return this;
  }
  getName(): string | null {
    return this.attributes['name'];
  }
  setName(name: string | null): LyricFont {
    this.attributes['name'] = name;
    return this;
  }
  getNumber(): string | null {
    return this.attributes['number'];
  }
  setNumber(number: string | null): LyricFont {
    this.attributes['number'] = number;
    return this;
  }
}

export type LyricLanguageAttributes = { 'xml:lang': string; name: string | null; number: string | null };

export type LyricLanguageContents = [];

export class LyricLanguage implements XMLElement<'lyric-language', LyricLanguageAttributes, LyricLanguageContents> {
  static readonly schema = {
    name: 'lyric-language',
    attributes: {
      'xml:lang': { type: 'required', value: { type: 'string' } },
      name: { type: 'optional', value: { type: 'string' } },
      number: { type: 'optional', value: { type: 'string' } },
    },
    contents: [],
  } as const;

  readonly schema = LyricLanguage.schema;

  attributes: LyricLanguageAttributes;
  contents: LyricLanguageContents;

  constructor(opts?: { attributes?: Partial<LyricLanguageAttributes>; contents?: LyricLanguageContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, LyricLanguage.schema);
    this.contents = opts?.contents ?? operations.zero(LyricLanguage.schema.contents);
  }
  getXmlLang(): string {
    return this.attributes['xml:lang'];
  }
  setXmlLang(xmlLang: string): LyricLanguage {
    this.attributes['xml:lang'] = xmlLang;
    return this;
  }
  getName(): string | null {
    return this.attributes['name'];
  }
  setName(name: string | null): LyricLanguage {
    this.attributes['name'] = name;
    return this;
  }
  getNumber(): string | null {
    return this.attributes['number'];
  }
  setNumber(number: string | null): LyricLanguage {
    this.attributes['number'] = number;
    return this;
  }
}

export type DefaultsAttributes = Record<string, unknown>;

export type DefaultsContents = [
  Scaling | null,
  ConcertScore | null,
  PageLayout | null,
  SystemLayout | null,
  Array<StaffLayout>,
  Appearance | null,
  MusicFont | null,
  WordFont | null,
  Array<LyricFont>,
  Array<LyricLanguage>
];

export class Defaults implements XMLElement<'defaults', DefaultsAttributes, DefaultsContents> {
  static readonly schema = {
    name: 'defaults',
    attributes: {},
    contents: [
      { type: 'optional', value: Scaling },
      { type: 'optional', value: ConcertScore },
      { type: 'optional', value: PageLayout },
      { type: 'optional', value: SystemLayout },
      { type: 'label', label: 'staff-layouts', value: { type: 'zeroOrMore', value: StaffLayout } },
      { type: 'optional', value: Appearance },
      { type: 'optional', value: MusicFont },
      { type: 'optional', value: WordFont },
      { type: 'label', label: 'lyric-fonts', value: { type: 'zeroOrMore', value: LyricFont } },
      { type: 'label', label: 'lyric-languages', value: { type: 'zeroOrMore', value: LyricLanguage } },
    ],
  } as const;

  readonly schema = Defaults.schema;

  attributes: DefaultsAttributes;
  contents: DefaultsContents;

  constructor(opts?: { attributes?: Partial<DefaultsAttributes>; contents?: DefaultsContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Defaults.schema);
    this.contents = opts?.contents ?? operations.zero(Defaults.schema.contents);
  }

  getScaling(): Scaling | null {
    return this.contents[0];
  }
  setScaling(scaling: Scaling | null): Defaults {
    this.contents[0] = scaling;
    return this;
  }
  getConcertScore(): ConcertScore | null {
    return this.contents[1];
  }
  setConcertScore(concertScore: ConcertScore | null): Defaults {
    this.contents[1] = concertScore;
    return this;
  }
  getPageLayout(): PageLayout | null {
    return this.contents[2];
  }
  setPageLayout(pageLayout: PageLayout | null): Defaults {
    this.contents[2] = pageLayout;
    return this;
  }
  getSystemLayout(): SystemLayout | null {
    return this.contents[3];
  }
  setSystemLayout(systemLayout: SystemLayout | null): Defaults {
    this.contents[3] = systemLayout;
    return this;
  }
  getStaffLayouts(): Array<StaffLayout> {
    return this.contents[4];
  }
  setStaffLayouts(staffLayouts: Array<StaffLayout>): Defaults {
    this.contents[4] = staffLayouts;
    return this;
  }
  getAppearance(): Appearance | null {
    return this.contents[5];
  }
  setAppearance(appearance: Appearance | null): Defaults {
    this.contents[5] = appearance;
    return this;
  }
  getMusicFont(): MusicFont | null {
    return this.contents[6];
  }
  setMusicFont(musicFont: MusicFont | null): Defaults {
    this.contents[6] = musicFont;
    return this;
  }
  getWordFont(): WordFont | null {
    return this.contents[7];
  }
  setWordFont(wordFont: WordFont | null): Defaults {
    this.contents[7] = wordFont;
    return this;
  }
  getLyricFonts(): Array<LyricFont> {
    return this.contents[8];
  }
  setLyricFonts(lyricFonts: Array<LyricFont>): Defaults {
    this.contents[8] = lyricFonts;
    return this;
  }
  getLyricLanguages(): Array<LyricLanguage> {
    return this.contents[9];
  }
  setLyricLanguages(lyricLanguages: Array<LyricLanguage>): Defaults {
    this.contents[9] = lyricLanguages;
    return this;
  }
}

export type CreditTypeAttributes = Record<string, unknown>;

export type CreditTypeContents = [string];

export class CreditType implements XMLElement<'credit-type', CreditTypeAttributes, CreditTypeContents> {
  static readonly schema = {
    name: 'credit-type',
    attributes: {},
    contents: [{ type: 'required', value: { type: 'string' } }],
  } as const;

  readonly schema = CreditType.schema;

  attributes: CreditTypeAttributes;
  contents: CreditTypeContents;

  constructor(opts?: { attributes?: Partial<CreditTypeAttributes>; contents?: CreditTypeContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, CreditType.schema);
    this.contents = opts?.contents ?? operations.zero(CreditType.schema.contents);
  }

  getText(): string {
    return this.contents[0];
  }
  setText(text: string): CreditType {
    this.contents[0] = text;
    return this;
  }
}

export type LinkAttributes = {
  'xlink:href': string;
  'default-x': number | null;
  'default-y': number | null;
  element: string | null;
  name: string | null;
  position: number | null;
  'relative-x': number | null;
  'relative-y': number | null;
  'xlink:actuate': 'none' | 'onRequest' | 'onLoad' | 'other' | null;
  'xlink:role': string | null;
  'xlink:show': 'none' | 'new' | 'replace' | 'embed' | 'other' | null;
  'xlink:title': string | null;
  'xlink:type': 'simple' | null;
};

export type LinkContents = [];

export class Link implements XMLElement<'link', LinkAttributes, LinkContents> {
  static readonly schema = {
    name: 'link',
    attributes: {
      'xlink:href': { type: 'required', value: { type: 'string' } },
      'default-x': {
        type: 'label',
        label: 'default-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'default-y': {
        type: 'label',
        label: 'default-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      element: { type: 'optional', value: { type: 'string' } },
      name: { type: 'optional', value: { type: 'string' } },
      position: { type: 'optional', value: { type: 'int', min: 1, max: Infinity } },
      'relative-x': {
        type: 'label',
        label: 'relative-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'relative-y': {
        type: 'label',
        label: 'relative-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'xlink:actuate': {
        type: 'optional',
        value: { type: 'choices', choices: ['none', 'onRequest', 'onLoad', 'other'] },
      },
      'xlink:role': { type: 'optional', value: { type: 'string' } },
      'xlink:show': {
        type: 'optional',
        value: { type: 'choices', choices: ['none', 'new', 'replace', 'embed', 'other'] },
      },
      'xlink:title': { type: 'optional', value: { type: 'string' } },
      'xlink:type': { type: 'optional', value: { type: 'choices', choices: ['simple'] } },
    },
    contents: [],
  } as const;

  readonly schema = Link.schema;

  attributes: LinkAttributes;
  contents: LinkContents;

  constructor(opts?: { attributes?: Partial<LinkAttributes>; contents?: LinkContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Link.schema);
    this.contents = opts?.contents ?? operations.zero(Link.schema.contents);
  }
  getXlinkHref(): string {
    return this.attributes['xlink:href'];
  }
  setXlinkHref(xlinkHref: string): Link {
    this.attributes['xlink:href'] = xlinkHref;
    return this;
  }
  getDefaultX(): number | null {
    return this.attributes['default-x'];
  }
  setDefaultX(defaultX: number | null): Link {
    this.attributes['default-x'] = defaultX;
    return this;
  }
  getDefaultY(): number | null {
    return this.attributes['default-y'];
  }
  setDefaultY(defaultY: number | null): Link {
    this.attributes['default-y'] = defaultY;
    return this;
  }
  getElement(): string | null {
    return this.attributes['element'];
  }
  setElement(element: string | null): Link {
    this.attributes['element'] = element;
    return this;
  }
  getName(): string | null {
    return this.attributes['name'];
  }
  setName(name: string | null): Link {
    this.attributes['name'] = name;
    return this;
  }
  getPosition(): number | null {
    return this.attributes['position'];
  }
  setPosition(position: number | null): Link {
    this.attributes['position'] = position;
    return this;
  }
  getRelativeX(): number | null {
    return this.attributes['relative-x'];
  }
  setRelativeX(relativeX: number | null): Link {
    this.attributes['relative-x'] = relativeX;
    return this;
  }
  getRelativeY(): number | null {
    return this.attributes['relative-y'];
  }
  setRelativeY(relativeY: number | null): Link {
    this.attributes['relative-y'] = relativeY;
    return this;
  }
  getXlinkActuate(): 'none' | 'onRequest' | 'onLoad' | 'other' | null {
    return this.attributes['xlink:actuate'];
  }
  setXlinkActuate(xlinkActuate: 'none' | 'onRequest' | 'onLoad' | 'other' | null): Link {
    this.attributes['xlink:actuate'] = xlinkActuate;
    return this;
  }
  getXlinkRole(): string | null {
    return this.attributes['xlink:role'];
  }
  setXlinkRole(xlinkRole: string | null): Link {
    this.attributes['xlink:role'] = xlinkRole;
    return this;
  }
  getXlinkShow(): 'none' | 'new' | 'replace' | 'embed' | 'other' | null {
    return this.attributes['xlink:show'];
  }
  setXlinkShow(xlinkShow: 'none' | 'new' | 'replace' | 'embed' | 'other' | null): Link {
    this.attributes['xlink:show'] = xlinkShow;
    return this;
  }
  getXlinkTitle(): string | null {
    return this.attributes['xlink:title'];
  }
  setXlinkTitle(xlinkTitle: string | null): Link {
    this.attributes['xlink:title'] = xlinkTitle;
    return this;
  }
  getXlinkType(): 'simple' | null {
    return this.attributes['xlink:type'];
  }
  setXlinkType(xlinkType: 'simple' | null): Link {
    this.attributes['xlink:type'] = xlinkType;
    return this;
  }
}

export type BookmarkAttributes = { id: string; element: string | null; name: string | null; position: number | null };

export type BookmarkContents = [];

export class Bookmark implements XMLElement<'bookmark', BookmarkAttributes, BookmarkContents> {
  static readonly schema = {
    name: 'bookmark',
    attributes: {
      id: { type: 'required', value: { type: 'regex', pattern: /[A-Za-z_][A-Za-z0-9.-_]*/, zero: '_' } },
      element: { type: 'optional', value: { type: 'string' } },
      name: { type: 'optional', value: { type: 'string' } },
      position: { type: 'optional', value: { type: 'int', min: 1, max: Infinity } },
    },
    contents: [],
  } as const;

  readonly schema = Bookmark.schema;

  attributes: BookmarkAttributes;
  contents: BookmarkContents;

  constructor(opts?: { attributes?: Partial<BookmarkAttributes>; contents?: BookmarkContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Bookmark.schema);
    this.contents = opts?.contents ?? operations.zero(Bookmark.schema.contents);
  }
  getId(): string {
    return this.attributes['id'];
  }
  setId(id: string): Bookmark {
    this.attributes['id'] = id;
    return this;
  }
  getElement(): string | null {
    return this.attributes['element'];
  }
  setElement(element: string | null): Bookmark {
    this.attributes['element'] = element;
    return this;
  }
  getName(): string | null {
    return this.attributes['name'];
  }
  setName(name: string | null): Bookmark {
    this.attributes['name'] = name;
    return this;
  }
  getPosition(): number | null {
    return this.attributes['position'];
  }
  setPosition(position: number | null): Bookmark {
    this.attributes['position'] = position;
    return this;
  }
}

export type CreditImageAttributes = {
  'default-x': number | null;
  'default-y': number | null;
  halign: 'left' | 'center' | 'right' | null;
  height: number | null;
  id: string | null;
  'relative-x': number | null;
  'relative-y': number | null;
  source: string | null;
  type: string | null;
  valign: 'top' | 'middle' | 'bottom' | null;
  width: number | null;
};

export type CreditImageContents = [];

export class CreditImage implements XMLElement<'credit-image', CreditImageAttributes, CreditImageContents> {
  static readonly schema = {
    name: 'credit-image',
    attributes: {
      'default-x': {
        type: 'label',
        label: 'default-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'default-y': {
        type: 'label',
        label: 'default-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      halign: { type: 'optional', value: { type: 'choices', choices: ['left', 'center', 'right'] } },
      height: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      id: { type: 'optional', value: { type: 'regex', pattern: /[A-Za-z_][A-Za-z0-9.-_]*/, zero: '_' } },
      'relative-x': {
        type: 'label',
        label: 'relative-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'relative-y': {
        type: 'label',
        label: 'relative-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      source: { type: 'optional', value: { type: 'string' } },
      type: { type: 'optional', value: { type: 'string' } },
      valign: { type: 'optional', value: { type: 'choices', choices: ['top', 'middle', 'bottom'] } },
      width: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
    },
    contents: [],
  } as const;

  readonly schema = CreditImage.schema;

  attributes: CreditImageAttributes;
  contents: CreditImageContents;

  constructor(opts?: { attributes?: Partial<CreditImageAttributes>; contents?: CreditImageContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, CreditImage.schema);
    this.contents = opts?.contents ?? operations.zero(CreditImage.schema.contents);
  }
  getDefaultX(): number | null {
    return this.attributes['default-x'];
  }
  setDefaultX(defaultX: number | null): CreditImage {
    this.attributes['default-x'] = defaultX;
    return this;
  }
  getDefaultY(): number | null {
    return this.attributes['default-y'];
  }
  setDefaultY(defaultY: number | null): CreditImage {
    this.attributes['default-y'] = defaultY;
    return this;
  }
  getHalign(): 'left' | 'center' | 'right' | null {
    return this.attributes['halign'];
  }
  setHalign(halign: 'left' | 'center' | 'right' | null): CreditImage {
    this.attributes['halign'] = halign;
    return this;
  }
  getHeight(): number | null {
    return this.attributes['height'];
  }
  setHeight(height: number | null): CreditImage {
    this.attributes['height'] = height;
    return this;
  }
  getId(): string | null {
    return this.attributes['id'];
  }
  setId(id: string | null): CreditImage {
    this.attributes['id'] = id;
    return this;
  }
  getRelativeX(): number | null {
    return this.attributes['relative-x'];
  }
  setRelativeX(relativeX: number | null): CreditImage {
    this.attributes['relative-x'] = relativeX;
    return this;
  }
  getRelativeY(): number | null {
    return this.attributes['relative-y'];
  }
  setRelativeY(relativeY: number | null): CreditImage {
    this.attributes['relative-y'] = relativeY;
    return this;
  }
  getSource(): string | null {
    return this.attributes['source'];
  }
  setSource(source: string | null): CreditImage {
    this.attributes['source'] = source;
    return this;
  }
  getType(): string | null {
    return this.attributes['type'];
  }
  setType(type: string | null): CreditImage {
    this.attributes['type'] = type;
    return this;
  }
  getValign(): 'top' | 'middle' | 'bottom' | null {
    return this.attributes['valign'];
  }
  setValign(valign: 'top' | 'middle' | 'bottom' | null): CreditImage {
    this.attributes['valign'] = valign;
    return this;
  }
  getWidth(): number | null {
    return this.attributes['width'];
  }
  setWidth(width: number | null): CreditImage {
    this.attributes['width'] = width;
    return this;
  }
}

export type CreditWordsAttributes = {
  color: string | null;
  'default-x': number | null;
  'default-y': number | null;
  dir: 'ltr' | 'rtl' | 'lro' | 'rlo' | null;
  enclosure:
    | 'none'
    | 'rectangle'
    | 'square'
    | 'oval'
    | 'circle'
    | 'bracket'
    | 'inverted-bracket'
    | 'triangle'
    | 'diamond'
    | 'pentagon'
    | 'hexagon'
    | 'heptagon'
    | 'octagon'
    | 'nonagon'
    | 'decagon'
    | null;
  'font-family': string | null;
  'font-size': 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null;
  'font-style': 'normal' | 'italic' | null;
  'font-weight': 'normal' | 'bold' | null;
  halign: 'left' | 'center' | 'right' | null;
  id: string | null;
  justify: 'left' | 'center' | 'right' | null;
  'letter-spacing': 'normal' | number | null;
  'line-height': 'normal' | number | null;
  'line-through': number | null;
  overline: number | null;
  'relative-x': number | null;
  'relative-y': number | null;
  rotation: number | null;
  underline: number | null;
  valign: 'top' | 'middle' | 'bottom' | 'baseline' | null;
  'xml:lang': string | null;
  'xml:space': 'default' | 'preserve' | null;
};

export type CreditWordsContents = [string];

export class CreditWords implements XMLElement<'credit-words', CreditWordsAttributes, CreditWordsContents> {
  static readonly schema = {
    name: 'credit-words',
    attributes: {
      color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
      'default-x': {
        type: 'label',
        label: 'default-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'default-y': {
        type: 'label',
        label: 'default-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      dir: { type: 'optional', value: { type: 'choices', choices: ['ltr', 'rtl', 'lro', 'rlo'] } },
      enclosure: {
        type: 'optional',
        value: {
          type: 'choices',
          choices: [
            'none',
            'rectangle',
            'square',
            'oval',
            'circle',
            'bracket',
            'inverted-bracket',
            'triangle',
            'diamond',
            'pentagon',
            'hexagon',
            'heptagon',
            'octagon',
            'nonagon',
            'decagon',
          ],
        },
      },
      'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
      'font-size': {
        type: 'optional',
        value: {
          type: 'choices',
          choices: [
            { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
            { type: 'float', min: -Infinity, max: Infinity },
          ],
        },
      },
      'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
      'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
      halign: { type: 'optional', value: { type: 'choices', choices: ['left', 'center', 'right'] } },
      id: { type: 'optional', value: { type: 'regex', pattern: /[A-Za-z_][A-Za-z0-9.-_]*/, zero: '_' } },
      justify: { type: 'optional', value: { type: 'choices', choices: ['left', 'center', 'right'] } },
      'letter-spacing': {
        type: 'optional',
        value: { type: 'choices', choices: ['normal', { type: 'float', min: -Infinity, max: Infinity }] },
      },
      'line-height': {
        type: 'optional',
        value: { type: 'choices', choices: ['normal', { type: 'float', min: -Infinity, max: Infinity }] },
      },
      'line-through': { type: 'optional', value: { type: 'int', min: 0, max: 3 } },
      overline: { type: 'optional', value: { type: 'int', min: 0, max: 3 } },
      'relative-x': {
        type: 'label',
        label: 'relative-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'relative-y': {
        type: 'label',
        label: 'relative-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      rotation: { type: 'optional', value: { type: 'float', min: -180, max: 180 } },
      underline: { type: 'optional', value: { type: 'int', min: 0, max: 3 } },
      valign: { type: 'optional', value: { type: 'choices', choices: ['top', 'middle', 'bottom', 'baseline'] } },
      'xml:lang': { type: 'optional', value: { type: 'string' } },
      'xml:space': { type: 'optional', value: { type: 'choices', choices: ['default', 'preserve'] } },
    },
    contents: [{ type: 'string' }],
  } as const;

  readonly schema = CreditWords.schema;

  attributes: CreditWordsAttributes;
  contents: CreditWordsContents;

  constructor(opts?: { attributes?: Partial<CreditWordsAttributes>; contents?: CreditWordsContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, CreditWords.schema);
    this.contents = opts?.contents ?? operations.zero(CreditWords.schema.contents);
  }
  getColor(): string | null {
    return this.attributes['color'];
  }
  setColor(color: string | null): CreditWords {
    this.attributes['color'] = color;
    return this;
  }
  getDefaultX(): number | null {
    return this.attributes['default-x'];
  }
  setDefaultX(defaultX: number | null): CreditWords {
    this.attributes['default-x'] = defaultX;
    return this;
  }
  getDefaultY(): number | null {
    return this.attributes['default-y'];
  }
  setDefaultY(defaultY: number | null): CreditWords {
    this.attributes['default-y'] = defaultY;
    return this;
  }
  getDir(): 'ltr' | 'rtl' | 'lro' | 'rlo' | null {
    return this.attributes['dir'];
  }
  setDir(dir: 'ltr' | 'rtl' | 'lro' | 'rlo' | null): CreditWords {
    this.attributes['dir'] = dir;
    return this;
  }
  getEnclosure():
    | 'none'
    | 'rectangle'
    | 'square'
    | 'oval'
    | 'circle'
    | 'bracket'
    | 'inverted-bracket'
    | 'triangle'
    | 'diamond'
    | 'pentagon'
    | 'hexagon'
    | 'heptagon'
    | 'octagon'
    | 'nonagon'
    | 'decagon'
    | null {
    return this.attributes['enclosure'];
  }
  setEnclosure(
    enclosure:
      | 'none'
      | 'rectangle'
      | 'square'
      | 'oval'
      | 'circle'
      | 'bracket'
      | 'inverted-bracket'
      | 'triangle'
      | 'diamond'
      | 'pentagon'
      | 'hexagon'
      | 'heptagon'
      | 'octagon'
      | 'nonagon'
      | 'decagon'
      | null
  ): CreditWords {
    this.attributes['enclosure'] = enclosure;
    return this;
  }
  getFontFamily(): string | null {
    return this.attributes['font-family'];
  }
  setFontFamily(fontFamily: string | null): CreditWords {
    this.attributes['font-family'] = fontFamily;
    return this;
  }
  getFontSize(): 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null {
    return this.attributes['font-size'];
  }
  setFontSize(
    fontSize: 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null
  ): CreditWords {
    this.attributes['font-size'] = fontSize;
    return this;
  }
  getFontStyle(): 'normal' | 'italic' | null {
    return this.attributes['font-style'];
  }
  setFontStyle(fontStyle: 'normal' | 'italic' | null): CreditWords {
    this.attributes['font-style'] = fontStyle;
    return this;
  }
  getFontWeight(): 'normal' | 'bold' | null {
    return this.attributes['font-weight'];
  }
  setFontWeight(fontWeight: 'normal' | 'bold' | null): CreditWords {
    this.attributes['font-weight'] = fontWeight;
    return this;
  }
  getHalign(): 'left' | 'center' | 'right' | null {
    return this.attributes['halign'];
  }
  setHalign(halign: 'left' | 'center' | 'right' | null): CreditWords {
    this.attributes['halign'] = halign;
    return this;
  }
  getId(): string | null {
    return this.attributes['id'];
  }
  setId(id: string | null): CreditWords {
    this.attributes['id'] = id;
    return this;
  }
  getJustify(): 'left' | 'center' | 'right' | null {
    return this.attributes['justify'];
  }
  setJustify(justify: 'left' | 'center' | 'right' | null): CreditWords {
    this.attributes['justify'] = justify;
    return this;
  }
  getLetterSpacing(): 'normal' | number | null {
    return this.attributes['letter-spacing'];
  }
  setLetterSpacing(letterSpacing: 'normal' | number | null): CreditWords {
    this.attributes['letter-spacing'] = letterSpacing;
    return this;
  }
  getLineHeight(): 'normal' | number | null {
    return this.attributes['line-height'];
  }
  setLineHeight(lineHeight: 'normal' | number | null): CreditWords {
    this.attributes['line-height'] = lineHeight;
    return this;
  }
  getLineThrough(): number | null {
    return this.attributes['line-through'];
  }
  setLineThrough(lineThrough: number | null): CreditWords {
    this.attributes['line-through'] = lineThrough;
    return this;
  }
  getOverline(): number | null {
    return this.attributes['overline'];
  }
  setOverline(overline: number | null): CreditWords {
    this.attributes['overline'] = overline;
    return this;
  }
  getRelativeX(): number | null {
    return this.attributes['relative-x'];
  }
  setRelativeX(relativeX: number | null): CreditWords {
    this.attributes['relative-x'] = relativeX;
    return this;
  }
  getRelativeY(): number | null {
    return this.attributes['relative-y'];
  }
  setRelativeY(relativeY: number | null): CreditWords {
    this.attributes['relative-y'] = relativeY;
    return this;
  }
  getRotation(): number | null {
    return this.attributes['rotation'];
  }
  setRotation(rotation: number | null): CreditWords {
    this.attributes['rotation'] = rotation;
    return this;
  }
  getUnderline(): number | null {
    return this.attributes['underline'];
  }
  setUnderline(underline: number | null): CreditWords {
    this.attributes['underline'] = underline;
    return this;
  }
  getValign(): 'top' | 'middle' | 'bottom' | 'baseline' | null {
    return this.attributes['valign'];
  }
  setValign(valign: 'top' | 'middle' | 'bottom' | 'baseline' | null): CreditWords {
    this.attributes['valign'] = valign;
    return this;
  }
  getXmlLang(): string | null {
    return this.attributes['xml:lang'];
  }
  setXmlLang(xmlLang: string | null): CreditWords {
    this.attributes['xml:lang'] = xmlLang;
    return this;
  }
  getXmlSpace(): 'default' | 'preserve' | null {
    return this.attributes['xml:space'];
  }
  setXmlSpace(xmlSpace: 'default' | 'preserve' | null): CreditWords {
    this.attributes['xml:space'] = xmlSpace;
    return this;
  }
  getText(): string {
    return this.contents[0];
  }
  setText(text: string): CreditWords {
    this.contents[0] = text;
    return this;
  }
}

export type CreditSymbolAttributes = {
  color: string | null;
  'default-x': number | null;
  'default-y': number | null;
  dir: 'ltr' | 'rtl' | 'lro' | 'rlo' | null;
  enclosure:
    | 'none'
    | 'rectangle'
    | 'square'
    | 'oval'
    | 'circle'
    | 'bracket'
    | 'inverted-bracket'
    | 'triangle'
    | 'diamond'
    | 'pentagon'
    | 'hexagon'
    | 'heptagon'
    | 'octagon'
    | 'nonagon'
    | 'decagon'
    | null;
  'font-family': string | null;
  'font-size': 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null;
  'font-style': 'normal' | 'italic' | null;
  'font-weight': 'normal' | 'bold' | null;
  halign: 'left' | 'center' | 'right' | null;
  id: string | null;
  justify: 'left' | 'center' | 'right' | null;
  'letter-spacing': 'normal' | number | null;
  'line-height': 'normal' | number | null;
  'line-through': number | null;
  overline: number | null;
  'relative-x': number | null;
  'relative-y': number | null;
  rotation: number | null;
  underline: number | null;
  valign: 'top' | 'middle' | 'bottom' | 'baseline' | null;
};

export type CreditSymbolContents = [string];

export class CreditSymbol implements XMLElement<'credit-symbol', CreditSymbolAttributes, CreditSymbolContents> {
  static readonly schema = {
    name: 'credit-symbol',
    attributes: {
      color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
      'default-x': {
        type: 'label',
        label: 'default-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'default-y': {
        type: 'label',
        label: 'default-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      dir: { type: 'optional', value: { type: 'choices', choices: ['ltr', 'rtl', 'lro', 'rlo'] } },
      enclosure: {
        type: 'optional',
        value: {
          type: 'choices',
          choices: [
            'none',
            'rectangle',
            'square',
            'oval',
            'circle',
            'bracket',
            'inverted-bracket',
            'triangle',
            'diamond',
            'pentagon',
            'hexagon',
            'heptagon',
            'octagon',
            'nonagon',
            'decagon',
          ],
        },
      },
      'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
      'font-size': {
        type: 'optional',
        value: {
          type: 'choices',
          choices: [
            { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
            { type: 'float', min: -Infinity, max: Infinity },
          ],
        },
      },
      'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
      'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
      halign: { type: 'optional', value: { type: 'choices', choices: ['left', 'center', 'right'] } },
      id: { type: 'optional', value: { type: 'regex', pattern: /[A-Za-z_][A-Za-z0-9.-_]*/, zero: '_' } },
      justify: { type: 'optional', value: { type: 'choices', choices: ['left', 'center', 'right'] } },
      'letter-spacing': {
        type: 'optional',
        value: { type: 'choices', choices: ['normal', { type: 'float', min: -Infinity, max: Infinity }] },
      },
      'line-height': {
        type: 'optional',
        value: { type: 'choices', choices: ['normal', { type: 'float', min: -Infinity, max: Infinity }] },
      },
      'line-through': { type: 'optional', value: { type: 'int', min: 0, max: 3 } },
      overline: { type: 'optional', value: { type: 'int', min: 0, max: 3 } },
      'relative-x': {
        type: 'label',
        label: 'relative-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'relative-y': {
        type: 'label',
        label: 'relative-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      rotation: { type: 'optional', value: { type: 'float', min: -180, max: 180 } },
      underline: { type: 'optional', value: { type: 'int', min: 0, max: 3 } },
      valign: { type: 'optional', value: { type: 'choices', choices: ['top', 'middle', 'bottom', 'baseline'] } },
    },
    contents: [{ type: 'required', value: { type: 'string' } }],
  } as const;

  readonly schema = CreditSymbol.schema;

  attributes: CreditSymbolAttributes;
  contents: CreditSymbolContents;

  constructor(opts?: { attributes?: Partial<CreditSymbolAttributes>; contents?: CreditSymbolContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, CreditSymbol.schema);
    this.contents = opts?.contents ?? operations.zero(CreditSymbol.schema.contents);
  }
  getColor(): string | null {
    return this.attributes['color'];
  }
  setColor(color: string | null): CreditSymbol {
    this.attributes['color'] = color;
    return this;
  }
  getDefaultX(): number | null {
    return this.attributes['default-x'];
  }
  setDefaultX(defaultX: number | null): CreditSymbol {
    this.attributes['default-x'] = defaultX;
    return this;
  }
  getDefaultY(): number | null {
    return this.attributes['default-y'];
  }
  setDefaultY(defaultY: number | null): CreditSymbol {
    this.attributes['default-y'] = defaultY;
    return this;
  }
  getDir(): 'ltr' | 'rtl' | 'lro' | 'rlo' | null {
    return this.attributes['dir'];
  }
  setDir(dir: 'ltr' | 'rtl' | 'lro' | 'rlo' | null): CreditSymbol {
    this.attributes['dir'] = dir;
    return this;
  }
  getEnclosure():
    | 'none'
    | 'rectangle'
    | 'square'
    | 'oval'
    | 'circle'
    | 'bracket'
    | 'inverted-bracket'
    | 'triangle'
    | 'diamond'
    | 'pentagon'
    | 'hexagon'
    | 'heptagon'
    | 'octagon'
    | 'nonagon'
    | 'decagon'
    | null {
    return this.attributes['enclosure'];
  }
  setEnclosure(
    enclosure:
      | 'none'
      | 'rectangle'
      | 'square'
      | 'oval'
      | 'circle'
      | 'bracket'
      | 'inverted-bracket'
      | 'triangle'
      | 'diamond'
      | 'pentagon'
      | 'hexagon'
      | 'heptagon'
      | 'octagon'
      | 'nonagon'
      | 'decagon'
      | null
  ): CreditSymbol {
    this.attributes['enclosure'] = enclosure;
    return this;
  }
  getFontFamily(): string | null {
    return this.attributes['font-family'];
  }
  setFontFamily(fontFamily: string | null): CreditSymbol {
    this.attributes['font-family'] = fontFamily;
    return this;
  }
  getFontSize(): 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null {
    return this.attributes['font-size'];
  }
  setFontSize(
    fontSize: 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null
  ): CreditSymbol {
    this.attributes['font-size'] = fontSize;
    return this;
  }
  getFontStyle(): 'normal' | 'italic' | null {
    return this.attributes['font-style'];
  }
  setFontStyle(fontStyle: 'normal' | 'italic' | null): CreditSymbol {
    this.attributes['font-style'] = fontStyle;
    return this;
  }
  getFontWeight(): 'normal' | 'bold' | null {
    return this.attributes['font-weight'];
  }
  setFontWeight(fontWeight: 'normal' | 'bold' | null): CreditSymbol {
    this.attributes['font-weight'] = fontWeight;
    return this;
  }
  getHalign(): 'left' | 'center' | 'right' | null {
    return this.attributes['halign'];
  }
  setHalign(halign: 'left' | 'center' | 'right' | null): CreditSymbol {
    this.attributes['halign'] = halign;
    return this;
  }
  getId(): string | null {
    return this.attributes['id'];
  }
  setId(id: string | null): CreditSymbol {
    this.attributes['id'] = id;
    return this;
  }
  getJustify(): 'left' | 'center' | 'right' | null {
    return this.attributes['justify'];
  }
  setJustify(justify: 'left' | 'center' | 'right' | null): CreditSymbol {
    this.attributes['justify'] = justify;
    return this;
  }
  getLetterSpacing(): 'normal' | number | null {
    return this.attributes['letter-spacing'];
  }
  setLetterSpacing(letterSpacing: 'normal' | number | null): CreditSymbol {
    this.attributes['letter-spacing'] = letterSpacing;
    return this;
  }
  getLineHeight(): 'normal' | number | null {
    return this.attributes['line-height'];
  }
  setLineHeight(lineHeight: 'normal' | number | null): CreditSymbol {
    this.attributes['line-height'] = lineHeight;
    return this;
  }
  getLineThrough(): number | null {
    return this.attributes['line-through'];
  }
  setLineThrough(lineThrough: number | null): CreditSymbol {
    this.attributes['line-through'] = lineThrough;
    return this;
  }
  getOverline(): number | null {
    return this.attributes['overline'];
  }
  setOverline(overline: number | null): CreditSymbol {
    this.attributes['overline'] = overline;
    return this;
  }
  getRelativeX(): number | null {
    return this.attributes['relative-x'];
  }
  setRelativeX(relativeX: number | null): CreditSymbol {
    this.attributes['relative-x'] = relativeX;
    return this;
  }
  getRelativeY(): number | null {
    return this.attributes['relative-y'];
  }
  setRelativeY(relativeY: number | null): CreditSymbol {
    this.attributes['relative-y'] = relativeY;
    return this;
  }
  getRotation(): number | null {
    return this.attributes['rotation'];
  }
  setRotation(rotation: number | null): CreditSymbol {
    this.attributes['rotation'] = rotation;
    return this;
  }
  getUnderline(): number | null {
    return this.attributes['underline'];
  }
  setUnderline(underline: number | null): CreditSymbol {
    this.attributes['underline'] = underline;
    return this;
  }
  getValign(): 'top' | 'middle' | 'bottom' | 'baseline' | null {
    return this.attributes['valign'];
  }
  setValign(valign: 'top' | 'middle' | 'bottom' | 'baseline' | null): CreditSymbol {
    this.attributes['valign'] = valign;
    return this;
  }
  getText(): string {
    return this.contents[0];
  }
  setText(text: string): CreditSymbol {
    this.contents[0] = text;
    return this;
  }
}

export type CreditToken = [
  CreditWords | CreditSymbol,
  Array<[Array<Link>, Array<Bookmark>, CreditWords | CreditSymbol]>
];

export type CreditAttributes = { id: string | null; page: number | null };

export type CreditContents = [Array<CreditType>, Array<Link>, Array<Bookmark>, CreditImage | CreditToken];

export class Credit implements XMLElement<'credit', CreditAttributes, CreditContents> {
  static readonly schema = {
    name: 'credit',
    attributes: {
      id: { type: 'optional', value: { type: 'regex', pattern: /[A-Za-z_][A-Za-z0-9.-_]*/, zero: '_' } },
      page: { type: 'optional', value: { type: 'int', min: 1, max: Infinity } },
    },
    contents: [
      { type: 'label', label: 'credit-types', value: { type: 'zeroOrMore', value: CreditType } },
      { type: 'label', label: 'links', value: { type: 'zeroOrMore', value: Link } },
      { type: 'label', label: 'bookmarks', value: { type: 'zeroOrMore', value: Bookmark } },
      {
        type: 'label',
        label: 'credit-value',
        value: {
          type: 'choices',
          choices: [
            CreditImage,
            {
              type: 'label',
              label: 'credit-token',
              value: [
                { type: 'choices', choices: [CreditWords, CreditSymbol] },
                {
                  type: 'zeroOrMore',
                  value: [
                    { type: 'zeroOrMore', value: Link },
                    { type: 'zeroOrMore', value: Bookmark },
                    { type: 'choices', choices: [CreditWords, CreditSymbol] },
                  ],
                },
              ],
            },
          ],
        },
      },
    ],
  } as const;

  readonly schema = Credit.schema;

  attributes: CreditAttributes;
  contents: CreditContents;

  constructor(opts?: { attributes?: Partial<CreditAttributes>; contents?: CreditContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Credit.schema);
    this.contents = opts?.contents ?? operations.zero(Credit.schema.contents);
  }
  getId(): string | null {
    return this.attributes['id'];
  }
  setId(id: string | null): Credit {
    this.attributes['id'] = id;
    return this;
  }
  getPage(): number | null {
    return this.attributes['page'];
  }
  setPage(page: number | null): Credit {
    this.attributes['page'] = page;
    return this;
  }
  getCreditTypes(): Array<CreditType> {
    return this.contents[0];
  }
  setCreditTypes(creditTypes: Array<CreditType>): Credit {
    this.contents[0] = creditTypes;
    return this;
  }
  getLinks(): Array<Link> {
    return this.contents[1];
  }
  setLinks(links: Array<Link>): Credit {
    this.contents[1] = links;
    return this;
  }
  getBookmarks(): Array<Bookmark> {
    return this.contents[2];
  }
  setBookmarks(bookmarks: Array<Bookmark>): Credit {
    this.contents[2] = bookmarks;
    return this;
  }
  getCreditValue(): CreditImage | CreditToken {
    return this.contents[3];
  }
  setCreditValue(creditValue: CreditImage | CreditToken): Credit {
    this.contents[3] = creditValue;
    return this;
  }
}

export type GroupNameAttributes = {
  color: string | null;
  'default-x': number | null;
  'default-y': number | null;
  'font-family': string | null;
  'font-size': 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null;
  'font-style': 'normal' | 'italic' | null;
  'font-weight': 'normal' | 'bold' | null;
  justify: 'left' | 'center' | 'right' | null;
  'relative-x': number | null;
  'relative-y': number | null;
};

export type GroupNameContents = [string];

export class GroupName implements XMLElement<'group-name', GroupNameAttributes, GroupNameContents> {
  static readonly schema = {
    name: 'group-name',
    attributes: {
      color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
      'default-x': {
        type: 'label',
        label: 'default-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'default-y': {
        type: 'label',
        label: 'default-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
      'font-size': {
        type: 'optional',
        value: {
          type: 'choices',
          choices: [
            { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
            { type: 'float', min: -Infinity, max: Infinity },
          ],
        },
      },
      'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
      'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
      justify: { type: 'optional', value: { type: 'choices', choices: ['left', 'center', 'right'] } },
      'relative-x': {
        type: 'label',
        label: 'relative-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'relative-y': {
        type: 'label',
        label: 'relative-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
    },
    contents: [{ type: 'required', value: { type: 'string' } }],
  } as const;

  readonly schema = GroupName.schema;

  attributes: GroupNameAttributes;
  contents: GroupNameContents;

  constructor(opts?: { attributes?: Partial<GroupNameAttributes>; contents?: GroupNameContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, GroupName.schema);
    this.contents = opts?.contents ?? operations.zero(GroupName.schema.contents);
  }
  getColor(): string | null {
    return this.attributes['color'];
  }
  setColor(color: string | null): GroupName {
    this.attributes['color'] = color;
    return this;
  }
  getDefaultX(): number | null {
    return this.attributes['default-x'];
  }
  setDefaultX(defaultX: number | null): GroupName {
    this.attributes['default-x'] = defaultX;
    return this;
  }
  getDefaultY(): number | null {
    return this.attributes['default-y'];
  }
  setDefaultY(defaultY: number | null): GroupName {
    this.attributes['default-y'] = defaultY;
    return this;
  }
  getFontFamily(): string | null {
    return this.attributes['font-family'];
  }
  setFontFamily(fontFamily: string | null): GroupName {
    this.attributes['font-family'] = fontFamily;
    return this;
  }
  getFontSize(): 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null {
    return this.attributes['font-size'];
  }
  setFontSize(
    fontSize: 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null
  ): GroupName {
    this.attributes['font-size'] = fontSize;
    return this;
  }
  getFontStyle(): 'normal' | 'italic' | null {
    return this.attributes['font-style'];
  }
  setFontStyle(fontStyle: 'normal' | 'italic' | null): GroupName {
    this.attributes['font-style'] = fontStyle;
    return this;
  }
  getFontWeight(): 'normal' | 'bold' | null {
    return this.attributes['font-weight'];
  }
  setFontWeight(fontWeight: 'normal' | 'bold' | null): GroupName {
    this.attributes['font-weight'] = fontWeight;
    return this;
  }
  getJustify(): 'left' | 'center' | 'right' | null {
    return this.attributes['justify'];
  }
  setJustify(justify: 'left' | 'center' | 'right' | null): GroupName {
    this.attributes['justify'] = justify;
    return this;
  }
  getRelativeX(): number | null {
    return this.attributes['relative-x'];
  }
  setRelativeX(relativeX: number | null): GroupName {
    this.attributes['relative-x'] = relativeX;
    return this;
  }
  getRelativeY(): number | null {
    return this.attributes['relative-y'];
  }
  setRelativeY(relativeY: number | null): GroupName {
    this.attributes['relative-y'] = relativeY;
    return this;
  }
  getText(): string {
    return this.contents[0];
  }
  setText(text: string): GroupName {
    this.contents[0] = text;
    return this;
  }
}

export type DisplayTextAttributes = {
  color: string | null;
  'default-x': number | null;
  'default-y': number | null;
  dir: 'ltr' | 'rtl' | 'lro' | 'rlo' | null;
  enclosure:
    | 'none'
    | 'rectangle'
    | 'square'
    | 'oval'
    | 'circle'
    | 'bracket'
    | 'inverted-bracket'
    | 'triangle'
    | 'diamond'
    | 'pentagon'
    | 'hexagon'
    | 'heptagon'
    | 'octagon'
    | 'nonagon'
    | 'decagon'
    | null;
  'font-family': string | null;
  'font-size': 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null;
  'font-style': 'normal' | 'italic' | null;
  'font-weight': 'normal' | 'bold' | null;
  halign: 'left' | 'center' | 'right' | null;
  justify: 'left' | 'center' | 'right' | null;
  'letter-spacing': 'normal' | number | null;
  'line-height': 'normal' | number | null;
  'line-through': number | null;
  overline: number | null;
  'relative-x': number | null;
  'relative-y': number | null;
  rotation: number | null;
  underline: number | null;
  valign: 'top' | 'middle' | 'bottom' | 'baseline' | null;
  'xml:lang': string | null;
  'xml:space': 'default' | 'preserve' | null;
};

export type DisplayTextContents = [string | null];

export class DisplayText implements XMLElement<'display-text', DisplayTextAttributes, DisplayTextContents> {
  static readonly schema = {
    name: 'display-text',
    attributes: {
      color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
      'default-x': {
        type: 'label',
        label: 'default-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'default-y': {
        type: 'label',
        label: 'default-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      dir: { type: 'optional', value: { type: 'choices', choices: ['ltr', 'rtl', 'lro', 'rlo'] } },
      enclosure: {
        type: 'optional',
        value: {
          type: 'choices',
          choices: [
            'none',
            'rectangle',
            'square',
            'oval',
            'circle',
            'bracket',
            'inverted-bracket',
            'triangle',
            'diamond',
            'pentagon',
            'hexagon',
            'heptagon',
            'octagon',
            'nonagon',
            'decagon',
          ],
        },
      },
      'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
      'font-size': {
        type: 'optional',
        value: {
          type: 'choices',
          choices: [
            { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
            { type: 'float', min: -Infinity, max: Infinity },
          ],
        },
      },
      'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
      'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
      halign: { type: 'optional', value: { type: 'choices', choices: ['left', 'center', 'right'] } },
      justify: { type: 'optional', value: { type: 'choices', choices: ['left', 'center', 'right'] } },
      'letter-spacing': {
        type: 'optional',
        value: { type: 'choices', choices: ['normal', { type: 'float', min: -Infinity, max: Infinity }] },
      },
      'line-height': {
        type: 'optional',
        value: { type: 'choices', choices: ['normal', { type: 'float', min: -Infinity, max: Infinity }] },
      },
      'line-through': { type: 'optional', value: { type: 'int', min: 0, max: 3 } },
      overline: { type: 'optional', value: { type: 'int', min: 0, max: 3 } },
      'relative-x': {
        type: 'label',
        label: 'relative-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'relative-y': {
        type: 'label',
        label: 'relative-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      rotation: { type: 'optional', value: { type: 'float', min: -180, max: 180 } },
      underline: { type: 'optional', value: { type: 'int', min: 0, max: 3 } },
      valign: { type: 'optional', value: { type: 'choices', choices: ['top', 'middle', 'bottom', 'baseline'] } },
      'xml:lang': { type: 'optional', value: { type: 'string' } },
      'xml:space': { type: 'optional', value: { type: 'choices', choices: ['default', 'preserve'] } },
    },
    contents: [{ type: 'optional', value: { type: 'string' } }],
  } as const;

  readonly schema = DisplayText.schema;

  attributes: DisplayTextAttributes;
  contents: DisplayTextContents;

  constructor(opts?: { attributes?: Partial<DisplayTextAttributes>; contents?: DisplayTextContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, DisplayText.schema);
    this.contents = opts?.contents ?? operations.zero(DisplayText.schema.contents);
  }
  getColor(): string | null {
    return this.attributes['color'];
  }
  setColor(color: string | null): DisplayText {
    this.attributes['color'] = color;
    return this;
  }
  getDefaultX(): number | null {
    return this.attributes['default-x'];
  }
  setDefaultX(defaultX: number | null): DisplayText {
    this.attributes['default-x'] = defaultX;
    return this;
  }
  getDefaultY(): number | null {
    return this.attributes['default-y'];
  }
  setDefaultY(defaultY: number | null): DisplayText {
    this.attributes['default-y'] = defaultY;
    return this;
  }
  getDir(): 'ltr' | 'rtl' | 'lro' | 'rlo' | null {
    return this.attributes['dir'];
  }
  setDir(dir: 'ltr' | 'rtl' | 'lro' | 'rlo' | null): DisplayText {
    this.attributes['dir'] = dir;
    return this;
  }
  getEnclosure():
    | 'none'
    | 'rectangle'
    | 'square'
    | 'oval'
    | 'circle'
    | 'bracket'
    | 'inverted-bracket'
    | 'triangle'
    | 'diamond'
    | 'pentagon'
    | 'hexagon'
    | 'heptagon'
    | 'octagon'
    | 'nonagon'
    | 'decagon'
    | null {
    return this.attributes['enclosure'];
  }
  setEnclosure(
    enclosure:
      | 'none'
      | 'rectangle'
      | 'square'
      | 'oval'
      | 'circle'
      | 'bracket'
      | 'inverted-bracket'
      | 'triangle'
      | 'diamond'
      | 'pentagon'
      | 'hexagon'
      | 'heptagon'
      | 'octagon'
      | 'nonagon'
      | 'decagon'
      | null
  ): DisplayText {
    this.attributes['enclosure'] = enclosure;
    return this;
  }
  getFontFamily(): string | null {
    return this.attributes['font-family'];
  }
  setFontFamily(fontFamily: string | null): DisplayText {
    this.attributes['font-family'] = fontFamily;
    return this;
  }
  getFontSize(): 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null {
    return this.attributes['font-size'];
  }
  setFontSize(
    fontSize: 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null
  ): DisplayText {
    this.attributes['font-size'] = fontSize;
    return this;
  }
  getFontStyle(): 'normal' | 'italic' | null {
    return this.attributes['font-style'];
  }
  setFontStyle(fontStyle: 'normal' | 'italic' | null): DisplayText {
    this.attributes['font-style'] = fontStyle;
    return this;
  }
  getFontWeight(): 'normal' | 'bold' | null {
    return this.attributes['font-weight'];
  }
  setFontWeight(fontWeight: 'normal' | 'bold' | null): DisplayText {
    this.attributes['font-weight'] = fontWeight;
    return this;
  }
  getHalign(): 'left' | 'center' | 'right' | null {
    return this.attributes['halign'];
  }
  setHalign(halign: 'left' | 'center' | 'right' | null): DisplayText {
    this.attributes['halign'] = halign;
    return this;
  }
  getJustify(): 'left' | 'center' | 'right' | null {
    return this.attributes['justify'];
  }
  setJustify(justify: 'left' | 'center' | 'right' | null): DisplayText {
    this.attributes['justify'] = justify;
    return this;
  }
  getLetterSpacing(): 'normal' | number | null {
    return this.attributes['letter-spacing'];
  }
  setLetterSpacing(letterSpacing: 'normal' | number | null): DisplayText {
    this.attributes['letter-spacing'] = letterSpacing;
    return this;
  }
  getLineHeight(): 'normal' | number | null {
    return this.attributes['line-height'];
  }
  setLineHeight(lineHeight: 'normal' | number | null): DisplayText {
    this.attributes['line-height'] = lineHeight;
    return this;
  }
  getLineThrough(): number | null {
    return this.attributes['line-through'];
  }
  setLineThrough(lineThrough: number | null): DisplayText {
    this.attributes['line-through'] = lineThrough;
    return this;
  }
  getOverline(): number | null {
    return this.attributes['overline'];
  }
  setOverline(overline: number | null): DisplayText {
    this.attributes['overline'] = overline;
    return this;
  }
  getRelativeX(): number | null {
    return this.attributes['relative-x'];
  }
  setRelativeX(relativeX: number | null): DisplayText {
    this.attributes['relative-x'] = relativeX;
    return this;
  }
  getRelativeY(): number | null {
    return this.attributes['relative-y'];
  }
  setRelativeY(relativeY: number | null): DisplayText {
    this.attributes['relative-y'] = relativeY;
    return this;
  }
  getRotation(): number | null {
    return this.attributes['rotation'];
  }
  setRotation(rotation: number | null): DisplayText {
    this.attributes['rotation'] = rotation;
    return this;
  }
  getUnderline(): number | null {
    return this.attributes['underline'];
  }
  setUnderline(underline: number | null): DisplayText {
    this.attributes['underline'] = underline;
    return this;
  }
  getValign(): 'top' | 'middle' | 'bottom' | 'baseline' | null {
    return this.attributes['valign'];
  }
  setValign(valign: 'top' | 'middle' | 'bottom' | 'baseline' | null): DisplayText {
    this.attributes['valign'] = valign;
    return this;
  }
  getXmlLang(): string | null {
    return this.attributes['xml:lang'];
  }
  setXmlLang(xmlLang: string | null): DisplayText {
    this.attributes['xml:lang'] = xmlLang;
    return this;
  }
  getXmlSpace(): 'default' | 'preserve' | null {
    return this.attributes['xml:space'];
  }
  setXmlSpace(xmlSpace: 'default' | 'preserve' | null): DisplayText {
    this.attributes['xml:space'] = xmlSpace;
    return this;
  }
  getText(): string | null {
    return this.contents[0];
  }
  setText(text: string | null): DisplayText {
    this.contents[0] = text;
    return this;
  }
}

export type AccidentalTextAttributes = {
  color: string | null;
  'default-x': number | null;
  'default-y': number | null;
  dir: 'ltr' | 'rtl' | 'lro' | 'rlo' | null;
  enclosure:
    | 'none'
    | 'rectangle'
    | 'square'
    | 'oval'
    | 'circle'
    | 'bracket'
    | 'inverted-bracket'
    | 'triangle'
    | 'diamond'
    | 'pentagon'
    | 'hexagon'
    | 'heptagon'
    | 'octagon'
    | 'nonagon'
    | 'decagon'
    | null;
  'font-family': string | null;
  'font-size': 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null;
  'font-style': 'normal' | 'italic' | null;
  'font-weight': 'normal' | 'bold' | null;
  halign: 'left' | 'center' | 'right' | null;
  justify: 'left' | 'center' | 'right' | null;
  'letter-spacing': 'normal' | number | null;
  'line-height': 'normal' | number | null;
  'line-through': number | null;
  overline: number | null;
  'relative-x': number | null;
  'relative-y': number | null;
  rotation: number | null;
  smufl: string | null;
  underline: number | null;
  valign: 'top' | 'middle' | 'bottom' | 'baseline' | null;
  'xml:lang': string | null;
  'xml:space': 'default' | 'preserve' | null;
};

export type AccidentalTextContents = [
  | 'other'
  | 'sharp'
  | 'natural'
  | 'flat'
  | 'double-sharp'
  | 'sharp-sharp'
  | 'flat-flat'
  | 'natural-sharp'
  | 'natural-flat'
  | 'quarter-flat'
  | 'quarter-sharp'
  | 'three-quarters-flat'
  | 'three-quarters-sharp'
  | 'sharp-down'
  | 'sharp-up'
  | 'natural-down'
  | 'natural-up'
  | 'flat-down'
  | 'flat-up'
  | 'double-sharp-down'
  | 'double-sharp-up'
  | 'flat-flat-down'
  | 'flat-flat-up'
  | 'arrow-down'
  | 'arrow-up'
  | 'triple-sharp'
  | 'triple-flat'
  | 'slash-quarter-sharp'
  | 'slash-sharp'
  | 'slash-flat'
  | 'double-slash-flat'
  | 'sharp-1'
  | 'sharp-2'
  | 'sharp-3'
  | 'sharp-5'
  | 'flat-1'
  | 'flat-2'
  | 'flat-3'
  | 'flat-4'
  | 'sori'
  | 'koron'
];

export class AccidentalText implements XMLElement<'accidental-text', AccidentalTextAttributes, AccidentalTextContents> {
  static readonly schema = {
    name: 'accidental-text',
    attributes: {
      color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
      'default-x': {
        type: 'label',
        label: 'default-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'default-y': {
        type: 'label',
        label: 'default-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      dir: { type: 'optional', value: { type: 'choices', choices: ['ltr', 'rtl', 'lro', 'rlo'] } },
      enclosure: {
        type: 'optional',
        value: {
          type: 'choices',
          choices: [
            'none',
            'rectangle',
            'square',
            'oval',
            'circle',
            'bracket',
            'inverted-bracket',
            'triangle',
            'diamond',
            'pentagon',
            'hexagon',
            'heptagon',
            'octagon',
            'nonagon',
            'decagon',
          ],
        },
      },
      'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
      'font-size': {
        type: 'optional',
        value: {
          type: 'choices',
          choices: [
            { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
            { type: 'float', min: -Infinity, max: Infinity },
          ],
        },
      },
      'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
      'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
      halign: { type: 'optional', value: { type: 'choices', choices: ['left', 'center', 'right'] } },
      justify: { type: 'optional', value: { type: 'choices', choices: ['left', 'center', 'right'] } },
      'letter-spacing': {
        type: 'optional',
        value: { type: 'choices', choices: ['normal', { type: 'float', min: -Infinity, max: Infinity }] },
      },
      'line-height': {
        type: 'optional',
        value: { type: 'choices', choices: ['normal', { type: 'float', min: -Infinity, max: Infinity }] },
      },
      'line-through': { type: 'optional', value: { type: 'int', min: 0, max: 3 } },
      overline: { type: 'optional', value: { type: 'int', min: 0, max: 3 } },
      'relative-x': {
        type: 'label',
        label: 'relative-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'relative-y': {
        type: 'label',
        label: 'relative-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      rotation: { type: 'optional', value: { type: 'float', min: -180, max: 180 } },
      smufl: {
        type: 'optional',
        value: { type: 'regex', pattern: /(acc|medRenFla|medRenNatura|medRenShar|kievanAccidental)/, zero: 'acc' },
      },
      underline: { type: 'optional', value: { type: 'int', min: 0, max: 3 } },
      valign: { type: 'optional', value: { type: 'choices', choices: ['top', 'middle', 'bottom', 'baseline'] } },
      'xml:lang': { type: 'optional', value: { type: 'string' } },
      'xml:space': { type: 'optional', value: { type: 'choices', choices: ['default', 'preserve'] } },
    },
    contents: [
      {
        type: 'label',
        label: 'accidental-value',
        value: {
          type: 'choices',
          choices: [
            'other',
            'sharp',
            'natural',
            'flat',
            'double-sharp',
            'sharp-sharp',
            'flat-flat',
            'natural-sharp',
            'natural-flat',
            'quarter-flat',
            'quarter-sharp',
            'three-quarters-flat',
            'three-quarters-sharp',
            'sharp-down',
            'sharp-up',
            'natural-down',
            'natural-up',
            'flat-down',
            'flat-up',
            'double-sharp-down',
            'double-sharp-up',
            'flat-flat-down',
            'flat-flat-up',
            'arrow-down',
            'arrow-up',
            'triple-sharp',
            'triple-flat',
            'slash-quarter-sharp',
            'slash-sharp',
            'slash-flat',
            'double-slash-flat',
            'sharp-1',
            'sharp-2',
            'sharp-3',
            'sharp-5',
            'flat-1',
            'flat-2',
            'flat-3',
            'flat-4',
            'sori',
            'koron',
          ],
        },
      },
    ],
  } as const;

  readonly schema = AccidentalText.schema;

  attributes: AccidentalTextAttributes;
  contents: AccidentalTextContents;

  constructor(opts?: { attributes?: Partial<AccidentalTextAttributes>; contents?: AccidentalTextContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, AccidentalText.schema);
    this.contents = opts?.contents ?? operations.zero(AccidentalText.schema.contents);
  }
  getColor(): string | null {
    return this.attributes['color'];
  }
  setColor(color: string | null): AccidentalText {
    this.attributes['color'] = color;
    return this;
  }
  getDefaultX(): number | null {
    return this.attributes['default-x'];
  }
  setDefaultX(defaultX: number | null): AccidentalText {
    this.attributes['default-x'] = defaultX;
    return this;
  }
  getDefaultY(): number | null {
    return this.attributes['default-y'];
  }
  setDefaultY(defaultY: number | null): AccidentalText {
    this.attributes['default-y'] = defaultY;
    return this;
  }
  getDir(): 'ltr' | 'rtl' | 'lro' | 'rlo' | null {
    return this.attributes['dir'];
  }
  setDir(dir: 'ltr' | 'rtl' | 'lro' | 'rlo' | null): AccidentalText {
    this.attributes['dir'] = dir;
    return this;
  }
  getEnclosure():
    | 'none'
    | 'rectangle'
    | 'square'
    | 'oval'
    | 'circle'
    | 'bracket'
    | 'inverted-bracket'
    | 'triangle'
    | 'diamond'
    | 'pentagon'
    | 'hexagon'
    | 'heptagon'
    | 'octagon'
    | 'nonagon'
    | 'decagon'
    | null {
    return this.attributes['enclosure'];
  }
  setEnclosure(
    enclosure:
      | 'none'
      | 'rectangle'
      | 'square'
      | 'oval'
      | 'circle'
      | 'bracket'
      | 'inverted-bracket'
      | 'triangle'
      | 'diamond'
      | 'pentagon'
      | 'hexagon'
      | 'heptagon'
      | 'octagon'
      | 'nonagon'
      | 'decagon'
      | null
  ): AccidentalText {
    this.attributes['enclosure'] = enclosure;
    return this;
  }
  getFontFamily(): string | null {
    return this.attributes['font-family'];
  }
  setFontFamily(fontFamily: string | null): AccidentalText {
    this.attributes['font-family'] = fontFamily;
    return this;
  }
  getFontSize(): 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null {
    return this.attributes['font-size'];
  }
  setFontSize(
    fontSize: 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null
  ): AccidentalText {
    this.attributes['font-size'] = fontSize;
    return this;
  }
  getFontStyle(): 'normal' | 'italic' | null {
    return this.attributes['font-style'];
  }
  setFontStyle(fontStyle: 'normal' | 'italic' | null): AccidentalText {
    this.attributes['font-style'] = fontStyle;
    return this;
  }
  getFontWeight(): 'normal' | 'bold' | null {
    return this.attributes['font-weight'];
  }
  setFontWeight(fontWeight: 'normal' | 'bold' | null): AccidentalText {
    this.attributes['font-weight'] = fontWeight;
    return this;
  }
  getHalign(): 'left' | 'center' | 'right' | null {
    return this.attributes['halign'];
  }
  setHalign(halign: 'left' | 'center' | 'right' | null): AccidentalText {
    this.attributes['halign'] = halign;
    return this;
  }
  getJustify(): 'left' | 'center' | 'right' | null {
    return this.attributes['justify'];
  }
  setJustify(justify: 'left' | 'center' | 'right' | null): AccidentalText {
    this.attributes['justify'] = justify;
    return this;
  }
  getLetterSpacing(): 'normal' | number | null {
    return this.attributes['letter-spacing'];
  }
  setLetterSpacing(letterSpacing: 'normal' | number | null): AccidentalText {
    this.attributes['letter-spacing'] = letterSpacing;
    return this;
  }
  getLineHeight(): 'normal' | number | null {
    return this.attributes['line-height'];
  }
  setLineHeight(lineHeight: 'normal' | number | null): AccidentalText {
    this.attributes['line-height'] = lineHeight;
    return this;
  }
  getLineThrough(): number | null {
    return this.attributes['line-through'];
  }
  setLineThrough(lineThrough: number | null): AccidentalText {
    this.attributes['line-through'] = lineThrough;
    return this;
  }
  getOverline(): number | null {
    return this.attributes['overline'];
  }
  setOverline(overline: number | null): AccidentalText {
    this.attributes['overline'] = overline;
    return this;
  }
  getRelativeX(): number | null {
    return this.attributes['relative-x'];
  }
  setRelativeX(relativeX: number | null): AccidentalText {
    this.attributes['relative-x'] = relativeX;
    return this;
  }
  getRelativeY(): number | null {
    return this.attributes['relative-y'];
  }
  setRelativeY(relativeY: number | null): AccidentalText {
    this.attributes['relative-y'] = relativeY;
    return this;
  }
  getRotation(): number | null {
    return this.attributes['rotation'];
  }
  setRotation(rotation: number | null): AccidentalText {
    this.attributes['rotation'] = rotation;
    return this;
  }
  getSmufl(): string | null {
    return this.attributes['smufl'];
  }
  setSmufl(smufl: string | null): AccidentalText {
    this.attributes['smufl'] = smufl;
    return this;
  }
  getUnderline(): number | null {
    return this.attributes['underline'];
  }
  setUnderline(underline: number | null): AccidentalText {
    this.attributes['underline'] = underline;
    return this;
  }
  getValign(): 'top' | 'middle' | 'bottom' | 'baseline' | null {
    return this.attributes['valign'];
  }
  setValign(valign: 'top' | 'middle' | 'bottom' | 'baseline' | null): AccidentalText {
    this.attributes['valign'] = valign;
    return this;
  }
  getXmlLang(): string | null {
    return this.attributes['xml:lang'];
  }
  setXmlLang(xmlLang: string | null): AccidentalText {
    this.attributes['xml:lang'] = xmlLang;
    return this;
  }
  getXmlSpace(): 'default' | 'preserve' | null {
    return this.attributes['xml:space'];
  }
  setXmlSpace(xmlSpace: 'default' | 'preserve' | null): AccidentalText {
    this.attributes['xml:space'] = xmlSpace;
    return this;
  }
  getAccidentalValue():
    | 'other'
    | 'sharp'
    | 'natural'
    | 'flat'
    | 'double-sharp'
    | 'sharp-sharp'
    | 'flat-flat'
    | 'natural-sharp'
    | 'natural-flat'
    | 'quarter-flat'
    | 'quarter-sharp'
    | 'three-quarters-flat'
    | 'three-quarters-sharp'
    | 'sharp-down'
    | 'sharp-up'
    | 'natural-down'
    | 'natural-up'
    | 'flat-down'
    | 'flat-up'
    | 'double-sharp-down'
    | 'double-sharp-up'
    | 'flat-flat-down'
    | 'flat-flat-up'
    | 'arrow-down'
    | 'arrow-up'
    | 'triple-sharp'
    | 'triple-flat'
    | 'slash-quarter-sharp'
    | 'slash-sharp'
    | 'slash-flat'
    | 'double-slash-flat'
    | 'sharp-1'
    | 'sharp-2'
    | 'sharp-3'
    | 'sharp-5'
    | 'flat-1'
    | 'flat-2'
    | 'flat-3'
    | 'flat-4'
    | 'sori'
    | 'koron' {
    return this.contents[0];
  }
  setAccidentalValue(
    accidentalValue:
      | 'other'
      | 'sharp'
      | 'natural'
      | 'flat'
      | 'double-sharp'
      | 'sharp-sharp'
      | 'flat-flat'
      | 'natural-sharp'
      | 'natural-flat'
      | 'quarter-flat'
      | 'quarter-sharp'
      | 'three-quarters-flat'
      | 'three-quarters-sharp'
      | 'sharp-down'
      | 'sharp-up'
      | 'natural-down'
      | 'natural-up'
      | 'flat-down'
      | 'flat-up'
      | 'double-sharp-down'
      | 'double-sharp-up'
      | 'flat-flat-down'
      | 'flat-flat-up'
      | 'arrow-down'
      | 'arrow-up'
      | 'triple-sharp'
      | 'triple-flat'
      | 'slash-quarter-sharp'
      | 'slash-sharp'
      | 'slash-flat'
      | 'double-slash-flat'
      | 'sharp-1'
      | 'sharp-2'
      | 'sharp-3'
      | 'sharp-5'
      | 'flat-1'
      | 'flat-2'
      | 'flat-3'
      | 'flat-4'
      | 'sori'
      | 'koron'
  ): AccidentalText {
    this.contents[0] = accidentalValue;
    return this;
  }
}

export type GroupNameDisplayAttributes = { 'print-object': 'yes' | 'no' | null };

export type GroupNameDisplayContents = [Array<DisplayText | AccidentalText>];

export class GroupNameDisplay
  implements XMLElement<'group-name-display', GroupNameDisplayAttributes, GroupNameDisplayContents>
{
  static readonly schema = {
    name: 'group-name-display',
    attributes: { 'print-object': { type: 'optional', value: { type: 'choices', choices: ['yes', 'no'] } } },
    contents: [
      {
        type: 'label',
        label: 'texts',
        value: { type: 'zeroOrMore', value: { type: 'choices', choices: [DisplayText, AccidentalText] } },
      },
    ],
  } as const;

  readonly schema = GroupNameDisplay.schema;

  attributes: GroupNameDisplayAttributes;
  contents: GroupNameDisplayContents;

  constructor(opts?: { attributes?: Partial<GroupNameDisplayAttributes>; contents?: GroupNameDisplayContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, GroupNameDisplay.schema);
    this.contents = opts?.contents ?? operations.zero(GroupNameDisplay.schema.contents);
  }
  getPrintObject(): 'yes' | 'no' | null {
    return this.attributes['print-object'];
  }
  setPrintObject(printObject: 'yes' | 'no' | null): GroupNameDisplay {
    this.attributes['print-object'] = printObject;
    return this;
  }
  getTexts(): Array<DisplayText | AccidentalText> {
    return this.contents[0];
  }
  setTexts(texts: Array<DisplayText | AccidentalText>): GroupNameDisplay {
    this.contents[0] = texts;
    return this;
  }
}

export type GroupAbbreviationAttributes = {
  color: string | null;
  'default-x': number | null;
  'default-y': number | null;
  'font-family': string | null;
  'font-size': 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null;
  'font-style': 'normal' | 'italic' | null;
  'font-weight': 'normal' | 'bold' | null;
  justify: 'left' | 'center' | 'right' | null;
  'relative-x': number | null;
  'relative-y': number | null;
};

export type GroupAbbreviationContents = [string];

export class GroupAbbreviation
  implements XMLElement<'group-abbreviation', GroupAbbreviationAttributes, GroupAbbreviationContents>
{
  static readonly schema = {
    name: 'group-abbreviation',
    attributes: {
      color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
      'default-x': {
        type: 'label',
        label: 'default-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'default-y': {
        type: 'label',
        label: 'default-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
      'font-size': {
        type: 'optional',
        value: {
          type: 'choices',
          choices: [
            { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
            { type: 'float', min: -Infinity, max: Infinity },
          ],
        },
      },
      'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
      'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
      justify: { type: 'optional', value: { type: 'choices', choices: ['left', 'center', 'right'] } },
      'relative-x': {
        type: 'label',
        label: 'relative-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'relative-y': {
        type: 'label',
        label: 'relative-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
    },
    contents: [{ type: 'string' }],
  } as const;

  readonly schema = GroupAbbreviation.schema;

  attributes: GroupAbbreviationAttributes;
  contents: GroupAbbreviationContents;

  constructor(opts?: { attributes?: Partial<GroupAbbreviationAttributes>; contents?: GroupAbbreviationContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, GroupAbbreviation.schema);
    this.contents = opts?.contents ?? operations.zero(GroupAbbreviation.schema.contents);
  }
  getColor(): string | null {
    return this.attributes['color'];
  }
  setColor(color: string | null): GroupAbbreviation {
    this.attributes['color'] = color;
    return this;
  }
  getDefaultX(): number | null {
    return this.attributes['default-x'];
  }
  setDefaultX(defaultX: number | null): GroupAbbreviation {
    this.attributes['default-x'] = defaultX;
    return this;
  }
  getDefaultY(): number | null {
    return this.attributes['default-y'];
  }
  setDefaultY(defaultY: number | null): GroupAbbreviation {
    this.attributes['default-y'] = defaultY;
    return this;
  }
  getFontFamily(): string | null {
    return this.attributes['font-family'];
  }
  setFontFamily(fontFamily: string | null): GroupAbbreviation {
    this.attributes['font-family'] = fontFamily;
    return this;
  }
  getFontSize(): 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null {
    return this.attributes['font-size'];
  }
  setFontSize(
    fontSize: 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null
  ): GroupAbbreviation {
    this.attributes['font-size'] = fontSize;
    return this;
  }
  getFontStyle(): 'normal' | 'italic' | null {
    return this.attributes['font-style'];
  }
  setFontStyle(fontStyle: 'normal' | 'italic' | null): GroupAbbreviation {
    this.attributes['font-style'] = fontStyle;
    return this;
  }
  getFontWeight(): 'normal' | 'bold' | null {
    return this.attributes['font-weight'];
  }
  setFontWeight(fontWeight: 'normal' | 'bold' | null): GroupAbbreviation {
    this.attributes['font-weight'] = fontWeight;
    return this;
  }
  getJustify(): 'left' | 'center' | 'right' | null {
    return this.attributes['justify'];
  }
  setJustify(justify: 'left' | 'center' | 'right' | null): GroupAbbreviation {
    this.attributes['justify'] = justify;
    return this;
  }
  getRelativeX(): number | null {
    return this.attributes['relative-x'];
  }
  setRelativeX(relativeX: number | null): GroupAbbreviation {
    this.attributes['relative-x'] = relativeX;
    return this;
  }
  getRelativeY(): number | null {
    return this.attributes['relative-y'];
  }
  setRelativeY(relativeY: number | null): GroupAbbreviation {
    this.attributes['relative-y'] = relativeY;
    return this;
  }
  getText(): string {
    return this.contents[0];
  }
  setText(text: string): GroupAbbreviation {
    this.contents[0] = text;
    return this;
  }
}

export type GroupAbbreviationDisplayAttributes = { 'print-object': 'yes' | 'no' | null };

export type GroupAbbreviationDisplayContents = [Array<DisplayText | AccidentalText>];

export class GroupAbbreviationDisplay
  implements
    XMLElement<'group-abbreviation-display', GroupAbbreviationDisplayAttributes, GroupAbbreviationDisplayContents>
{
  static readonly schema = {
    name: 'group-abbreviation-display',
    attributes: { 'print-object': { type: 'optional', value: { type: 'choices', choices: ['yes', 'no'] } } },
    contents: [
      {
        type: 'label',
        label: 'texts',
        value: { type: 'zeroOrMore', value: { type: 'choices', choices: [DisplayText, AccidentalText] } },
      },
    ],
  } as const;

  readonly schema = GroupAbbreviationDisplay.schema;

  attributes: GroupAbbreviationDisplayAttributes;
  contents: GroupAbbreviationDisplayContents;

  constructor(opts?: {
    attributes?: Partial<GroupAbbreviationDisplayAttributes>;
    contents?: GroupAbbreviationDisplayContents;
  }) {
    this.attributes = operations.merge(opts?.attributes || {}, GroupAbbreviationDisplay.schema);
    this.contents = opts?.contents ?? operations.zero(GroupAbbreviationDisplay.schema.contents);
  }
  getPrintObject(): 'yes' | 'no' | null {
    return this.attributes['print-object'];
  }
  setPrintObject(printObject: 'yes' | 'no' | null): GroupAbbreviationDisplay {
    this.attributes['print-object'] = printObject;
    return this;
  }
  getTexts(): Array<DisplayText | AccidentalText> {
    return this.contents[0];
  }
  setTexts(texts: Array<DisplayText | AccidentalText>): GroupAbbreviationDisplay {
    this.contents[0] = texts;
    return this;
  }
}

export type GroupSymbolAttributes = {
  color: string | null;
  'default-x': number | null;
  'default-y': number | null;
  'relative-x': number | null;
  'relative-y': number | null;
};

export type GroupSymbolContents = ['none' | 'brace' | 'bracket' | 'line' | 'square'];

export class GroupSymbol implements XMLElement<'group-symbol', GroupSymbolAttributes, GroupSymbolContents> {
  static readonly schema = {
    name: 'group-symbol',
    attributes: {
      color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
      'default-x': {
        type: 'label',
        label: 'default-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'default-y': {
        type: 'label',
        label: 'default-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'relative-x': {
        type: 'label',
        label: 'relative-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'relative-y': {
        type: 'label',
        label: 'relative-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
    },
    contents: [
      {
        type: 'required',
        value: {
          type: 'label',
          label: 'group-symbol-value',
          value: { type: 'choices', choices: ['none', 'brace', 'bracket', 'line', 'square'] },
        },
      },
    ],
  } as const;

  readonly schema = GroupSymbol.schema;

  attributes: GroupSymbolAttributes;
  contents: GroupSymbolContents;

  constructor(opts?: { attributes?: Partial<GroupSymbolAttributes>; contents?: GroupSymbolContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, GroupSymbol.schema);
    this.contents = opts?.contents ?? operations.zero(GroupSymbol.schema.contents);
  }
  getColor(): string | null {
    return this.attributes['color'];
  }
  setColor(color: string | null): GroupSymbol {
    this.attributes['color'] = color;
    return this;
  }
  getDefaultX(): number | null {
    return this.attributes['default-x'];
  }
  setDefaultX(defaultX: number | null): GroupSymbol {
    this.attributes['default-x'] = defaultX;
    return this;
  }
  getDefaultY(): number | null {
    return this.attributes['default-y'];
  }
  setDefaultY(defaultY: number | null): GroupSymbol {
    this.attributes['default-y'] = defaultY;
    return this;
  }
  getRelativeX(): number | null {
    return this.attributes['relative-x'];
  }
  setRelativeX(relativeX: number | null): GroupSymbol {
    this.attributes['relative-x'] = relativeX;
    return this;
  }
  getRelativeY(): number | null {
    return this.attributes['relative-y'];
  }
  setRelativeY(relativeY: number | null): GroupSymbol {
    this.attributes['relative-y'] = relativeY;
    return this;
  }
  getGroupSymbolValue(): 'none' | 'brace' | 'bracket' | 'line' | 'square' {
    return this.contents[0];
  }
  setGroupSymbolValue(groupSymbolValue: 'none' | 'brace' | 'bracket' | 'line' | 'square'): GroupSymbol {
    this.contents[0] = groupSymbolValue;
    return this;
  }
}

export type GroupBarlineAttributes = { color: string | null };

export type GroupBarlineContents = ['yes' | 'no' | 'Mensurstrich'];

export class GroupBarline implements XMLElement<'group-barline', GroupBarlineAttributes, GroupBarlineContents> {
  static readonly schema = {
    name: 'group-barline',
    attributes: {
      color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
    },
    contents: [
      {
        type: 'required',
        value: {
          type: 'label',
          label: 'group-barline-value',
          value: { type: 'choices', choices: ['yes', 'no', 'Mensurstrich'] },
        },
      },
    ],
  } as const;

  readonly schema = GroupBarline.schema;

  attributes: GroupBarlineAttributes;
  contents: GroupBarlineContents;

  constructor(opts?: { attributes?: Partial<GroupBarlineAttributes>; contents?: GroupBarlineContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, GroupBarline.schema);
    this.contents = opts?.contents ?? operations.zero(GroupBarline.schema.contents);
  }
  getColor(): string | null {
    return this.attributes['color'];
  }
  setColor(color: string | null): GroupBarline {
    this.attributes['color'] = color;
    return this;
  }
  getGroupBarlineValue(): 'yes' | 'no' | 'Mensurstrich' {
    return this.contents[0];
  }
  setGroupBarlineValue(groupBarlineValue: 'yes' | 'no' | 'Mensurstrich'): GroupBarline {
    this.contents[0] = groupBarlineValue;
    return this;
  }
}

export type GroupTimeAttributes = Record<string, unknown>;

export type GroupTimeContents = [];

export class GroupTime implements XMLElement<'group-time', GroupTimeAttributes, GroupTimeContents> {
  static readonly schema = { name: 'group-time', attributes: {}, contents: [] } as const;

  readonly schema = GroupTime.schema;

  attributes: GroupTimeAttributes;
  contents: GroupTimeContents;

  constructor(opts?: { attributes?: Partial<GroupTimeAttributes>; contents?: GroupTimeContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, GroupTime.schema);
    this.contents = opts?.contents ?? operations.zero(GroupTime.schema.contents);
  }
}

export type FootnoteAttributes = {
  color: string | null;
  'default-x': number | null;
  'default-y': number | null;
  dir: 'ltr' | 'rtl' | 'lro' | 'rlo' | null;
  enclosure:
    | 'none'
    | 'rectangle'
    | 'square'
    | 'oval'
    | 'circle'
    | 'bracket'
    | 'inverted-bracket'
    | 'triangle'
    | 'diamond'
    | 'pentagon'
    | 'hexagon'
    | 'heptagon'
    | 'octagon'
    | 'nonagon'
    | 'decagon'
    | null;
  'font-family': string | null;
  'font-size': 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null;
  'font-style': 'normal' | 'italic' | null;
  'font-weight': 'normal' | 'bold' | null;
  halign: 'left' | 'center' | 'right' | null;
  justify: 'left' | 'center' | 'right' | null;
  'letter-spacing': 'normal' | number | null;
  'line-height': 'normal' | number | null;
  'line-through': number | null;
  overline: number | null;
  'relative-x': number | null;
  'relative-y': number | null;
  rotation: number | null;
  underline: number | null;
  valign: 'top' | 'middle' | 'bottom' | 'baseline' | null;
  'xml:lang': string | null;
  'xml:space': 'default' | 'preserve' | null;
};

export type FootnoteContents = [string];

export class Footnote implements XMLElement<'footnote', FootnoteAttributes, FootnoteContents> {
  static readonly schema = {
    name: 'footnote',
    attributes: {
      color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
      'default-x': {
        type: 'label',
        label: 'default-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'default-y': {
        type: 'label',
        label: 'default-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      dir: { type: 'optional', value: { type: 'choices', choices: ['ltr', 'rtl', 'lro', 'rlo'] } },
      enclosure: {
        type: 'optional',
        value: {
          type: 'choices',
          choices: [
            'none',
            'rectangle',
            'square',
            'oval',
            'circle',
            'bracket',
            'inverted-bracket',
            'triangle',
            'diamond',
            'pentagon',
            'hexagon',
            'heptagon',
            'octagon',
            'nonagon',
            'decagon',
          ],
        },
      },
      'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
      'font-size': {
        type: 'optional',
        value: {
          type: 'choices',
          choices: [
            { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
            { type: 'float', min: -Infinity, max: Infinity },
          ],
        },
      },
      'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
      'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
      halign: { type: 'optional', value: { type: 'choices', choices: ['left', 'center', 'right'] } },
      justify: { type: 'optional', value: { type: 'choices', choices: ['left', 'center', 'right'] } },
      'letter-spacing': {
        type: 'optional',
        value: { type: 'choices', choices: ['normal', { type: 'float', min: -Infinity, max: Infinity }] },
      },
      'line-height': {
        type: 'optional',
        value: { type: 'choices', choices: ['normal', { type: 'float', min: -Infinity, max: Infinity }] },
      },
      'line-through': { type: 'optional', value: { type: 'int', min: 0, max: 3 } },
      overline: { type: 'optional', value: { type: 'int', min: 0, max: 3 } },
      'relative-x': {
        type: 'label',
        label: 'relative-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'relative-y': {
        type: 'label',
        label: 'relative-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      rotation: { type: 'optional', value: { type: 'float', min: -180, max: 180 } },
      underline: { type: 'optional', value: { type: 'int', min: 0, max: 3 } },
      valign: { type: 'optional', value: { type: 'choices', choices: ['top', 'middle', 'bottom', 'baseline'] } },
      'xml:lang': { type: 'optional', value: { type: 'string' } },
      'xml:space': { type: 'optional', value: { type: 'choices', choices: ['default', 'preserve'] } },
    },
    contents: [{ type: 'required', value: { type: 'string' } }],
  } as const;

  readonly schema = Footnote.schema;

  attributes: FootnoteAttributes;
  contents: FootnoteContents;

  constructor(opts?: { attributes?: Partial<FootnoteAttributes>; contents?: FootnoteContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Footnote.schema);
    this.contents = opts?.contents ?? operations.zero(Footnote.schema.contents);
  }
  getColor(): string | null {
    return this.attributes['color'];
  }
  setColor(color: string | null): Footnote {
    this.attributes['color'] = color;
    return this;
  }
  getDefaultX(): number | null {
    return this.attributes['default-x'];
  }
  setDefaultX(defaultX: number | null): Footnote {
    this.attributes['default-x'] = defaultX;
    return this;
  }
  getDefaultY(): number | null {
    return this.attributes['default-y'];
  }
  setDefaultY(defaultY: number | null): Footnote {
    this.attributes['default-y'] = defaultY;
    return this;
  }
  getDir(): 'ltr' | 'rtl' | 'lro' | 'rlo' | null {
    return this.attributes['dir'];
  }
  setDir(dir: 'ltr' | 'rtl' | 'lro' | 'rlo' | null): Footnote {
    this.attributes['dir'] = dir;
    return this;
  }
  getEnclosure():
    | 'none'
    | 'rectangle'
    | 'square'
    | 'oval'
    | 'circle'
    | 'bracket'
    | 'inverted-bracket'
    | 'triangle'
    | 'diamond'
    | 'pentagon'
    | 'hexagon'
    | 'heptagon'
    | 'octagon'
    | 'nonagon'
    | 'decagon'
    | null {
    return this.attributes['enclosure'];
  }
  setEnclosure(
    enclosure:
      | 'none'
      | 'rectangle'
      | 'square'
      | 'oval'
      | 'circle'
      | 'bracket'
      | 'inverted-bracket'
      | 'triangle'
      | 'diamond'
      | 'pentagon'
      | 'hexagon'
      | 'heptagon'
      | 'octagon'
      | 'nonagon'
      | 'decagon'
      | null
  ): Footnote {
    this.attributes['enclosure'] = enclosure;
    return this;
  }
  getFontFamily(): string | null {
    return this.attributes['font-family'];
  }
  setFontFamily(fontFamily: string | null): Footnote {
    this.attributes['font-family'] = fontFamily;
    return this;
  }
  getFontSize(): 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null {
    return this.attributes['font-size'];
  }
  setFontSize(
    fontSize: 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null
  ): Footnote {
    this.attributes['font-size'] = fontSize;
    return this;
  }
  getFontStyle(): 'normal' | 'italic' | null {
    return this.attributes['font-style'];
  }
  setFontStyle(fontStyle: 'normal' | 'italic' | null): Footnote {
    this.attributes['font-style'] = fontStyle;
    return this;
  }
  getFontWeight(): 'normal' | 'bold' | null {
    return this.attributes['font-weight'];
  }
  setFontWeight(fontWeight: 'normal' | 'bold' | null): Footnote {
    this.attributes['font-weight'] = fontWeight;
    return this;
  }
  getHalign(): 'left' | 'center' | 'right' | null {
    return this.attributes['halign'];
  }
  setHalign(halign: 'left' | 'center' | 'right' | null): Footnote {
    this.attributes['halign'] = halign;
    return this;
  }
  getJustify(): 'left' | 'center' | 'right' | null {
    return this.attributes['justify'];
  }
  setJustify(justify: 'left' | 'center' | 'right' | null): Footnote {
    this.attributes['justify'] = justify;
    return this;
  }
  getLetterSpacing(): 'normal' | number | null {
    return this.attributes['letter-spacing'];
  }
  setLetterSpacing(letterSpacing: 'normal' | number | null): Footnote {
    this.attributes['letter-spacing'] = letterSpacing;
    return this;
  }
  getLineHeight(): 'normal' | number | null {
    return this.attributes['line-height'];
  }
  setLineHeight(lineHeight: 'normal' | number | null): Footnote {
    this.attributes['line-height'] = lineHeight;
    return this;
  }
  getLineThrough(): number | null {
    return this.attributes['line-through'];
  }
  setLineThrough(lineThrough: number | null): Footnote {
    this.attributes['line-through'] = lineThrough;
    return this;
  }
  getOverline(): number | null {
    return this.attributes['overline'];
  }
  setOverline(overline: number | null): Footnote {
    this.attributes['overline'] = overline;
    return this;
  }
  getRelativeX(): number | null {
    return this.attributes['relative-x'];
  }
  setRelativeX(relativeX: number | null): Footnote {
    this.attributes['relative-x'] = relativeX;
    return this;
  }
  getRelativeY(): number | null {
    return this.attributes['relative-y'];
  }
  setRelativeY(relativeY: number | null): Footnote {
    this.attributes['relative-y'] = relativeY;
    return this;
  }
  getRotation(): number | null {
    return this.attributes['rotation'];
  }
  setRotation(rotation: number | null): Footnote {
    this.attributes['rotation'] = rotation;
    return this;
  }
  getUnderline(): number | null {
    return this.attributes['underline'];
  }
  setUnderline(underline: number | null): Footnote {
    this.attributes['underline'] = underline;
    return this;
  }
  getValign(): 'top' | 'middle' | 'bottom' | 'baseline' | null {
    return this.attributes['valign'];
  }
  setValign(valign: 'top' | 'middle' | 'bottom' | 'baseline' | null): Footnote {
    this.attributes['valign'] = valign;
    return this;
  }
  getXmlLang(): string | null {
    return this.attributes['xml:lang'];
  }
  setXmlLang(xmlLang: string | null): Footnote {
    this.attributes['xml:lang'] = xmlLang;
    return this;
  }
  getXmlSpace(): 'default' | 'preserve' | null {
    return this.attributes['xml:space'];
  }
  setXmlSpace(xmlSpace: 'default' | 'preserve' | null): Footnote {
    this.attributes['xml:space'] = xmlSpace;
    return this;
  }
  getText(): string {
    return this.contents[0];
  }
  setText(text: string): Footnote {
    this.contents[0] = text;
    return this;
  }
}

export type LevelAttributes = {
  bracket: 'yes' | 'no' | null;
  parentheses: 'yes' | 'no' | null;
  reference: 'yes' | 'no' | null;
  size: 'cue' | 'full' | 'grace-cue' | 'large' | null;
  type: 'start' | 'stop' | 'single' | null;
};

export type LevelContents = [string];

export class Level implements XMLElement<'level', LevelAttributes, LevelContents> {
  static readonly schema = {
    name: 'level',
    attributes: {
      bracket: { type: 'optional', value: { type: 'choices', choices: ['yes', 'no'] } },
      parentheses: { type: 'optional', value: { type: 'choices', choices: ['yes', 'no'] } },
      reference: { type: 'optional', value: { type: 'choices', choices: ['yes', 'no'] } },
      size: { type: 'optional', value: { type: 'choices', choices: ['cue', 'full', 'grace-cue', 'large'] } },
      type: { type: 'optional', value: { type: 'choices', choices: ['start', 'stop', 'single'] } },
    },
    contents: [{ type: 'required', value: { type: 'string' } }],
  } as const;

  readonly schema = Level.schema;

  attributes: LevelAttributes;
  contents: LevelContents;

  constructor(opts?: { attributes?: Partial<LevelAttributes>; contents?: LevelContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Level.schema);
    this.contents = opts?.contents ?? operations.zero(Level.schema.contents);
  }
  getBracket(): 'yes' | 'no' | null {
    return this.attributes['bracket'];
  }
  setBracket(bracket: 'yes' | 'no' | null): Level {
    this.attributes['bracket'] = bracket;
    return this;
  }
  getParentheses(): 'yes' | 'no' | null {
    return this.attributes['parentheses'];
  }
  setParentheses(parentheses: 'yes' | 'no' | null): Level {
    this.attributes['parentheses'] = parentheses;
    return this;
  }
  getReference(): 'yes' | 'no' | null {
    return this.attributes['reference'];
  }
  setReference(reference: 'yes' | 'no' | null): Level {
    this.attributes['reference'] = reference;
    return this;
  }
  getSize(): 'cue' | 'full' | 'grace-cue' | 'large' | null {
    return this.attributes['size'];
  }
  setSize(size: 'cue' | 'full' | 'grace-cue' | 'large' | null): Level {
    this.attributes['size'] = size;
    return this;
  }
  getType(): 'start' | 'stop' | 'single' | null {
    return this.attributes['type'];
  }
  setType(type: 'start' | 'stop' | 'single' | null): Level {
    this.attributes['type'] = type;
    return this;
  }
  getText(): string {
    return this.contents[0];
  }
  setText(text: string): Level {
    this.contents[0] = text;
    return this;
  }
}

export type PartGroupAttributes = { type: 'start' | 'stop'; number: string | null };

export type PartGroupContents = [
  GroupName | null,
  GroupNameDisplay | null,
  GroupAbbreviation | null,
  GroupAbbreviationDisplay | null,
  GroupSymbol | null,
  GroupBarline | null,
  GroupTime | null,
  Footnote | null,
  Level | null
];

export class PartGroup implements XMLElement<'part-group', PartGroupAttributes, PartGroupContents> {
  static readonly schema = {
    name: 'part-group',
    attributes: {
      type: { type: 'required', value: { type: 'choices', choices: ['start', 'stop'] } },
      number: { type: 'optional', value: { type: 'string' } },
    },
    contents: [
      { type: 'optional', value: GroupName },
      { type: 'optional', value: GroupNameDisplay },
      { type: 'optional', value: GroupAbbreviation },
      { type: 'optional', value: GroupAbbreviationDisplay },
      { type: 'optional', value: GroupSymbol },
      { type: 'optional', value: GroupBarline },
      { type: 'optional', value: GroupTime },
      { type: 'optional', value: Footnote },
      { type: 'optional', value: Level },
    ],
  } as const;

  readonly schema = PartGroup.schema;

  attributes: PartGroupAttributes;
  contents: PartGroupContents;

  constructor(opts?: { attributes?: Partial<PartGroupAttributes>; contents?: PartGroupContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, PartGroup.schema);
    this.contents = opts?.contents ?? operations.zero(PartGroup.schema.contents);
  }
  getType(): 'start' | 'stop' {
    return this.attributes['type'];
  }
  setType(type: 'start' | 'stop'): PartGroup {
    this.attributes['type'] = type;
    return this;
  }
  getNumber(): string | null {
    return this.attributes['number'];
  }
  setNumber(number: string | null): PartGroup {
    this.attributes['number'] = number;
    return this;
  }
  getGroupName(): GroupName | null {
    return this.contents[0];
  }
  setGroupName(groupName: GroupName | null): PartGroup {
    this.contents[0] = groupName;
    return this;
  }
  getGroupNameDisplay(): GroupNameDisplay | null {
    return this.contents[1];
  }
  setGroupNameDisplay(groupNameDisplay: GroupNameDisplay | null): PartGroup {
    this.contents[1] = groupNameDisplay;
    return this;
  }
  getGroupAbbreviation(): GroupAbbreviation | null {
    return this.contents[2];
  }
  setGroupAbbreviation(groupAbbreviation: GroupAbbreviation | null): PartGroup {
    this.contents[2] = groupAbbreviation;
    return this;
  }
  getGroupAbbreviationDisplay(): GroupAbbreviationDisplay | null {
    return this.contents[3];
  }
  setGroupAbbreviationDisplay(groupAbbreviationDisplay: GroupAbbreviationDisplay | null): PartGroup {
    this.contents[3] = groupAbbreviationDisplay;
    return this;
  }
  getGroupSymbol(): GroupSymbol | null {
    return this.contents[4];
  }
  setGroupSymbol(groupSymbol: GroupSymbol | null): PartGroup {
    this.contents[4] = groupSymbol;
    return this;
  }
  getGroupBarline(): GroupBarline | null {
    return this.contents[5];
  }
  setGroupBarline(groupBarline: GroupBarline | null): PartGroup {
    this.contents[5] = groupBarline;
    return this;
  }
  getGroupTime(): GroupTime | null {
    return this.contents[6];
  }
  setGroupTime(groupTime: GroupTime | null): PartGroup {
    this.contents[6] = groupTime;
    return this;
  }
  getFootnote(): Footnote | null {
    return this.contents[7];
  }
  setFootnote(footnote: Footnote | null): PartGroup {
    this.contents[7] = footnote;
    return this;
  }
  getLevel(): Level | null {
    return this.contents[8];
  }
  setLevel(level: Level | null): PartGroup {
    this.contents[8] = level;
    return this;
  }
}

export type InstrumentLinkAttributes = { id: string };

export type InstrumentLinkContents = [];

export class InstrumentLink implements XMLElement<'instrument-link', InstrumentLinkAttributes, InstrumentLinkContents> {
  static readonly schema = {
    name: 'instrument-link',
    attributes: { id: { type: 'required', value: { type: 'regex', pattern: /[A-Za-z_][A-Za-z0-9.-_]*/, zero: '_' } } },
    contents: [],
  } as const;

  readonly schema = InstrumentLink.schema;

  attributes: InstrumentLinkAttributes;
  contents: InstrumentLinkContents;

  constructor(opts?: { attributes?: Partial<InstrumentLinkAttributes>; contents?: InstrumentLinkContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, InstrumentLink.schema);
    this.contents = opts?.contents ?? operations.zero(InstrumentLink.schema.contents);
  }
  getId(): string {
    return this.attributes['id'];
  }
  setId(id: string): InstrumentLink {
    this.attributes['id'] = id;
    return this;
  }
}

export type GroupLinkAttributes = Record<string, unknown>;

export type GroupLinkContents = [string];

export class GroupLink implements XMLElement<'group-link', GroupLinkAttributes, GroupLinkContents> {
  static readonly schema = {
    name: 'group-link',
    attributes: {},
    contents: [{ type: 'required', value: { type: 'string' } }],
  } as const;

  readonly schema = GroupLink.schema;

  attributes: GroupLinkAttributes;
  contents: GroupLinkContents;

  constructor(opts?: { attributes?: Partial<GroupLinkAttributes>; contents?: GroupLinkContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, GroupLink.schema);
    this.contents = opts?.contents ?? operations.zero(GroupLink.schema.contents);
  }

  getText(): string {
    return this.contents[0];
  }
  setText(text: string): GroupLink {
    this.contents[0] = text;
    return this;
  }
}

export type PartLinkAttributes = {
  'xlink:href': string;
  'xlink:actuate': 'none' | 'onRequest' | 'onLoad' | 'other' | null;
  'xlink:role': string | null;
  'xlink:show': 'none' | 'new' | 'replace' | 'embed' | 'other' | null;
  'xlink:title': string | null;
  'xlink:type': 'simple' | null;
};

export type PartLinkContents = [Array<InstrumentLink>, Array<GroupLink>];

export class PartLink implements XMLElement<'part-link', PartLinkAttributes, PartLinkContents> {
  static readonly schema = {
    name: 'part-link',
    attributes: {
      'xlink:href': { type: 'required', value: { type: 'string' } },
      'xlink:actuate': {
        type: 'optional',
        value: { type: 'choices', choices: ['none', 'onRequest', 'onLoad', 'other'] },
      },
      'xlink:role': { type: 'optional', value: { type: 'string' } },
      'xlink:show': {
        type: 'optional',
        value: { type: 'choices', choices: ['none', 'new', 'replace', 'embed', 'other'] },
      },
      'xlink:title': { type: 'optional', value: { type: 'string' } },
      'xlink:type': { type: 'optional', value: { type: 'choices', choices: ['simple'] } },
    },
    contents: [
      { type: 'label', label: 'instrument-links', value: { type: 'zeroOrMore', value: InstrumentLink } },
      { type: 'label', label: 'group-links', value: { type: 'zeroOrMore', value: GroupLink } },
    ],
  } as const;

  readonly schema = PartLink.schema;

  attributes: PartLinkAttributes;
  contents: PartLinkContents;

  constructor(opts?: { attributes?: Partial<PartLinkAttributes>; contents?: PartLinkContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, PartLink.schema);
    this.contents = opts?.contents ?? operations.zero(PartLink.schema.contents);
  }
  getXlinkHref(): string {
    return this.attributes['xlink:href'];
  }
  setXlinkHref(xlinkHref: string): PartLink {
    this.attributes['xlink:href'] = xlinkHref;
    return this;
  }
  getXlinkActuate(): 'none' | 'onRequest' | 'onLoad' | 'other' | null {
    return this.attributes['xlink:actuate'];
  }
  setXlinkActuate(xlinkActuate: 'none' | 'onRequest' | 'onLoad' | 'other' | null): PartLink {
    this.attributes['xlink:actuate'] = xlinkActuate;
    return this;
  }
  getXlinkRole(): string | null {
    return this.attributes['xlink:role'];
  }
  setXlinkRole(xlinkRole: string | null): PartLink {
    this.attributes['xlink:role'] = xlinkRole;
    return this;
  }
  getXlinkShow(): 'none' | 'new' | 'replace' | 'embed' | 'other' | null {
    return this.attributes['xlink:show'];
  }
  setXlinkShow(xlinkShow: 'none' | 'new' | 'replace' | 'embed' | 'other' | null): PartLink {
    this.attributes['xlink:show'] = xlinkShow;
    return this;
  }
  getXlinkTitle(): string | null {
    return this.attributes['xlink:title'];
  }
  setXlinkTitle(xlinkTitle: string | null): PartLink {
    this.attributes['xlink:title'] = xlinkTitle;
    return this;
  }
  getXlinkType(): 'simple' | null {
    return this.attributes['xlink:type'];
  }
  setXlinkType(xlinkType: 'simple' | null): PartLink {
    this.attributes['xlink:type'] = xlinkType;
    return this;
  }
  getInstrumentLinks(): Array<InstrumentLink> {
    return this.contents[0];
  }
  setInstrumentLinks(instrumentLinks: Array<InstrumentLink>): PartLink {
    this.contents[0] = instrumentLinks;
    return this;
  }
  getGroupLinks(): Array<GroupLink> {
    return this.contents[1];
  }
  setGroupLinks(groupLinks: Array<GroupLink>): PartLink {
    this.contents[1] = groupLinks;
    return this;
  }
}

export type PartNameAttributes = {
  color: string | null;
  'default-x': number | null;
  'default-y': number | null;
  'font-family': string | null;
  'font-size': 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null;
  'font-style': 'normal' | 'italic' | null;
  'font-weight': 'normal' | 'bold' | null;
  justify: 'left' | 'center' | 'right' | null;
  'print-object': 'yes' | 'no' | null;
  'relative-x': number | null;
  'relative-y': number | null;
};

export type PartNameContents = [string];

export class PartName implements XMLElement<'part-name', PartNameAttributes, PartNameContents> {
  static readonly schema = {
    name: 'part-name',
    attributes: {
      color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
      'default-x': {
        type: 'label',
        label: 'default-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'default-y': {
        type: 'label',
        label: 'default-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
      'font-size': {
        type: 'optional',
        value: {
          type: 'choices',
          choices: [
            { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
            { type: 'float', min: -Infinity, max: Infinity },
          ],
        },
      },
      'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
      'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
      justify: { type: 'optional', value: { type: 'choices', choices: ['left', 'center', 'right'] } },
      'print-object': { type: 'optional', value: { type: 'choices', choices: ['yes', 'no'] } },
      'relative-x': {
        type: 'label',
        label: 'relative-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'relative-y': {
        type: 'label',
        label: 'relative-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
    },
    contents: [{ type: 'required', value: { type: 'string' } }],
  } as const;

  readonly schema = PartName.schema;

  attributes: PartNameAttributes;
  contents: PartNameContents;

  constructor(opts?: { attributes?: Partial<PartNameAttributes>; contents?: PartNameContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, PartName.schema);
    this.contents = opts?.contents ?? operations.zero(PartName.schema.contents);
  }
  getColor(): string | null {
    return this.attributes['color'];
  }
  setColor(color: string | null): PartName {
    this.attributes['color'] = color;
    return this;
  }
  getDefaultX(): number | null {
    return this.attributes['default-x'];
  }
  setDefaultX(defaultX: number | null): PartName {
    this.attributes['default-x'] = defaultX;
    return this;
  }
  getDefaultY(): number | null {
    return this.attributes['default-y'];
  }
  setDefaultY(defaultY: number | null): PartName {
    this.attributes['default-y'] = defaultY;
    return this;
  }
  getFontFamily(): string | null {
    return this.attributes['font-family'];
  }
  setFontFamily(fontFamily: string | null): PartName {
    this.attributes['font-family'] = fontFamily;
    return this;
  }
  getFontSize(): 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null {
    return this.attributes['font-size'];
  }
  setFontSize(
    fontSize: 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null
  ): PartName {
    this.attributes['font-size'] = fontSize;
    return this;
  }
  getFontStyle(): 'normal' | 'italic' | null {
    return this.attributes['font-style'];
  }
  setFontStyle(fontStyle: 'normal' | 'italic' | null): PartName {
    this.attributes['font-style'] = fontStyle;
    return this;
  }
  getFontWeight(): 'normal' | 'bold' | null {
    return this.attributes['font-weight'];
  }
  setFontWeight(fontWeight: 'normal' | 'bold' | null): PartName {
    this.attributes['font-weight'] = fontWeight;
    return this;
  }
  getJustify(): 'left' | 'center' | 'right' | null {
    return this.attributes['justify'];
  }
  setJustify(justify: 'left' | 'center' | 'right' | null): PartName {
    this.attributes['justify'] = justify;
    return this;
  }
  getPrintObject(): 'yes' | 'no' | null {
    return this.attributes['print-object'];
  }
  setPrintObject(printObject: 'yes' | 'no' | null): PartName {
    this.attributes['print-object'] = printObject;
    return this;
  }
  getRelativeX(): number | null {
    return this.attributes['relative-x'];
  }
  setRelativeX(relativeX: number | null): PartName {
    this.attributes['relative-x'] = relativeX;
    return this;
  }
  getRelativeY(): number | null {
    return this.attributes['relative-y'];
  }
  setRelativeY(relativeY: number | null): PartName {
    this.attributes['relative-y'] = relativeY;
    return this;
  }
  getText(): string {
    return this.contents[0];
  }
  setText(text: string): PartName {
    this.contents[0] = text;
    return this;
  }
}

export type PartNameDisplayAttributes = { 'print-object': 'yes' | 'no' | null };

export type PartNameDisplayContents = [Array<DisplayText | AccidentalText>];

export class PartNameDisplay
  implements XMLElement<'part-name-display', PartNameDisplayAttributes, PartNameDisplayContents>
{
  static readonly schema = {
    name: 'part-name-display',
    attributes: { 'print-object': { type: 'optional', value: { type: 'choices', choices: ['yes', 'no'] } } },
    contents: [
      {
        type: 'label',
        label: 'texts',
        value: { type: 'zeroOrMore', value: { type: 'choices', choices: [DisplayText, AccidentalText] } },
      },
    ],
  } as const;

  readonly schema = PartNameDisplay.schema;

  attributes: PartNameDisplayAttributes;
  contents: PartNameDisplayContents;

  constructor(opts?: { attributes?: Partial<PartNameDisplayAttributes>; contents?: PartNameDisplayContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, PartNameDisplay.schema);
    this.contents = opts?.contents ?? operations.zero(PartNameDisplay.schema.contents);
  }
  getPrintObject(): 'yes' | 'no' | null {
    return this.attributes['print-object'];
  }
  setPrintObject(printObject: 'yes' | 'no' | null): PartNameDisplay {
    this.attributes['print-object'] = printObject;
    return this;
  }
  getTexts(): Array<DisplayText | AccidentalText> {
    return this.contents[0];
  }
  setTexts(texts: Array<DisplayText | AccidentalText>): PartNameDisplay {
    this.contents[0] = texts;
    return this;
  }
}

export type PartAbbreviationAttributes = {
  color: string | null;
  'default-x': number | null;
  'default-y': number | null;
  'font-family': string | null;
  'font-size': 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null;
  'font-style': 'normal' | 'italic' | null;
  'font-weight': 'normal' | 'bold' | null;
  justify: 'left' | 'center' | 'right' | null;
  'print-object': 'yes' | 'no' | null;
  'relative-x': number | null;
  'relative-y': number | null;
};

export type PartAbbreviationContents = [string];

export class PartAbbreviation
  implements XMLElement<'part-abbreviation', PartAbbreviationAttributes, PartAbbreviationContents>
{
  static readonly schema = {
    name: 'part-abbreviation',
    attributes: {
      color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
      'default-x': {
        type: 'label',
        label: 'default-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'default-y': {
        type: 'label',
        label: 'default-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
      'font-size': {
        type: 'optional',
        value: {
          type: 'choices',
          choices: [
            { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
            { type: 'float', min: -Infinity, max: Infinity },
          ],
        },
      },
      'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
      'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
      justify: { type: 'optional', value: { type: 'choices', choices: ['left', 'center', 'right'] } },
      'print-object': { type: 'optional', value: { type: 'choices', choices: ['yes', 'no'] } },
      'relative-x': {
        type: 'label',
        label: 'relative-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'relative-y': {
        type: 'label',
        label: 'relative-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
    },
    contents: [{ type: 'required', value: { type: 'string' } }],
  } as const;

  readonly schema = PartAbbreviation.schema;

  attributes: PartAbbreviationAttributes;
  contents: PartAbbreviationContents;

  constructor(opts?: { attributes?: Partial<PartAbbreviationAttributes>; contents?: PartAbbreviationContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, PartAbbreviation.schema);
    this.contents = opts?.contents ?? operations.zero(PartAbbreviation.schema.contents);
  }
  getColor(): string | null {
    return this.attributes['color'];
  }
  setColor(color: string | null): PartAbbreviation {
    this.attributes['color'] = color;
    return this;
  }
  getDefaultX(): number | null {
    return this.attributes['default-x'];
  }
  setDefaultX(defaultX: number | null): PartAbbreviation {
    this.attributes['default-x'] = defaultX;
    return this;
  }
  getDefaultY(): number | null {
    return this.attributes['default-y'];
  }
  setDefaultY(defaultY: number | null): PartAbbreviation {
    this.attributes['default-y'] = defaultY;
    return this;
  }
  getFontFamily(): string | null {
    return this.attributes['font-family'];
  }
  setFontFamily(fontFamily: string | null): PartAbbreviation {
    this.attributes['font-family'] = fontFamily;
    return this;
  }
  getFontSize(): 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null {
    return this.attributes['font-size'];
  }
  setFontSize(
    fontSize: 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null
  ): PartAbbreviation {
    this.attributes['font-size'] = fontSize;
    return this;
  }
  getFontStyle(): 'normal' | 'italic' | null {
    return this.attributes['font-style'];
  }
  setFontStyle(fontStyle: 'normal' | 'italic' | null): PartAbbreviation {
    this.attributes['font-style'] = fontStyle;
    return this;
  }
  getFontWeight(): 'normal' | 'bold' | null {
    return this.attributes['font-weight'];
  }
  setFontWeight(fontWeight: 'normal' | 'bold' | null): PartAbbreviation {
    this.attributes['font-weight'] = fontWeight;
    return this;
  }
  getJustify(): 'left' | 'center' | 'right' | null {
    return this.attributes['justify'];
  }
  setJustify(justify: 'left' | 'center' | 'right' | null): PartAbbreviation {
    this.attributes['justify'] = justify;
    return this;
  }
  getPrintObject(): 'yes' | 'no' | null {
    return this.attributes['print-object'];
  }
  setPrintObject(printObject: 'yes' | 'no' | null): PartAbbreviation {
    this.attributes['print-object'] = printObject;
    return this;
  }
  getRelativeX(): number | null {
    return this.attributes['relative-x'];
  }
  setRelativeX(relativeX: number | null): PartAbbreviation {
    this.attributes['relative-x'] = relativeX;
    return this;
  }
  getRelativeY(): number | null {
    return this.attributes['relative-y'];
  }
  setRelativeY(relativeY: number | null): PartAbbreviation {
    this.attributes['relative-y'] = relativeY;
    return this;
  }
  getText(): string {
    return this.contents[0];
  }
  setText(text: string): PartAbbreviation {
    this.contents[0] = text;
    return this;
  }
}

export type PartAbbreviationDisplayAttributes = { 'print-object': 'yes' | 'no' | null };

export type PartAbbreviationDisplayContents = [Array<DisplayText | AccidentalText>];

export class PartAbbreviationDisplay
  implements
    XMLElement<'part-abbreviation-display', PartAbbreviationDisplayAttributes, PartAbbreviationDisplayContents>
{
  static readonly schema = {
    name: 'part-abbreviation-display',
    attributes: { 'print-object': { type: 'optional', value: { type: 'choices', choices: ['yes', 'no'] } } },
    contents: [
      {
        type: 'label',
        label: 'texts',
        value: { type: 'zeroOrMore', value: { type: 'choices', choices: [DisplayText, AccidentalText] } },
      },
    ],
  } as const;

  readonly schema = PartAbbreviationDisplay.schema;

  attributes: PartAbbreviationDisplayAttributes;
  contents: PartAbbreviationDisplayContents;

  constructor(opts?: {
    attributes?: Partial<PartAbbreviationDisplayAttributes>;
    contents?: PartAbbreviationDisplayContents;
  }) {
    this.attributes = operations.merge(opts?.attributes || {}, PartAbbreviationDisplay.schema);
    this.contents = opts?.contents ?? operations.zero(PartAbbreviationDisplay.schema.contents);
  }
  getPrintObject(): 'yes' | 'no' | null {
    return this.attributes['print-object'];
  }
  setPrintObject(printObject: 'yes' | 'no' | null): PartAbbreviationDisplay {
    this.attributes['print-object'] = printObject;
    return this;
  }
  getTexts(): Array<DisplayText | AccidentalText> {
    return this.contents[0];
  }
  setTexts(texts: Array<DisplayText | AccidentalText>): PartAbbreviationDisplay {
    this.contents[0] = texts;
    return this;
  }
}

export type GroupAttributes = Record<string, unknown>;

export type GroupContents = [string];

export class Group implements XMLElement<'group', GroupAttributes, GroupContents> {
  static readonly schema = {
    name: 'group',
    attributes: {},
    contents: [{ type: 'required', value: { type: 'string' } }],
  } as const;

  readonly schema = Group.schema;

  attributes: GroupAttributes;
  contents: GroupContents;

  constructor(opts?: { attributes?: Partial<GroupAttributes>; contents?: GroupContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Group.schema);
    this.contents = opts?.contents ?? operations.zero(Group.schema.contents);
  }

  getText(): string {
    return this.contents[0];
  }
  setText(text: string): Group {
    this.contents[0] = text;
    return this;
  }
}

export type InstrumentNameAttributes = Record<string, unknown>;

export type InstrumentNameContents = [string];

export class InstrumentName implements XMLElement<'instrument-name', InstrumentNameAttributes, InstrumentNameContents> {
  static readonly schema = {
    name: 'instrument-name',
    attributes: {},
    contents: [{ type: 'required', value: { type: 'string' } }],
  } as const;

  readonly schema = InstrumentName.schema;

  attributes: InstrumentNameAttributes;
  contents: InstrumentNameContents;

  constructor(opts?: { attributes?: Partial<InstrumentNameAttributes>; contents?: InstrumentNameContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, InstrumentName.schema);
    this.contents = opts?.contents ?? operations.zero(InstrumentName.schema.contents);
  }

  getText(): string {
    return this.contents[0];
  }
  setText(text: string): InstrumentName {
    this.contents[0] = text;
    return this;
  }
}

export type InstrumentAbbreviationAttributes = Record<string, unknown>;

export type InstrumentAbbreviationContents = [string];

export class InstrumentAbbreviation
  implements XMLElement<'instrument-abbreviation', InstrumentAbbreviationAttributes, InstrumentAbbreviationContents>
{
  static readonly schema = {
    name: 'instrument-abbreviation',
    attributes: {},
    contents: [{ type: 'required', value: { type: 'string' } }],
  } as const;

  readonly schema = InstrumentAbbreviation.schema;

  attributes: InstrumentAbbreviationAttributes;
  contents: InstrumentAbbreviationContents;

  constructor(opts?: {
    attributes?: Partial<InstrumentAbbreviationAttributes>;
    contents?: InstrumentAbbreviationContents;
  }) {
    this.attributes = operations.merge(opts?.attributes || {}, InstrumentAbbreviation.schema);
    this.contents = opts?.contents ?? operations.zero(InstrumentAbbreviation.schema.contents);
  }

  getText(): string {
    return this.contents[0];
  }
  setText(text: string): InstrumentAbbreviation {
    this.contents[0] = text;
    return this;
  }
}

export type InstrumentSoundAttributes = Record<string, unknown>;

export type InstrumentSoundContents = [string];

export class InstrumentSound
  implements XMLElement<'instrument-sound', InstrumentSoundAttributes, InstrumentSoundContents>
{
  static readonly schema = {
    name: 'instrument-sound',
    attributes: {},
    contents: [{ type: 'required', value: { type: 'string' } }],
  } as const;

  readonly schema = InstrumentSound.schema;

  attributes: InstrumentSoundAttributes;
  contents: InstrumentSoundContents;

  constructor(opts?: { attributes?: Partial<InstrumentSoundAttributes>; contents?: InstrumentSoundContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, InstrumentSound.schema);
    this.contents = opts?.contents ?? operations.zero(InstrumentSound.schema.contents);
  }

  getText(): string {
    return this.contents[0];
  }
  setText(text: string): InstrumentSound {
    this.contents[0] = text;
    return this;
  }
}

export type SoloAttributes = Record<string, unknown>;

export type SoloContents = [];

export class Solo implements XMLElement<'solo', SoloAttributes, SoloContents> {
  static readonly schema = { name: 'solo', attributes: {}, contents: [] } as const;

  readonly schema = Solo.schema;

  attributes: SoloAttributes;
  contents: SoloContents;

  constructor(opts?: { attributes?: Partial<SoloAttributes>; contents?: SoloContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Solo.schema);
    this.contents = opts?.contents ?? operations.zero(Solo.schema.contents);
  }
}

export type EnsembleAttributes = Record<string, unknown>;

export type EnsembleContents = ['' | number];

export class Ensemble implements XMLElement<'ensemble', EnsembleAttributes, EnsembleContents> {
  static readonly schema = {
    name: 'ensemble',
    attributes: {},
    contents: [
      {
        type: 'label',
        label: 'size',
        value: { type: 'required', value: { type: 'choices', choices: ['', { type: 'int', min: 1, max: Infinity }] } },
      },
    ],
  } as const;

  readonly schema = Ensemble.schema;

  attributes: EnsembleAttributes;
  contents: EnsembleContents;

  constructor(opts?: { attributes?: Partial<EnsembleAttributes>; contents?: EnsembleContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Ensemble.schema);
    this.contents = opts?.contents ?? operations.zero(Ensemble.schema.contents);
  }

  getSize(): '' | number {
    return this.contents[0];
  }
  setSize(size: '' | number): Ensemble {
    this.contents[0] = size;
    return this;
  }
}

export type VirtualLibraryAttributes = Record<string, unknown>;

export type VirtualLibraryContents = [string];

export class VirtualLibrary implements XMLElement<'virtual-library', VirtualLibraryAttributes, VirtualLibraryContents> {
  static readonly schema = {
    name: 'virtual-library',
    attributes: {},
    contents: [{ type: 'required', value: { type: 'string' } }],
  } as const;

  readonly schema = VirtualLibrary.schema;

  attributes: VirtualLibraryAttributes;
  contents: VirtualLibraryContents;

  constructor(opts?: { attributes?: Partial<VirtualLibraryAttributes>; contents?: VirtualLibraryContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, VirtualLibrary.schema);
    this.contents = opts?.contents ?? operations.zero(VirtualLibrary.schema.contents);
  }

  getText(): string {
    return this.contents[0];
  }
  setText(text: string): VirtualLibrary {
    this.contents[0] = text;
    return this;
  }
}

export type VirtualNameAttributes = Record<string, unknown>;

export type VirtualNameContents = [string];

export class VirtualName implements XMLElement<'virtual-name', VirtualNameAttributes, VirtualNameContents> {
  static readonly schema = {
    name: 'virtual-name',
    attributes: {},
    contents: [{ type: 'required', value: { type: 'string' } }],
  } as const;

  readonly schema = VirtualName.schema;

  attributes: VirtualNameAttributes;
  contents: VirtualNameContents;

  constructor(opts?: { attributes?: Partial<VirtualNameAttributes>; contents?: VirtualNameContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, VirtualName.schema);
    this.contents = opts?.contents ?? operations.zero(VirtualName.schema.contents);
  }

  getText(): string {
    return this.contents[0];
  }
  setText(text: string): VirtualName {
    this.contents[0] = text;
    return this;
  }
}

export type VirtualInstrumentAttributes = Record<string, unknown>;

export type VirtualInstrumentContents = [VirtualLibrary | null, VirtualName | null];

export class VirtualInstrument
  implements XMLElement<'virtual-instrument', VirtualInstrumentAttributes, VirtualInstrumentContents>
{
  static readonly schema = {
    name: 'virtual-instrument',
    attributes: {},
    contents: [
      { type: 'optional', value: VirtualLibrary },
      { type: 'optional', value: VirtualName },
    ],
  } as const;

  readonly schema = VirtualInstrument.schema;

  attributes: VirtualInstrumentAttributes;
  contents: VirtualInstrumentContents;

  constructor(opts?: { attributes?: Partial<VirtualInstrumentAttributes>; contents?: VirtualInstrumentContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, VirtualInstrument.schema);
    this.contents = opts?.contents ?? operations.zero(VirtualInstrument.schema.contents);
  }

  getVirtualLibrary(): VirtualLibrary | null {
    return this.contents[0];
  }
  setVirtualLibrary(virtualLibrary: VirtualLibrary | null): VirtualInstrument {
    this.contents[0] = virtualLibrary;
    return this;
  }
  getVirtualName(): VirtualName | null {
    return this.contents[1];
  }
  setVirtualName(virtualName: VirtualName | null): VirtualInstrument {
    this.contents[1] = virtualName;
    return this;
  }
}

export type ScoreInstrumentAttributes = { id: string };

export type ScoreInstrumentContents = [
  InstrumentName,
  InstrumentAbbreviation | null,
  InstrumentSound | null,
  Array<Solo | Ensemble>,
  VirtualInstrument | null
];

export class ScoreInstrument
  implements XMLElement<'score-instrument', ScoreInstrumentAttributes, ScoreInstrumentContents>
{
  static readonly schema = {
    name: 'score-instrument',
    attributes: { id: { type: 'required', value: { type: 'regex', pattern: /[A-Za-z_][A-Za-z0-9.-_]*/, zero: '_' } } },
    contents: [
      { type: 'required', value: InstrumentName },
      { type: 'optional', value: InstrumentAbbreviation },
      { type: 'optional', value: InstrumentSound },
      {
        type: 'label',
        label: 'instrument-types',
        value: { type: 'zeroOrMore', value: { type: 'choices', choices: [Solo, Ensemble] } },
      },
      { type: 'optional', value: VirtualInstrument },
    ],
  } as const;

  readonly schema = ScoreInstrument.schema;

  attributes: ScoreInstrumentAttributes;
  contents: ScoreInstrumentContents;

  constructor(opts?: { attributes?: Partial<ScoreInstrumentAttributes>; contents?: ScoreInstrumentContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, ScoreInstrument.schema);
    this.contents = opts?.contents ?? operations.zero(ScoreInstrument.schema.contents);
  }
  getId(): string {
    return this.attributes['id'];
  }
  setId(id: string): ScoreInstrument {
    this.attributes['id'] = id;
    return this;
  }
  getInstrumentName(): InstrumentName {
    return this.contents[0];
  }
  setInstrumentName(instrumentName: InstrumentName): ScoreInstrument {
    this.contents[0] = instrumentName;
    return this;
  }
  getInstrumentAbbreviation(): InstrumentAbbreviation | null {
    return this.contents[1];
  }
  setInstrumentAbbreviation(instrumentAbbreviation: InstrumentAbbreviation | null): ScoreInstrument {
    this.contents[1] = instrumentAbbreviation;
    return this;
  }
  getInstrumentSound(): InstrumentSound | null {
    return this.contents[2];
  }
  setInstrumentSound(instrumentSound: InstrumentSound | null): ScoreInstrument {
    this.contents[2] = instrumentSound;
    return this;
  }
  getInstrumentTypes(): Array<Solo | Ensemble> {
    return this.contents[3];
  }
  setInstrumentTypes(instrumentTypes: Array<Solo | Ensemble>): ScoreInstrument {
    this.contents[3] = instrumentTypes;
    return this;
  }
  getVirtualInstrument(): VirtualInstrument | null {
    return this.contents[4];
  }
  setVirtualInstrument(virtualInstrument: VirtualInstrument | null): ScoreInstrument {
    this.contents[4] = virtualInstrument;
    return this;
  }
}

export type PlayerAttributes = { id: string };

export type PlayerContents = [];

export class Player implements XMLElement<'player', PlayerAttributes, PlayerContents> {
  static readonly schema = {
    name: 'player',
    attributes: { id: { type: 'required', value: { type: 'regex', pattern: /[A-Za-z_][A-Za-z0-9.-_]*/, zero: '_' } } },
    contents: [],
  } as const;

  readonly schema = Player.schema;

  attributes: PlayerAttributes;
  contents: PlayerContents;

  constructor(opts?: { attributes?: Partial<PlayerAttributes>; contents?: PlayerContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Player.schema);
    this.contents = opts?.contents ?? operations.zero(Player.schema.contents);
  }
  getId(): string {
    return this.attributes['id'];
  }
  setId(id: string): Player {
    this.attributes['id'] = id;
    return this;
  }
}

export type MidiDeviceAttributes = { id: string | null; port: number | null };

export type MidiDeviceContents = [string];

export class MidiDevice implements XMLElement<'midi-device', MidiDeviceAttributes, MidiDeviceContents> {
  static readonly schema = {
    name: 'midi-device',
    attributes: {
      id: { type: 'optional', value: { type: 'regex', pattern: /[A-Za-z_][A-Za-z0-9.-_]*/, zero: '_' } },
      port: { type: 'optional', value: { type: 'label', label: 'midi16', value: { type: 'int', min: 1, max: 16 } } },
    },
    contents: [{ type: 'required', value: { type: 'string' } }],
  } as const;

  readonly schema = MidiDevice.schema;

  attributes: MidiDeviceAttributes;
  contents: MidiDeviceContents;

  constructor(opts?: { attributes?: Partial<MidiDeviceAttributes>; contents?: MidiDeviceContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, MidiDevice.schema);
    this.contents = opts?.contents ?? operations.zero(MidiDevice.schema.contents);
  }
  getId(): string | null {
    return this.attributes['id'];
  }
  setId(id: string | null): MidiDevice {
    this.attributes['id'] = id;
    return this;
  }
  getMidi16(): number | null {
    return this.attributes['port'];
  }
  setMidi16(midi16: number | null): MidiDevice {
    this.attributes['port'] = midi16;
    return this;
  }
  getText(): string {
    return this.contents[0];
  }
  setText(text: string): MidiDevice {
    this.contents[0] = text;
    return this;
  }
}

export type MidiChannelAttributes = Record<string, unknown>;

export type MidiChannelContents = [number];

export class MidiChannel implements XMLElement<'midi-channel', MidiChannelAttributes, MidiChannelContents> {
  static readonly schema = {
    name: 'midi-channel',
    attributes: {},
    contents: [
      { type: 'required', value: { type: 'label', label: 'midi16', value: { type: 'int', min: 1, max: 16 } } },
    ],
  } as const;

  readonly schema = MidiChannel.schema;

  attributes: MidiChannelAttributes;
  contents: MidiChannelContents;

  constructor(opts?: { attributes?: Partial<MidiChannelAttributes>; contents?: MidiChannelContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, MidiChannel.schema);
    this.contents = opts?.contents ?? operations.zero(MidiChannel.schema.contents);
  }

  getMidi16(): number {
    return this.contents[0];
  }
  setMidi16(midi16: number): MidiChannel {
    this.contents[0] = midi16;
    return this;
  }
}

export type MidiNameAttributes = Record<string, unknown>;

export type MidiNameContents = [string];

export class MidiName implements XMLElement<'midi-name', MidiNameAttributes, MidiNameContents> {
  static readonly schema = {
    name: 'midi-name',
    attributes: {},
    contents: [{ type: 'required', value: { type: 'string' } }],
  } as const;

  readonly schema = MidiName.schema;

  attributes: MidiNameAttributes;
  contents: MidiNameContents;

  constructor(opts?: { attributes?: Partial<MidiNameAttributes>; contents?: MidiNameContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, MidiName.schema);
    this.contents = opts?.contents ?? operations.zero(MidiName.schema.contents);
  }

  getText(): string {
    return this.contents[0];
  }
  setText(text: string): MidiName {
    this.contents[0] = text;
    return this;
  }
}

export type MidiBankAttributes = Record<string, unknown>;

export type MidiBankContents = [number];

export class MidiBank implements XMLElement<'midi-bank', MidiBankAttributes, MidiBankContents> {
  static readonly schema = {
    name: 'midi-bank',
    attributes: {},
    contents: [
      { type: 'required', value: { type: 'label', label: 'midi16384', value: { type: 'int', min: 1, max: 16384 } } },
    ],
  } as const;

  readonly schema = MidiBank.schema;

  attributes: MidiBankAttributes;
  contents: MidiBankContents;

  constructor(opts?: { attributes?: Partial<MidiBankAttributes>; contents?: MidiBankContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, MidiBank.schema);
    this.contents = opts?.contents ?? operations.zero(MidiBank.schema.contents);
  }

  getMidi16384(): number {
    return this.contents[0];
  }
  setMidi16384(midi16384: number): MidiBank {
    this.contents[0] = midi16384;
    return this;
  }
}

export type MidiProgramAttributes = Record<string, unknown>;

export type MidiProgramContents = [number];

export class MidiProgram implements XMLElement<'midi-program', MidiProgramAttributes, MidiProgramContents> {
  static readonly schema = {
    name: 'midi-program',
    attributes: {},
    contents: [
      { type: 'required', value: { type: 'label', label: 'midi128', value: { type: 'int', min: 1, max: 128 } } },
    ],
  } as const;

  readonly schema = MidiProgram.schema;

  attributes: MidiProgramAttributes;
  contents: MidiProgramContents;

  constructor(opts?: { attributes?: Partial<MidiProgramAttributes>; contents?: MidiProgramContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, MidiProgram.schema);
    this.contents = opts?.contents ?? operations.zero(MidiProgram.schema.contents);
  }

  getMidi128(): number {
    return this.contents[0];
  }
  setMidi128(midi128: number): MidiProgram {
    this.contents[0] = midi128;
    return this;
  }
}

export type MidiUnpitchedAttributes = Record<string, unknown>;

export type MidiUnpitchedContents = [number];

export class MidiUnpitched implements XMLElement<'midi-unpitched', MidiUnpitchedAttributes, MidiUnpitchedContents> {
  static readonly schema = {
    name: 'midi-unpitched',
    attributes: {},
    contents: [
      { type: 'required', value: { type: 'label', label: 'midi128', value: { type: 'int', min: 1, max: 128 } } },
    ],
  } as const;

  readonly schema = MidiUnpitched.schema;

  attributes: MidiUnpitchedAttributes;
  contents: MidiUnpitchedContents;

  constructor(opts?: { attributes?: Partial<MidiUnpitchedAttributes>; contents?: MidiUnpitchedContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, MidiUnpitched.schema);
    this.contents = opts?.contents ?? operations.zero(MidiUnpitched.schema.contents);
  }

  getMidi128(): number {
    return this.contents[0];
  }
  setMidi128(midi128: number): MidiUnpitched {
    this.contents[0] = midi128;
    return this;
  }
}

export type VolumeAttributes = Record<string, unknown>;

export type VolumeContents = [number];

export class Volume implements XMLElement<'volume', VolumeAttributes, VolumeContents> {
  static readonly schema = {
    name: 'volume',
    attributes: {},
    contents: [
      { type: 'label', label: 'volume', value: { type: 'required', value: { type: 'float', min: 0, max: 100 } } },
    ],
  } as const;

  readonly schema = Volume.schema;

  attributes: VolumeAttributes;
  contents: VolumeContents;

  constructor(opts?: { attributes?: Partial<VolumeAttributes>; contents?: VolumeContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Volume.schema);
    this.contents = opts?.contents ?? operations.zero(Volume.schema.contents);
  }

  getVolume(): number {
    return this.contents[0];
  }
  setVolume(volume: number): Volume {
    this.contents[0] = volume;
    return this;
  }
}

export type PanAttributes = Record<string, unknown>;

export type PanContents = [number];

export class Pan implements XMLElement<'pan', PanAttributes, PanContents> {
  static readonly schema = {
    name: 'pan',
    attributes: {},
    contents: [
      { type: 'label', label: 'pan-value', value: { type: 'required', value: { type: 'float', min: -180, max: 180 } } },
    ],
  } as const;

  readonly schema = Pan.schema;

  attributes: PanAttributes;
  contents: PanContents;

  constructor(opts?: { attributes?: Partial<PanAttributes>; contents?: PanContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Pan.schema);
    this.contents = opts?.contents ?? operations.zero(Pan.schema.contents);
  }

  getPanValue(): number {
    return this.contents[0];
  }
  setPanValue(panValue: number): Pan {
    this.contents[0] = panValue;
    return this;
  }
}

export type ElevationAttributes = Record<string, unknown>;

export type ElevationContents = [number];

export class Elevation implements XMLElement<'elevation', ElevationAttributes, ElevationContents> {
  static readonly schema = {
    name: 'elevation',
    attributes: {},
    contents: [
      { type: 'label', label: 'elevation', value: { type: 'required', value: { type: 'float', min: -180, max: 180 } } },
    ],
  } as const;

  readonly schema = Elevation.schema;

  attributes: ElevationAttributes;
  contents: ElevationContents;

  constructor(opts?: { attributes?: Partial<ElevationAttributes>; contents?: ElevationContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Elevation.schema);
    this.contents = opts?.contents ?? operations.zero(Elevation.schema.contents);
  }

  getElevation(): number {
    return this.contents[0];
  }
  setElevation(elevation: number): Elevation {
    this.contents[0] = elevation;
    return this;
  }
}

export type MidiInstrumentAttributes = { id: string };

export type MidiInstrumentContents = [
  MidiChannel | null,
  MidiName | null,
  MidiBank | null,
  MidiProgram | null,
  MidiUnpitched | null,
  Volume | null,
  Pan | null,
  Elevation | null
];

export class MidiInstrument implements XMLElement<'midi-instrument', MidiInstrumentAttributes, MidiInstrumentContents> {
  static readonly schema = {
    name: 'midi-instrument',
    attributes: { id: { type: 'required', value: { type: 'regex', pattern: /[A-Za-z_][A-Za-z0-9.-_]*/, zero: '_' } } },
    contents: [
      { type: 'optional', value: MidiChannel },
      { type: 'optional', value: MidiName },
      { type: 'optional', value: MidiBank },
      { type: 'optional', value: MidiProgram },
      { type: 'optional', value: MidiUnpitched },
      { type: 'optional', value: Volume },
      { type: 'optional', value: Pan },
      { type: 'optional', value: Elevation },
    ],
  } as const;

  readonly schema = MidiInstrument.schema;

  attributes: MidiInstrumentAttributes;
  contents: MidiInstrumentContents;

  constructor(opts?: { attributes?: Partial<MidiInstrumentAttributes>; contents?: MidiInstrumentContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, MidiInstrument.schema);
    this.contents = opts?.contents ?? operations.zero(MidiInstrument.schema.contents);
  }
  getId(): string {
    return this.attributes['id'];
  }
  setId(id: string): MidiInstrument {
    this.attributes['id'] = id;
    return this;
  }
  getMidiChannel(): MidiChannel | null {
    return this.contents[0];
  }
  setMidiChannel(midiChannel: MidiChannel | null): MidiInstrument {
    this.contents[0] = midiChannel;
    return this;
  }
  getMidiName(): MidiName | null {
    return this.contents[1];
  }
  setMidiName(midiName: MidiName | null): MidiInstrument {
    this.contents[1] = midiName;
    return this;
  }
  getMidiBank(): MidiBank | null {
    return this.contents[2];
  }
  setMidiBank(midiBank: MidiBank | null): MidiInstrument {
    this.contents[2] = midiBank;
    return this;
  }
  getMidiProgram(): MidiProgram | null {
    return this.contents[3];
  }
  setMidiProgram(midiProgram: MidiProgram | null): MidiInstrument {
    this.contents[3] = midiProgram;
    return this;
  }
  getMidiUnpitched(): MidiUnpitched | null {
    return this.contents[4];
  }
  setMidiUnpitched(midiUnpitched: MidiUnpitched | null): MidiInstrument {
    this.contents[4] = midiUnpitched;
    return this;
  }
  getVolume(): Volume | null {
    return this.contents[5];
  }
  setVolume(volume: Volume | null): MidiInstrument {
    this.contents[5] = volume;
    return this;
  }
  getPan(): Pan | null {
    return this.contents[6];
  }
  setPan(pan: Pan | null): MidiInstrument {
    this.contents[6] = pan;
    return this;
  }
  getElevation(): Elevation | null {
    return this.contents[7];
  }
  setElevation(elevation: Elevation | null): MidiInstrument {
    this.contents[7] = elevation;
    return this;
  }
}

export type ScorePartAttributes = { id: string };

export type ScorePartContents = [
  Identification | null,
  Array<PartLink>,
  PartName,
  PartNameDisplay | null,
  PartAbbreviation | null,
  PartAbbreviationDisplay | null,
  Array<Group>,
  Array<ScoreInstrument>,
  Array<Player>,
  Array<MidiDevice | MidiInstrument>
];

export class ScorePart implements XMLElement<'score-part', ScorePartAttributes, ScorePartContents> {
  static readonly schema = {
    name: 'score-part',
    attributes: { id: { type: 'regex', pattern: /[A-Za-z_][A-Za-z0-9.-_]*/, zero: '_' } },
    contents: [
      { type: 'optional', value: Identification },
      { type: 'label', label: 'part-links', value: { type: 'zeroOrMore', value: PartLink } },
      { type: 'required', value: PartName },
      { type: 'optional', value: PartNameDisplay },
      { type: 'optional', value: PartAbbreviation },
      { type: 'optional', value: PartAbbreviationDisplay },
      { type: 'label', label: 'groups', value: { type: 'zeroOrMore', value: Group } },
      { type: 'label', label: 'score-instruments', value: { type: 'zeroOrMore', value: ScoreInstrument } },
      { type: 'label', label: 'players', value: { type: 'zeroOrMore', value: Player } },
      {
        type: 'label',
        label: 'midis',
        value: { type: 'zeroOrMore', value: { type: 'choices', choices: [MidiDevice, MidiInstrument] } },
      },
    ],
  } as const;

  readonly schema = ScorePart.schema;

  attributes: ScorePartAttributes;
  contents: ScorePartContents;

  constructor(opts?: { attributes?: Partial<ScorePartAttributes>; contents?: ScorePartContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, ScorePart.schema);
    this.contents = opts?.contents ?? operations.zero(ScorePart.schema.contents);
  }
  getId(): string {
    return this.attributes['id'];
  }
  setId(id: string): ScorePart {
    this.attributes['id'] = id;
    return this;
  }
  getIdentification(): Identification | null {
    return this.contents[0];
  }
  setIdentification(identification: Identification | null): ScorePart {
    this.contents[0] = identification;
    return this;
  }
  getPartLinks(): Array<PartLink> {
    return this.contents[1];
  }
  setPartLinks(partLinks: Array<PartLink>): ScorePart {
    this.contents[1] = partLinks;
    return this;
  }
  getPartName(): PartName {
    return this.contents[2];
  }
  setPartName(partName: PartName): ScorePart {
    this.contents[2] = partName;
    return this;
  }
  getPartNameDisplay(): PartNameDisplay | null {
    return this.contents[3];
  }
  setPartNameDisplay(partNameDisplay: PartNameDisplay | null): ScorePart {
    this.contents[3] = partNameDisplay;
    return this;
  }
  getPartAbbreviation(): PartAbbreviation | null {
    return this.contents[4];
  }
  setPartAbbreviation(partAbbreviation: PartAbbreviation | null): ScorePart {
    this.contents[4] = partAbbreviation;
    return this;
  }
  getPartAbbreviationDisplay(): PartAbbreviationDisplay | null {
    return this.contents[5];
  }
  setPartAbbreviationDisplay(partAbbreviationDisplay: PartAbbreviationDisplay | null): ScorePart {
    this.contents[5] = partAbbreviationDisplay;
    return this;
  }
  getGroups(): Array<Group> {
    return this.contents[6];
  }
  setGroups(groups: Array<Group>): ScorePart {
    this.contents[6] = groups;
    return this;
  }
  getScoreInstruments(): Array<ScoreInstrument> {
    return this.contents[7];
  }
  setScoreInstruments(scoreInstruments: Array<ScoreInstrument>): ScorePart {
    this.contents[7] = scoreInstruments;
    return this;
  }
  getPlayers(): Array<Player> {
    return this.contents[8];
  }
  setPlayers(players: Array<Player>): ScorePart {
    this.contents[8] = players;
    return this;
  }
  getMidis(): Array<MidiDevice | MidiInstrument> {
    return this.contents[9];
  }
  setMidis(midis: Array<MidiDevice | MidiInstrument>): ScorePart {
    this.contents[9] = midis;
    return this;
  }
}

export type PartListAttributes = Record<string, unknown>;

export type PartListContents = [Array<PartGroup>, ScorePart, Array<PartGroup | ScorePart>];

export class PartList implements XMLElement<'part-list', PartListAttributes, PartListContents> {
  static readonly schema = {
    name: 'part-list',
    attributes: {},
    contents: [
      { type: 'label', label: 'part-groups', value: { type: 'zeroOrMore', value: PartGroup } },
      { type: 'required', value: ScorePart },
      {
        type: 'label',
        label: 'parts',
        value: { type: 'zeroOrMore', value: { type: 'choices', choices: [PartGroup, ScorePart] } },
      },
    ],
  } as const;

  readonly schema = PartList.schema;

  attributes: PartListAttributes;
  contents: PartListContents;

  constructor(opts?: { attributes?: Partial<PartListAttributes>; contents?: PartListContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, PartList.schema);
    this.contents = opts?.contents ?? operations.zero(PartList.schema.contents);
  }

  getPartGroups(): Array<PartGroup> {
    return this.contents[0];
  }
  setPartGroups(partGroups: Array<PartGroup>): PartList {
    this.contents[0] = partGroups;
    return this;
  }
  getScorePart(): ScorePart {
    return this.contents[1];
  }
  setScorePart(scorePart: ScorePart): PartList {
    this.contents[1] = scorePart;
    return this;
  }
  getParts(): Array<PartGroup | ScorePart> {
    return this.contents[2];
  }
  setParts(parts: Array<PartGroup | ScorePart>): PartList {
    this.contents[2] = parts;
    return this;
  }
}

export type ChordAttributes = Record<string, unknown>;

export type ChordContents = [];

export class Chord implements XMLElement<'chord', ChordAttributes, ChordContents> {
  static readonly schema = { name: 'chord', attributes: {}, contents: [] } as const;

  readonly schema = Chord.schema;

  attributes: ChordAttributes;
  contents: ChordContents;

  constructor(opts?: { attributes?: Partial<ChordAttributes>; contents?: ChordContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Chord.schema);
    this.contents = opts?.contents ?? operations.zero(Chord.schema.contents);
  }
}

export type StepAttributes = Record<string, unknown>;

export type StepContents = ['A' | 'B' | 'C' | 'D' | 'E' | 'F' | 'G'];

export class Step implements XMLElement<'step', StepAttributes, StepContents> {
  static readonly schema = {
    name: 'step',
    attributes: {},
    contents: [
      {
        type: 'required',
        value: {
          type: 'label',
          label: 'step',
          value: { type: 'choices', choices: ['A', 'B', 'C', 'D', 'E', 'F', 'G'] },
        },
      },
    ],
  } as const;

  readonly schema = Step.schema;

  attributes: StepAttributes;
  contents: StepContents;

  constructor(opts?: { attributes?: Partial<StepAttributes>; contents?: StepContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Step.schema);
    this.contents = opts?.contents ?? operations.zero(Step.schema.contents);
  }

  getStep(): 'A' | 'B' | 'C' | 'D' | 'E' | 'F' | 'G' {
    return this.contents[0];
  }
  setStep(step: 'A' | 'B' | 'C' | 'D' | 'E' | 'F' | 'G'): Step {
    this.contents[0] = step;
    return this;
  }
}

export type AlterAttributes = Record<string, unknown>;

export type AlterContents = [number];

export class Alter implements XMLElement<'alter', AlterAttributes, AlterContents> {
  static readonly schema = {
    name: 'alter',
    attributes: {},
    contents: [
      {
        type: 'required',
        value: { type: 'label', label: 'semitones', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
    ],
  } as const;

  readonly schema = Alter.schema;

  attributes: AlterAttributes;
  contents: AlterContents;

  constructor(opts?: { attributes?: Partial<AlterAttributes>; contents?: AlterContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Alter.schema);
    this.contents = opts?.contents ?? operations.zero(Alter.schema.contents);
  }

  getSemitones(): number {
    return this.contents[0];
  }
  setSemitones(semitones: number): Alter {
    this.contents[0] = semitones;
    return this;
  }
}

export type OctaveAttributes = Record<string, unknown>;

export type OctaveContents = [number];

export class Octave implements XMLElement<'octave', OctaveAttributes, OctaveContents> {
  static readonly schema = {
    name: 'octave',
    attributes: {},
    contents: [{ type: 'required', value: { type: 'label', label: 'octave', value: { type: 'int', min: 0, max: 9 } } }],
  } as const;

  readonly schema = Octave.schema;

  attributes: OctaveAttributes;
  contents: OctaveContents;

  constructor(opts?: { attributes?: Partial<OctaveAttributes>; contents?: OctaveContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Octave.schema);
    this.contents = opts?.contents ?? operations.zero(Octave.schema.contents);
  }

  getOctave(): number {
    return this.contents[0];
  }
  setOctave(octave: number): Octave {
    this.contents[0] = octave;
    return this;
  }
}

export type PitchAttributes = Record<string, unknown>;

export type PitchContents = [Step, Alter | null, Octave];

export class Pitch implements XMLElement<'pitch', PitchAttributes, PitchContents> {
  static readonly schema = {
    name: 'pitch',
    attributes: {},
    contents: [
      { type: 'required', value: Step },
      { type: 'optional', value: Alter },
      { type: 'required', value: Octave },
    ],
  } as const;

  readonly schema = Pitch.schema;

  attributes: PitchAttributes;
  contents: PitchContents;

  constructor(opts?: { attributes?: Partial<PitchAttributes>; contents?: PitchContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Pitch.schema);
    this.contents = opts?.contents ?? operations.zero(Pitch.schema.contents);
  }

  getStep(): Step {
    return this.contents[0];
  }
  setStep(step: Step): Pitch {
    this.contents[0] = step;
    return this;
  }
  getAlter(): Alter | null {
    return this.contents[1];
  }
  setAlter(alter: Alter | null): Pitch {
    this.contents[1] = alter;
    return this;
  }
  getOctave(): Octave {
    return this.contents[2];
  }
  setOctave(octave: Octave): Pitch {
    this.contents[2] = octave;
    return this;
  }
}

export type DisplayStepAttributes = Record<string, unknown>;

export type DisplayStepContents = ['A' | 'B' | 'C' | 'D' | 'E' | 'F' | 'G'];

export class DisplayStep implements XMLElement<'display-step', DisplayStepAttributes, DisplayStepContents> {
  static readonly schema = {
    name: 'display-step',
    attributes: {},
    contents: [
      {
        type: 'required',
        value: {
          type: 'label',
          label: 'step',
          value: { type: 'choices', choices: ['A', 'B', 'C', 'D', 'E', 'F', 'G'] },
        },
      },
    ],
  } as const;

  readonly schema = DisplayStep.schema;

  attributes: DisplayStepAttributes;
  contents: DisplayStepContents;

  constructor(opts?: { attributes?: Partial<DisplayStepAttributes>; contents?: DisplayStepContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, DisplayStep.schema);
    this.contents = opts?.contents ?? operations.zero(DisplayStep.schema.contents);
  }

  getStep(): 'A' | 'B' | 'C' | 'D' | 'E' | 'F' | 'G' {
    return this.contents[0];
  }
  setStep(step: 'A' | 'B' | 'C' | 'D' | 'E' | 'F' | 'G'): DisplayStep {
    this.contents[0] = step;
    return this;
  }
}

export type DisplayOctaveAttributes = Record<string, unknown>;

export type DisplayOctaveContents = [number];

export class DisplayOctave implements XMLElement<'display-octave', DisplayOctaveAttributes, DisplayOctaveContents> {
  static readonly schema = {
    name: 'display-octave',
    attributes: {},
    contents: [{ type: 'required', value: { type: 'label', label: 'octave', value: { type: 'int', min: 0, max: 9 } } }],
  } as const;

  readonly schema = DisplayOctave.schema;

  attributes: DisplayOctaveAttributes;
  contents: DisplayOctaveContents;

  constructor(opts?: { attributes?: Partial<DisplayOctaveAttributes>; contents?: DisplayOctaveContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, DisplayOctave.schema);
    this.contents = opts?.contents ?? operations.zero(DisplayOctave.schema.contents);
  }

  getOctave(): number {
    return this.contents[0];
  }
  setOctave(octave: number): DisplayOctave {
    this.contents[0] = octave;
    return this;
  }
}

export type UnpitchedAttributes = Record<string, unknown>;

export type UnpitchedContents = [DisplayStep, DisplayOctave];

export class Unpitched implements XMLElement<'unpitched', UnpitchedAttributes, UnpitchedContents> {
  static readonly schema = {
    name: 'unpitched',
    attributes: {},
    contents: [
      { type: 'required', value: DisplayStep },
      { type: 'required', value: DisplayOctave },
    ],
  } as const;

  readonly schema = Unpitched.schema;

  attributes: UnpitchedAttributes;
  contents: UnpitchedContents;

  constructor(opts?: { attributes?: Partial<UnpitchedAttributes>; contents?: UnpitchedContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Unpitched.schema);
    this.contents = opts?.contents ?? operations.zero(Unpitched.schema.contents);
  }

  getDisplayStep(): DisplayStep {
    return this.contents[0];
  }
  setDisplayStep(displayStep: DisplayStep): Unpitched {
    this.contents[0] = displayStep;
    return this;
  }
  getDisplayOctave(): DisplayOctave {
    return this.contents[1];
  }
  setDisplayOctave(displayOctave: DisplayOctave): Unpitched {
    this.contents[1] = displayOctave;
    return this;
  }
}

export type RestAttributes = { measure: 'yes' | 'no' | null };

export type RestContents = [[DisplayStep, DisplayOctave] | null];

export class Rest implements XMLElement<'rest', RestAttributes, RestContents> {
  static readonly schema = {
    name: 'rest',
    attributes: { measure: { type: 'optional', value: { type: 'choices', choices: ['yes', 'no'] } } },
    contents: [
      {
        type: 'optional',
        value: {
          type: 'label',
          label: 'rest-value',
          value: [
            { type: 'required', value: DisplayStep },
            { type: 'required', value: DisplayOctave },
          ],
        },
      },
    ],
  } as const;

  readonly schema = Rest.schema;

  attributes: RestAttributes;
  contents: RestContents;

  constructor(opts?: { attributes?: Partial<RestAttributes>; contents?: RestContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Rest.schema);
    this.contents = opts?.contents ?? operations.zero(Rest.schema.contents);
  }
  getMeasure(): 'yes' | 'no' | null {
    return this.attributes['measure'];
  }
  setMeasure(measure: 'yes' | 'no' | null): Rest {
    this.attributes['measure'] = measure;
    return this;
  }
  getRestValue(): [DisplayStep, DisplayOctave] | null {
    return this.contents[0];
  }
  setRestValue(restValue: [DisplayStep, DisplayOctave] | null): Rest {
    this.contents[0] = restValue;
    return this;
  }
}

export type DurationAttributes = Record<string, unknown>;

export type DurationContents = [number];

export class Duration implements XMLElement<'duration', DurationAttributes, DurationContents> {
  static readonly schema = {
    name: 'duration',
    attributes: {},
    contents: [
      {
        type: 'required',
        value: { type: 'label', label: 'positive-divisions', value: { type: 'float', min: 1, max: Infinity } },
      },
    ],
  } as const;

  readonly schema = Duration.schema;

  attributes: DurationAttributes;
  contents: DurationContents;

  constructor(opts?: { attributes?: Partial<DurationAttributes>; contents?: DurationContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Duration.schema);
    this.contents = opts?.contents ?? operations.zero(Duration.schema.contents);
  }

  getPositiveDivisions(): number {
    return this.contents[0];
  }
  setPositiveDivisions(positiveDivisions: number): Duration {
    this.contents[0] = positiveDivisions;
    return this;
  }
}

export type TieAttributes = { type: 'start' | 'stop'; 'time-only': string | null };

export type TieContents = [];

export class Tie implements XMLElement<'tie', TieAttributes, TieContents> {
  static readonly schema = {
    name: 'tie',
    attributes: {
      type: { type: 'required', value: { type: 'choices', choices: ['start', 'stop'] } },
      'time-only': { type: 'optional', value: { type: 'regex', pattern: /[1-9][0-9]*(, ?[1-9][0-9]*)*/, zero: '1' } },
    },
    contents: [],
  } as const;

  readonly schema = Tie.schema;

  attributes: TieAttributes;
  contents: TieContents;

  constructor(opts?: { attributes?: Partial<TieAttributes>; contents?: TieContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Tie.schema);
    this.contents = opts?.contents ?? operations.zero(Tie.schema.contents);
  }
  getType(): 'start' | 'stop' {
    return this.attributes['type'];
  }
  setType(type: 'start' | 'stop'): Tie {
    this.attributes['type'] = type;
    return this;
  }
  getTimeOnly(): string | null {
    return this.attributes['time-only'];
  }
  setTimeOnly(timeOnly: string | null): Tie {
    this.attributes['time-only'] = timeOnly;
    return this;
  }
}

export type CueAttributes = Record<string, unknown>;

export type CueContents = [];

export class Cue implements XMLElement<'cue', CueAttributes, CueContents> {
  static readonly schema = { name: 'cue', attributes: {}, contents: [] } as const;

  readonly schema = Cue.schema;

  attributes: CueAttributes;
  contents: CueContents;

  constructor(opts?: { attributes?: Partial<CueAttributes>; contents?: CueContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Cue.schema);
    this.contents = opts?.contents ?? operations.zero(Cue.schema.contents);
  }
}

export type GraceAttributes = {
  'make-time': number | null;
  slash: 'yes' | 'no' | null;
  'steal-time-following': number | null;
  'steal-time-previous': number | null;
};

export type GraceContents = [];

export class Grace implements XMLElement<'grace', GraceAttributes, GraceContents> {
  static readonly schema = {
    name: 'grace',
    attributes: {
      'make-time': { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      slash: { type: 'optional', value: { type: 'choices', choices: ['yes', 'no'] } },
      'steal-time-following': { type: 'optional', value: { type: 'float', min: 0, max: 100 } },
      'steal-time-previous': { type: 'optional', value: { type: 'float', min: 0, max: 100 } },
    },
    contents: [],
  } as const;

  readonly schema = Grace.schema;

  attributes: GraceAttributes;
  contents: GraceContents;

  constructor(opts?: { attributes?: Partial<GraceAttributes>; contents?: GraceContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Grace.schema);
    this.contents = opts?.contents ?? operations.zero(Grace.schema.contents);
  }
  getMakeTime(): number | null {
    return this.attributes['make-time'];
  }
  setMakeTime(makeTime: number | null): Grace {
    this.attributes['make-time'] = makeTime;
    return this;
  }
  getSlash(): 'yes' | 'no' | null {
    return this.attributes['slash'];
  }
  setSlash(slash: 'yes' | 'no' | null): Grace {
    this.attributes['slash'] = slash;
    return this;
  }
  getStealTimeFollowing(): number | null {
    return this.attributes['steal-time-following'];
  }
  setStealTimeFollowing(stealTimeFollowing: number | null): Grace {
    this.attributes['steal-time-following'] = stealTimeFollowing;
    return this;
  }
  getStealTimePrevious(): number | null {
    return this.attributes['steal-time-previous'];
  }
  setStealTimePrevious(stealTimePrevious: number | null): Grace {
    this.attributes['steal-time-previous'] = stealTimePrevious;
    return this;
  }
}

export type InstrumentAttributes = { id: string };

export type InstrumentContents = [];

export class Instrument implements XMLElement<'instrument', InstrumentAttributes, InstrumentContents> {
  static readonly schema = {
    name: 'instrument',
    attributes: { id: { type: 'required', value: { type: 'regex', pattern: /[A-Za-z_][A-Za-z0-9.-_]*/, zero: '_' } } },
    contents: [],
  } as const;

  readonly schema = Instrument.schema;

  attributes: InstrumentAttributes;
  contents: InstrumentContents;

  constructor(opts?: { attributes?: Partial<InstrumentAttributes>; contents?: InstrumentContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Instrument.schema);
    this.contents = opts?.contents ?? operations.zero(Instrument.schema.contents);
  }
  getId(): string {
    return this.attributes['id'];
  }
  setId(id: string): Instrument {
    this.attributes['id'] = id;
    return this;
  }
}

export type VoiceAttributes = Record<string, unknown>;

export type VoiceContents = [string];

export class Voice implements XMLElement<'voice', VoiceAttributes, VoiceContents> {
  static readonly schema = {
    name: 'voice',
    attributes: {},
    contents: [{ type: 'required', value: { type: 'string' } }],
  } as const;

  readonly schema = Voice.schema;

  attributes: VoiceAttributes;
  contents: VoiceContents;

  constructor(opts?: { attributes?: Partial<VoiceAttributes>; contents?: VoiceContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Voice.schema);
    this.contents = opts?.contents ?? operations.zero(Voice.schema.contents);
  }

  getText(): string {
    return this.contents[0];
  }
  setText(text: string): Voice {
    this.contents[0] = text;
    return this;
  }
}

export type TypeAttributes = { size: 'cue' | 'full' | 'grace-cue' | 'large' | null };

export type TypeContents = [
  | 'whole'
  | '1024th'
  | '512th'
  | '256th'
  | '128th'
  | '64th'
  | '32nd'
  | '16th'
  | 'eighth'
  | 'half'
  | 'quarter'
  | 'whole'
  | 'breve'
  | 'long'
  | 'maxima'
];

export class Type implements XMLElement<'type', TypeAttributes, TypeContents> {
  static readonly schema = {
    name: 'type',
    attributes: {
      size: { type: 'optional', value: { type: 'choices', choices: ['cue', 'full', 'grace-cue', 'large'] } },
    },
    contents: [
      {
        type: 'required',
        value: {
          type: 'label',
          label: 'note-type-value',
          value: {
            type: 'choices',
            choices: [
              'whole',
              '1024th',
              '512th',
              '256th',
              '128th',
              '64th',
              '32nd',
              '16th',
              'eighth',
              'half',
              'quarter',
              'whole',
              'breve',
              'long',
              'maxima',
            ],
          },
        },
      },
    ],
  } as const;

  readonly schema = Type.schema;

  attributes: TypeAttributes;
  contents: TypeContents;

  constructor(opts?: { attributes?: Partial<TypeAttributes>; contents?: TypeContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Type.schema);
    this.contents = opts?.contents ?? operations.zero(Type.schema.contents);
  }
  getSize(): 'cue' | 'full' | 'grace-cue' | 'large' | null {
    return this.attributes['size'];
  }
  setSize(size: 'cue' | 'full' | 'grace-cue' | 'large' | null): Type {
    this.attributes['size'] = size;
    return this;
  }
  getNoteTypeValue():
    | 'whole'
    | '1024th'
    | '512th'
    | '256th'
    | '128th'
    | '64th'
    | '32nd'
    | '16th'
    | 'eighth'
    | 'half'
    | 'quarter'
    | 'whole'
    | 'breve'
    | 'long'
    | 'maxima' {
    return this.contents[0];
  }
  setNoteTypeValue(
    noteTypeValue:
      | 'whole'
      | '1024th'
      | '512th'
      | '256th'
      | '128th'
      | '64th'
      | '32nd'
      | '16th'
      | 'eighth'
      | 'half'
      | 'quarter'
      | 'whole'
      | 'breve'
      | 'long'
      | 'maxima'
  ): Type {
    this.contents[0] = noteTypeValue;
    return this;
  }
}

export type DotAttributes = {
  color: string | null;
  'default-x': number | null;
  'default-y': number | null;
  'font-family': string | null;
  'font-size': 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null;
  'font-style': 'normal' | 'italic' | null;
  'font-weight': 'normal' | 'bold' | null;
  placement: 'above' | 'below' | null;
  'relative-x': number | null;
  'relative-y': number | null;
};

export type DotContents = [];

export class Dot implements XMLElement<'dot', DotAttributes, DotContents> {
  static readonly schema = {
    name: 'dot',
    attributes: {
      color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
      'default-x': {
        type: 'label',
        label: 'default-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'default-y': {
        type: 'label',
        label: 'default-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
      'font-size': {
        type: 'optional',
        value: {
          type: 'choices',
          choices: [
            { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
            { type: 'float', min: -Infinity, max: Infinity },
          ],
        },
      },
      'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
      'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
      placement: { type: 'optional', value: { type: 'choices', choices: ['above', 'below'] } },
      'relative-x': {
        type: 'label',
        label: 'relative-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'relative-y': {
        type: 'label',
        label: 'relative-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
    },
    contents: [],
  } as const;

  readonly schema = Dot.schema;

  attributes: DotAttributes;
  contents: DotContents;

  constructor(opts?: { attributes?: Partial<DotAttributes>; contents?: DotContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Dot.schema);
    this.contents = opts?.contents ?? operations.zero(Dot.schema.contents);
  }
  getColor(): string | null {
    return this.attributes['color'];
  }
  setColor(color: string | null): Dot {
    this.attributes['color'] = color;
    return this;
  }
  getDefaultX(): number | null {
    return this.attributes['default-x'];
  }
  setDefaultX(defaultX: number | null): Dot {
    this.attributes['default-x'] = defaultX;
    return this;
  }
  getDefaultY(): number | null {
    return this.attributes['default-y'];
  }
  setDefaultY(defaultY: number | null): Dot {
    this.attributes['default-y'] = defaultY;
    return this;
  }
  getFontFamily(): string | null {
    return this.attributes['font-family'];
  }
  setFontFamily(fontFamily: string | null): Dot {
    this.attributes['font-family'] = fontFamily;
    return this;
  }
  getFontSize(): 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null {
    return this.attributes['font-size'];
  }
  setFontSize(
    fontSize: 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null
  ): Dot {
    this.attributes['font-size'] = fontSize;
    return this;
  }
  getFontStyle(): 'normal' | 'italic' | null {
    return this.attributes['font-style'];
  }
  setFontStyle(fontStyle: 'normal' | 'italic' | null): Dot {
    this.attributes['font-style'] = fontStyle;
    return this;
  }
  getFontWeight(): 'normal' | 'bold' | null {
    return this.attributes['font-weight'];
  }
  setFontWeight(fontWeight: 'normal' | 'bold' | null): Dot {
    this.attributes['font-weight'] = fontWeight;
    return this;
  }
  getPlacement(): 'above' | 'below' | null {
    return this.attributes['placement'];
  }
  setPlacement(placement: 'above' | 'below' | null): Dot {
    this.attributes['placement'] = placement;
    return this;
  }
  getRelativeX(): number | null {
    return this.attributes['relative-x'];
  }
  setRelativeX(relativeX: number | null): Dot {
    this.attributes['relative-x'] = relativeX;
    return this;
  }
  getRelativeY(): number | null {
    return this.attributes['relative-y'];
  }
  setRelativeY(relativeY: number | null): Dot {
    this.attributes['relative-y'] = relativeY;
    return this;
  }
}

export type AccidentalAttributes = {
  bracket: 'yes' | 'no' | null;
  cautionary: 'yes' | 'no' | null;
  color: string | null;
  'default-x': number | null;
  'default-y': number | null;
  editorial: 'yes' | 'no' | null;
  'font-family': string | null;
  'font-size': 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null;
  'font-style': 'normal' | 'italic' | null;
  'font-weight': 'normal' | 'bold' | null;
  parentheses: 'yes' | 'no' | null;
  'relative-x': number | null;
  'relative-y': number | null;
  size: 'cue' | 'full' | 'grace-cue' | 'large' | null;
  smufl: string | null;
};

export type AccidentalContents = [
  | 'other'
  | 'sharp'
  | 'natural'
  | 'flat'
  | 'double-sharp'
  | 'sharp-sharp'
  | 'flat-flat'
  | 'natural-sharp'
  | 'natural-flat'
  | 'quarter-flat'
  | 'quarter-sharp'
  | 'three-quarters-flat'
  | 'three-quarters-sharp'
  | 'sharp-down'
  | 'sharp-up'
  | 'natural-down'
  | 'natural-up'
  | 'flat-down'
  | 'flat-up'
  | 'double-sharp-down'
  | 'double-sharp-up'
  | 'flat-flat-down'
  | 'flat-flat-up'
  | 'arrow-down'
  | 'arrow-up'
  | 'triple-sharp'
  | 'triple-flat'
  | 'slash-quarter-sharp'
  | 'slash-sharp'
  | 'slash-flat'
  | 'double-slash-flat'
  | 'sharp-1'
  | 'sharp-2'
  | 'sharp-3'
  | 'sharp-5'
  | 'flat-1'
  | 'flat-2'
  | 'flat-3'
  | 'flat-4'
  | 'sori'
  | 'koron'
];

export class Accidental implements XMLElement<'accidental', AccidentalAttributes, AccidentalContents> {
  static readonly schema = {
    name: 'accidental',
    attributes: {
      bracket: { type: 'optional', value: { type: 'choices', choices: ['yes', 'no'] } },
      cautionary: { type: 'optional', value: { type: 'choices', choices: ['yes', 'no'] } },
      color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
      'default-x': {
        type: 'label',
        label: 'default-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'default-y': {
        type: 'label',
        label: 'default-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      editorial: { type: 'optional', value: { type: 'choices', choices: ['yes', 'no'] } },
      'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
      'font-size': {
        type: 'optional',
        value: {
          type: 'choices',
          choices: [
            { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
            { type: 'float', min: -Infinity, max: Infinity },
          ],
        },
      },
      'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
      'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
      parentheses: { type: 'optional', value: { type: 'choices', choices: ['yes', 'no'] } },
      'relative-x': {
        type: 'label',
        label: 'relative-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'relative-y': {
        type: 'label',
        label: 'relative-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      size: { type: 'optional', value: { type: 'choices', choices: ['cue', 'full', 'grace-cue', 'large'] } },
      smufl: {
        type: 'optional',
        value: { type: 'regex', pattern: /(acc|medRenFla|medRenNatura|medRenShar|kievanAccidental)/, zero: 'acc' },
      },
    },
    contents: [
      {
        type: 'required',
        value: {
          type: 'label',
          label: 'accidental-value',
          value: {
            type: 'choices',
            choices: [
              'other',
              'sharp',
              'natural',
              'flat',
              'double-sharp',
              'sharp-sharp',
              'flat-flat',
              'natural-sharp',
              'natural-flat',
              'quarter-flat',
              'quarter-sharp',
              'three-quarters-flat',
              'three-quarters-sharp',
              'sharp-down',
              'sharp-up',
              'natural-down',
              'natural-up',
              'flat-down',
              'flat-up',
              'double-sharp-down',
              'double-sharp-up',
              'flat-flat-down',
              'flat-flat-up',
              'arrow-down',
              'arrow-up',
              'triple-sharp',
              'triple-flat',
              'slash-quarter-sharp',
              'slash-sharp',
              'slash-flat',
              'double-slash-flat',
              'sharp-1',
              'sharp-2',
              'sharp-3',
              'sharp-5',
              'flat-1',
              'flat-2',
              'flat-3',
              'flat-4',
              'sori',
              'koron',
            ],
          },
        },
      },
    ],
  } as const;

  readonly schema = Accidental.schema;

  attributes: AccidentalAttributes;
  contents: AccidentalContents;

  constructor(opts?: { attributes?: Partial<AccidentalAttributes>; contents?: AccidentalContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Accidental.schema);
    this.contents = opts?.contents ?? operations.zero(Accidental.schema.contents);
  }
  getBracket(): 'yes' | 'no' | null {
    return this.attributes['bracket'];
  }
  setBracket(bracket: 'yes' | 'no' | null): Accidental {
    this.attributes['bracket'] = bracket;
    return this;
  }
  getCautionary(): 'yes' | 'no' | null {
    return this.attributes['cautionary'];
  }
  setCautionary(cautionary: 'yes' | 'no' | null): Accidental {
    this.attributes['cautionary'] = cautionary;
    return this;
  }
  getColor(): string | null {
    return this.attributes['color'];
  }
  setColor(color: string | null): Accidental {
    this.attributes['color'] = color;
    return this;
  }
  getDefaultX(): number | null {
    return this.attributes['default-x'];
  }
  setDefaultX(defaultX: number | null): Accidental {
    this.attributes['default-x'] = defaultX;
    return this;
  }
  getDefaultY(): number | null {
    return this.attributes['default-y'];
  }
  setDefaultY(defaultY: number | null): Accidental {
    this.attributes['default-y'] = defaultY;
    return this;
  }
  getEditorial(): 'yes' | 'no' | null {
    return this.attributes['editorial'];
  }
  setEditorial(editorial: 'yes' | 'no' | null): Accidental {
    this.attributes['editorial'] = editorial;
    return this;
  }
  getFontFamily(): string | null {
    return this.attributes['font-family'];
  }
  setFontFamily(fontFamily: string | null): Accidental {
    this.attributes['font-family'] = fontFamily;
    return this;
  }
  getFontSize(): 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null {
    return this.attributes['font-size'];
  }
  setFontSize(
    fontSize: 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null
  ): Accidental {
    this.attributes['font-size'] = fontSize;
    return this;
  }
  getFontStyle(): 'normal' | 'italic' | null {
    return this.attributes['font-style'];
  }
  setFontStyle(fontStyle: 'normal' | 'italic' | null): Accidental {
    this.attributes['font-style'] = fontStyle;
    return this;
  }
  getFontWeight(): 'normal' | 'bold' | null {
    return this.attributes['font-weight'];
  }
  setFontWeight(fontWeight: 'normal' | 'bold' | null): Accidental {
    this.attributes['font-weight'] = fontWeight;
    return this;
  }
  getParentheses(): 'yes' | 'no' | null {
    return this.attributes['parentheses'];
  }
  setParentheses(parentheses: 'yes' | 'no' | null): Accidental {
    this.attributes['parentheses'] = parentheses;
    return this;
  }
  getRelativeX(): number | null {
    return this.attributes['relative-x'];
  }
  setRelativeX(relativeX: number | null): Accidental {
    this.attributes['relative-x'] = relativeX;
    return this;
  }
  getRelativeY(): number | null {
    return this.attributes['relative-y'];
  }
  setRelativeY(relativeY: number | null): Accidental {
    this.attributes['relative-y'] = relativeY;
    return this;
  }
  getSize(): 'cue' | 'full' | 'grace-cue' | 'large' | null {
    return this.attributes['size'];
  }
  setSize(size: 'cue' | 'full' | 'grace-cue' | 'large' | null): Accidental {
    this.attributes['size'] = size;
    return this;
  }
  getSmufl(): string | null {
    return this.attributes['smufl'];
  }
  setSmufl(smufl: string | null): Accidental {
    this.attributes['smufl'] = smufl;
    return this;
  }
  getAccidentalValue():
    | 'other'
    | 'sharp'
    | 'natural'
    | 'flat'
    | 'double-sharp'
    | 'sharp-sharp'
    | 'flat-flat'
    | 'natural-sharp'
    | 'natural-flat'
    | 'quarter-flat'
    | 'quarter-sharp'
    | 'three-quarters-flat'
    | 'three-quarters-sharp'
    | 'sharp-down'
    | 'sharp-up'
    | 'natural-down'
    | 'natural-up'
    | 'flat-down'
    | 'flat-up'
    | 'double-sharp-down'
    | 'double-sharp-up'
    | 'flat-flat-down'
    | 'flat-flat-up'
    | 'arrow-down'
    | 'arrow-up'
    | 'triple-sharp'
    | 'triple-flat'
    | 'slash-quarter-sharp'
    | 'slash-sharp'
    | 'slash-flat'
    | 'double-slash-flat'
    | 'sharp-1'
    | 'sharp-2'
    | 'sharp-3'
    | 'sharp-5'
    | 'flat-1'
    | 'flat-2'
    | 'flat-3'
    | 'flat-4'
    | 'sori'
    | 'koron' {
    return this.contents[0];
  }
  setAccidentalValue(
    accidentalValue:
      | 'other'
      | 'sharp'
      | 'natural'
      | 'flat'
      | 'double-sharp'
      | 'sharp-sharp'
      | 'flat-flat'
      | 'natural-sharp'
      | 'natural-flat'
      | 'quarter-flat'
      | 'quarter-sharp'
      | 'three-quarters-flat'
      | 'three-quarters-sharp'
      | 'sharp-down'
      | 'sharp-up'
      | 'natural-down'
      | 'natural-up'
      | 'flat-down'
      | 'flat-up'
      | 'double-sharp-down'
      | 'double-sharp-up'
      | 'flat-flat-down'
      | 'flat-flat-up'
      | 'arrow-down'
      | 'arrow-up'
      | 'triple-sharp'
      | 'triple-flat'
      | 'slash-quarter-sharp'
      | 'slash-sharp'
      | 'slash-flat'
      | 'double-slash-flat'
      | 'sharp-1'
      | 'sharp-2'
      | 'sharp-3'
      | 'sharp-5'
      | 'flat-1'
      | 'flat-2'
      | 'flat-3'
      | 'flat-4'
      | 'sori'
      | 'koron'
  ): Accidental {
    this.contents[0] = accidentalValue;
    return this;
  }
}

export type ActualNotesAttributes = Record<string, unknown>;

export type ActualNotesContents = [number];

export class ActualNotes implements XMLElement<'actual-notes', ActualNotesAttributes, ActualNotesContents> {
  static readonly schema = {
    name: 'actual-notes',
    attributes: {},
    contents: [
      { type: 'label', label: 'value', value: { type: 'required', value: { type: 'int', min: 0, max: Infinity } } },
    ],
  } as const;

  readonly schema = ActualNotes.schema;

  attributes: ActualNotesAttributes;
  contents: ActualNotesContents;

  constructor(opts?: { attributes?: Partial<ActualNotesAttributes>; contents?: ActualNotesContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, ActualNotes.schema);
    this.contents = opts?.contents ?? operations.zero(ActualNotes.schema.contents);
  }

  getValue(): number {
    return this.contents[0];
  }
  setValue(value: number): ActualNotes {
    this.contents[0] = value;
    return this;
  }
}

export type NormalNotesAttributes = Record<string, unknown>;

export type NormalNotesContents = [number];

export class NormalNotes implements XMLElement<'normal-notes', NormalNotesAttributes, NormalNotesContents> {
  static readonly schema = {
    name: 'normal-notes',
    attributes: {},
    contents: [
      { type: 'label', label: 'value', value: { type: 'required', value: { type: 'int', min: 0, max: Infinity } } },
    ],
  } as const;

  readonly schema = NormalNotes.schema;

  attributes: NormalNotesAttributes;
  contents: NormalNotesContents;

  constructor(opts?: { attributes?: Partial<NormalNotesAttributes>; contents?: NormalNotesContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, NormalNotes.schema);
    this.contents = opts?.contents ?? operations.zero(NormalNotes.schema.contents);
  }

  getValue(): number {
    return this.contents[0];
  }
  setValue(value: number): NormalNotes {
    this.contents[0] = value;
    return this;
  }
}

export type NormalTypeAttributes = Record<string, unknown>;

export type NormalTypeContents = [
  | 'whole'
  | '1024th'
  | '512th'
  | '256th'
  | '128th'
  | '64th'
  | '32nd'
  | '16th'
  | 'eighth'
  | 'half'
  | 'quarter'
  | 'whole'
  | 'breve'
  | 'long'
  | 'maxima'
];

export class NormalType implements XMLElement<'normal-type', NormalTypeAttributes, NormalTypeContents> {
  static readonly schema = {
    name: 'normal-type',
    attributes: {},
    contents: [
      {
        type: 'required',
        value: {
          type: 'label',
          label: 'note-type-value',
          value: {
            type: 'choices',
            choices: [
              'whole',
              '1024th',
              '512th',
              '256th',
              '128th',
              '64th',
              '32nd',
              '16th',
              'eighth',
              'half',
              'quarter',
              'whole',
              'breve',
              'long',
              'maxima',
            ],
          },
        },
      },
    ],
  } as const;

  readonly schema = NormalType.schema;

  attributes: NormalTypeAttributes;
  contents: NormalTypeContents;

  constructor(opts?: { attributes?: Partial<NormalTypeAttributes>; contents?: NormalTypeContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, NormalType.schema);
    this.contents = opts?.contents ?? operations.zero(NormalType.schema.contents);
  }

  getNoteTypeValue():
    | 'whole'
    | '1024th'
    | '512th'
    | '256th'
    | '128th'
    | '64th'
    | '32nd'
    | '16th'
    | 'eighth'
    | 'half'
    | 'quarter'
    | 'whole'
    | 'breve'
    | 'long'
    | 'maxima' {
    return this.contents[0];
  }
  setNoteTypeValue(
    noteTypeValue:
      | 'whole'
      | '1024th'
      | '512th'
      | '256th'
      | '128th'
      | '64th'
      | '32nd'
      | '16th'
      | 'eighth'
      | 'half'
      | 'quarter'
      | 'whole'
      | 'breve'
      | 'long'
      | 'maxima'
  ): NormalType {
    this.contents[0] = noteTypeValue;
    return this;
  }
}

export type NormalDotAttributes = Record<string, unknown>;

export type NormalDotContents = [];

export class NormalDot implements XMLElement<'normal-dot', NormalDotAttributes, NormalDotContents> {
  static readonly schema = { name: 'normal-dot', attributes: {}, contents: [] } as const;

  readonly schema = NormalDot.schema;

  attributes: NormalDotAttributes;
  contents: NormalDotContents;

  constructor(opts?: { attributes?: Partial<NormalDotAttributes>; contents?: NormalDotContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, NormalDot.schema);
    this.contents = opts?.contents ?? operations.zero(NormalDot.schema.contents);
  }
}

export type TimeModificationAttributes = Record<string, unknown>;

export type TimeModificationContents = [ActualNotes, NormalNotes, [NormalType, Array<NormalDot>] | null];

export class TimeModification
  implements XMLElement<'time-modification', TimeModificationAttributes, TimeModificationContents>
{
  static readonly schema = {
    name: 'time-modification',
    attributes: {},
    contents: [
      { type: 'required', value: ActualNotes },
      { type: 'required', value: NormalNotes },
      {
        type: 'label',
        label: 'normal',
        value: {
          type: 'optional',
          value: [
            { type: 'required', value: NormalType },
            { type: 'zeroOrMore', value: NormalDot },
          ],
        },
      },
    ],
  } as const;

  readonly schema = TimeModification.schema;

  attributes: TimeModificationAttributes;
  contents: TimeModificationContents;

  constructor(opts?: { attributes?: Partial<TimeModificationAttributes>; contents?: TimeModificationContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, TimeModification.schema);
    this.contents = opts?.contents ?? operations.zero(TimeModification.schema.contents);
  }

  getActualNotes(): ActualNotes {
    return this.contents[0];
  }
  setActualNotes(actualNotes: ActualNotes): TimeModification {
    this.contents[0] = actualNotes;
    return this;
  }
  getNormalNotes(): NormalNotes {
    return this.contents[1];
  }
  setNormalNotes(normalNotes: NormalNotes): TimeModification {
    this.contents[1] = normalNotes;
    return this;
  }
  getNormal(): [NormalType, Array<NormalDot>] | null {
    return this.contents[2];
  }
  setNormal(normal: [NormalType, Array<NormalDot>] | null): TimeModification {
    this.contents[2] = normal;
    return this;
  }
}

export type StemAttributes = {
  color: string | null;
  'default-x': number | null;
  'default-y': number | null;
  'relative-x': number | null;
  'relative-y': number | null;
};

export type StemContents = ['none' | 'down' | 'up' | 'double'];

export class Stem implements XMLElement<'stem', StemAttributes, StemContents> {
  static readonly schema = {
    name: 'stem',
    attributes: {
      color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
      'default-x': {
        type: 'label',
        label: 'default-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'default-y': {
        type: 'label',
        label: 'default-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'relative-x': {
        type: 'label',
        label: 'relative-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'relative-y': {
        type: 'label',
        label: 'relative-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
    },
    contents: [
      { type: 'label', label: 'stem-value', value: { type: 'choices', choices: ['none', 'down', 'up', 'double'] } },
    ],
  } as const;

  readonly schema = Stem.schema;

  attributes: StemAttributes;
  contents: StemContents;

  constructor(opts?: { attributes?: Partial<StemAttributes>; contents?: StemContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Stem.schema);
    this.contents = opts?.contents ?? operations.zero(Stem.schema.contents);
  }
  getColor(): string | null {
    return this.attributes['color'];
  }
  setColor(color: string | null): Stem {
    this.attributes['color'] = color;
    return this;
  }
  getDefaultX(): number | null {
    return this.attributes['default-x'];
  }
  setDefaultX(defaultX: number | null): Stem {
    this.attributes['default-x'] = defaultX;
    return this;
  }
  getDefaultY(): number | null {
    return this.attributes['default-y'];
  }
  setDefaultY(defaultY: number | null): Stem {
    this.attributes['default-y'] = defaultY;
    return this;
  }
  getRelativeX(): number | null {
    return this.attributes['relative-x'];
  }
  setRelativeX(relativeX: number | null): Stem {
    this.attributes['relative-x'] = relativeX;
    return this;
  }
  getRelativeY(): number | null {
    return this.attributes['relative-y'];
  }
  setRelativeY(relativeY: number | null): Stem {
    this.attributes['relative-y'] = relativeY;
    return this;
  }
  getStemValue(): 'none' | 'down' | 'up' | 'double' {
    return this.contents[0];
  }
  setStemValue(stemValue: 'none' | 'down' | 'up' | 'double'): Stem {
    this.contents[0] = stemValue;
    return this;
  }
}

export type NoteheadAttributes = {
  color: string | null;
  filled: 'yes' | 'no' | null;
  'font-family': string | null;
  'font-size': 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null;
  'font-style': 'normal' | 'italic' | null;
  'font-weight': 'normal' | 'bold' | null;
  parentheses: 'yes' | 'no' | null;
  smufl: string | null;
};

export type NoteheadContents = [
  | 'other'
  | 'arrow down'
  | 'arrow up'
  | 'back slashed'
  | 'circle dot'
  | 'circle-x'
  | 'circled'
  | 'cluster'
  | 'cross'
  | 'diamond'
  | 'do'
  | 'fa'
  | 'fa up'
  | 'inverted triangle'
  | 'la'
  | 'left triangle'
  | 'mi'
  | 'none'
  | 'normal'
  | 're'
  | 'rectangle'
  | 'slash'
  | 'slashed'
  | 'so'
  | 'square'
  | 'ti'
  | 'triangle'
  | 'x'
];

export class Notehead implements XMLElement<'notehead', NoteheadAttributes, NoteheadContents> {
  static readonly schema = {
    name: 'notehead',
    attributes: {
      color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
      filled: { type: 'optional', value: { type: 'choices', choices: ['yes', 'no'] } },
      'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
      'font-size': {
        type: 'optional',
        value: {
          type: 'choices',
          choices: [
            { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
            { type: 'float', min: -Infinity, max: Infinity },
          ],
        },
      },
      'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
      'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
      parentheses: { type: 'optional', value: { type: 'choices', choices: ['yes', 'no'] } },
      smufl: { type: 'optional', value: { type: 'string' } },
    },
    contents: [
      {
        type: 'required',
        value: {
          type: 'label',
          label: 'notehead-value',
          value: {
            type: 'choices',
            choices: [
              'other',
              'arrow down',
              'arrow up',
              'back slashed',
              'circle dot',
              'circle-x',
              'circled',
              'cluster',
              'cross',
              'diamond',
              'do',
              'fa',
              'fa up',
              'inverted triangle',
              'la',
              'left triangle',
              'mi',
              'none',
              'normal',
              're',
              'rectangle',
              'slash',
              'slashed',
              'so',
              'square',
              'ti',
              'triangle',
              'x',
            ],
          },
        },
      },
    ],
  } as const;

  readonly schema = Notehead.schema;

  attributes: NoteheadAttributes;
  contents: NoteheadContents;

  constructor(opts?: { attributes?: Partial<NoteheadAttributes>; contents?: NoteheadContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Notehead.schema);
    this.contents = opts?.contents ?? operations.zero(Notehead.schema.contents);
  }
  getColor(): string | null {
    return this.attributes['color'];
  }
  setColor(color: string | null): Notehead {
    this.attributes['color'] = color;
    return this;
  }
  getFilled(): 'yes' | 'no' | null {
    return this.attributes['filled'];
  }
  setFilled(filled: 'yes' | 'no' | null): Notehead {
    this.attributes['filled'] = filled;
    return this;
  }
  getFontFamily(): string | null {
    return this.attributes['font-family'];
  }
  setFontFamily(fontFamily: string | null): Notehead {
    this.attributes['font-family'] = fontFamily;
    return this;
  }
  getFontSize(): 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null {
    return this.attributes['font-size'];
  }
  setFontSize(
    fontSize: 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null
  ): Notehead {
    this.attributes['font-size'] = fontSize;
    return this;
  }
  getFontStyle(): 'normal' | 'italic' | null {
    return this.attributes['font-style'];
  }
  setFontStyle(fontStyle: 'normal' | 'italic' | null): Notehead {
    this.attributes['font-style'] = fontStyle;
    return this;
  }
  getFontWeight(): 'normal' | 'bold' | null {
    return this.attributes['font-weight'];
  }
  setFontWeight(fontWeight: 'normal' | 'bold' | null): Notehead {
    this.attributes['font-weight'] = fontWeight;
    return this;
  }
  getParentheses(): 'yes' | 'no' | null {
    return this.attributes['parentheses'];
  }
  setParentheses(parentheses: 'yes' | 'no' | null): Notehead {
    this.attributes['parentheses'] = parentheses;
    return this;
  }
  getSmufl(): string | null {
    return this.attributes['smufl'];
  }
  setSmufl(smufl: string | null): Notehead {
    this.attributes['smufl'] = smufl;
    return this;
  }
  getNoteheadValue():
    | 'other'
    | 'arrow down'
    | 'arrow up'
    | 'back slashed'
    | 'circle dot'
    | 'circle-x'
    | 'circled'
    | 'cluster'
    | 'cross'
    | 'diamond'
    | 'do'
    | 'fa'
    | 'fa up'
    | 'inverted triangle'
    | 'la'
    | 'left triangle'
    | 'mi'
    | 'none'
    | 'normal'
    | 're'
    | 'rectangle'
    | 'slash'
    | 'slashed'
    | 'so'
    | 'square'
    | 'ti'
    | 'triangle'
    | 'x' {
    return this.contents[0];
  }
  setNoteheadValue(
    noteheadValue:
      | 'other'
      | 'arrow down'
      | 'arrow up'
      | 'back slashed'
      | 'circle dot'
      | 'circle-x'
      | 'circled'
      | 'cluster'
      | 'cross'
      | 'diamond'
      | 'do'
      | 'fa'
      | 'fa up'
      | 'inverted triangle'
      | 'la'
      | 'left triangle'
      | 'mi'
      | 'none'
      | 'normal'
      | 're'
      | 'rectangle'
      | 'slash'
      | 'slashed'
      | 'so'
      | 'square'
      | 'ti'
      | 'triangle'
      | 'x'
  ): Notehead {
    this.contents[0] = noteheadValue;
    return this;
  }
}

export type NoteheadTextAttributes = Record<string, unknown>;

export type NoteheadTextContents = [Array<[DisplayText, AccidentalText]>];

export class NoteheadText implements XMLElement<'notehead-text', NoteheadTextAttributes, NoteheadTextContents> {
  static readonly schema = {
    name: 'notehead-text',
    attributes: {},
    contents: [{ type: 'label', label: 'texts', value: { type: 'oneOrMore', value: [DisplayText, AccidentalText] } }],
  } as const;

  readonly schema = NoteheadText.schema;

  attributes: NoteheadTextAttributes;
  contents: NoteheadTextContents;

  constructor(opts?: { attributes?: Partial<NoteheadTextAttributes>; contents?: NoteheadTextContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, NoteheadText.schema);
    this.contents = opts?.contents ?? operations.zero(NoteheadText.schema.contents);
  }

  getTexts(): Array<[DisplayText, AccidentalText]> {
    return this.contents[0];
  }
  setTexts(texts: Array<[DisplayText, AccidentalText]>): NoteheadText {
    this.contents[0] = texts;
    return this;
  }
}

export type StaffAttributes = Record<string, unknown>;

export type StaffContents = [number];

export class Staff implements XMLElement<'staff', StaffAttributes, StaffContents> {
  static readonly schema = {
    name: 'staff',
    attributes: {},
    contents: [
      {
        type: 'label',
        label: 'staff-value',
        value: { type: 'required', value: { type: 'int', min: 1, max: Infinity } },
      },
    ],
  } as const;

  readonly schema = Staff.schema;

  attributes: StaffAttributes;
  contents: StaffContents;

  constructor(opts?: { attributes?: Partial<StaffAttributes>; contents?: StaffContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Staff.schema);
    this.contents = opts?.contents ?? operations.zero(Staff.schema.contents);
  }

  getStaffValue(): number {
    return this.contents[0];
  }
  setStaffValue(staffValue: number): Staff {
    this.contents[0] = staffValue;
    return this;
  }
}

export type BeamAttributes = {
  color: string | null;
  fan: 'accel' | 'none' | 'rit' | null;
  id: string | null;
  number: number | null;
  repeater: 'yes' | 'no' | null;
};

export type BeamContents = ['backward hook' | 'begin' | 'continue' | 'end' | 'forward hook'];

export class Beam implements XMLElement<'beam', BeamAttributes, BeamContents> {
  static readonly schema = {
    name: 'beam',
    attributes: {
      color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
      fan: { type: 'optional', value: { type: 'choices', choices: ['accel', 'none', 'rit'] } },
      id: { type: 'optional', value: { type: 'regex', pattern: /[A-Za-z_][A-Za-z0-9.-_]*/, zero: '_' } },
      number: { type: 'optional', value: { type: 'int', min: 1, max: 8 } },
      repeater: { type: 'optional', value: { type: 'choices', choices: ['yes', 'no'] } },
    },
    contents: [
      {
        type: 'required',
        value: {
          type: 'label',
          label: 'beam-value',
          value: { type: 'choices', choices: ['backward hook', 'begin', 'continue', 'end', 'forward hook'] },
        },
      },
    ],
  } as const;

  readonly schema = Beam.schema;

  attributes: BeamAttributes;
  contents: BeamContents;

  constructor(opts?: { attributes?: Partial<BeamAttributes>; contents?: BeamContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Beam.schema);
    this.contents = opts?.contents ?? operations.zero(Beam.schema.contents);
  }
  getColor(): string | null {
    return this.attributes['color'];
  }
  setColor(color: string | null): Beam {
    this.attributes['color'] = color;
    return this;
  }
  getFan(): 'accel' | 'none' | 'rit' | null {
    return this.attributes['fan'];
  }
  setFan(fan: 'accel' | 'none' | 'rit' | null): Beam {
    this.attributes['fan'] = fan;
    return this;
  }
  getId(): string | null {
    return this.attributes['id'];
  }
  setId(id: string | null): Beam {
    this.attributes['id'] = id;
    return this;
  }
  getNumber(): number | null {
    return this.attributes['number'];
  }
  setNumber(number: number | null): Beam {
    this.attributes['number'] = number;
    return this;
  }
  getRepeater(): 'yes' | 'no' | null {
    return this.attributes['repeater'];
  }
  setRepeater(repeater: 'yes' | 'no' | null): Beam {
    this.attributes['repeater'] = repeater;
    return this;
  }
  getBeamValue(): 'backward hook' | 'begin' | 'continue' | 'end' | 'forward hook' {
    return this.contents[0];
  }
  setBeamValue(beamValue: 'backward hook' | 'begin' | 'continue' | 'end' | 'forward hook'): Beam {
    this.contents[0] = beamValue;
    return this;
  }
}

export type TiedAttributes = {
  type: 'start' | 'stop' | 'continue' | 'let-ring';
  'bezier-x': number | null;
  'bezier-x2': number | null;
  'bezier-y': number | null;
  'bezier-y2': number | null;
  color: string | null;
  'dash-length': number | null;
  'default-x': number | null;
  'default-y': number | null;
  id: string | null;
  'line-type': 'dashed' | 'dotted' | 'solid' | 'wavy' | null;
  number: number | null;
  orientation: 'over' | 'under' | null;
  placement: 'above' | 'below' | null;
  'relative-x': number | null;
  'relative-y': number | null;
  'space-length': number | null;
};

export type TiedContents = [];

export class Tied implements XMLElement<'tied', TiedAttributes, TiedContents> {
  static readonly schema = {
    name: 'tied',
    attributes: {
      type: { type: 'required', value: { type: 'choices', choices: ['start', 'stop', 'continue', 'let-ring'] } },
      'bezier-x': { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      'bezier-x2': { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      'bezier-y': { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      'bezier-y2': { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
      'dash-length': { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      'default-x': {
        type: 'label',
        label: 'default-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'default-y': {
        type: 'label',
        label: 'default-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      id: { type: 'optional', value: { type: 'regex', pattern: /[A-Za-z_][A-Za-z0-9.-_]*/, zero: '_' } },
      'line-type': { type: 'optional', value: { type: 'choices', choices: ['dashed', 'dotted', 'solid', 'wavy'] } },
      number: { type: 'optional', value: { type: 'int', min: 1, max: 16 } },
      orientation: { type: 'optional', value: { type: 'choices', choices: ['over', 'under'] } },
      placement: { type: 'optional', value: { type: 'choices', choices: ['above', 'below'] } },
      'relative-x': {
        type: 'label',
        label: 'relative-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'relative-y': {
        type: 'label',
        label: 'relative-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'space-length': { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
    },
    contents: [],
  } as const;

  readonly schema = Tied.schema;

  attributes: TiedAttributes;
  contents: TiedContents;

  constructor(opts?: { attributes?: Partial<TiedAttributes>; contents?: TiedContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Tied.schema);
    this.contents = opts?.contents ?? operations.zero(Tied.schema.contents);
  }
  getType(): 'start' | 'stop' | 'continue' | 'let-ring' {
    return this.attributes['type'];
  }
  setType(type: 'start' | 'stop' | 'continue' | 'let-ring'): Tied {
    this.attributes['type'] = type;
    return this;
  }
  getBezierX(): number | null {
    return this.attributes['bezier-x'];
  }
  setBezierX(bezierX: number | null): Tied {
    this.attributes['bezier-x'] = bezierX;
    return this;
  }
  getBezierX2(): number | null {
    return this.attributes['bezier-x2'];
  }
  setBezierX2(bezierX2: number | null): Tied {
    this.attributes['bezier-x2'] = bezierX2;
    return this;
  }
  getBezierY(): number | null {
    return this.attributes['bezier-y'];
  }
  setBezierY(bezierY: number | null): Tied {
    this.attributes['bezier-y'] = bezierY;
    return this;
  }
  getBezierY2(): number | null {
    return this.attributes['bezier-y2'];
  }
  setBezierY2(bezierY2: number | null): Tied {
    this.attributes['bezier-y2'] = bezierY2;
    return this;
  }
  getColor(): string | null {
    return this.attributes['color'];
  }
  setColor(color: string | null): Tied {
    this.attributes['color'] = color;
    return this;
  }
  getDashLength(): number | null {
    return this.attributes['dash-length'];
  }
  setDashLength(dashLength: number | null): Tied {
    this.attributes['dash-length'] = dashLength;
    return this;
  }
  getDefaultX(): number | null {
    return this.attributes['default-x'];
  }
  setDefaultX(defaultX: number | null): Tied {
    this.attributes['default-x'] = defaultX;
    return this;
  }
  getDefaultY(): number | null {
    return this.attributes['default-y'];
  }
  setDefaultY(defaultY: number | null): Tied {
    this.attributes['default-y'] = defaultY;
    return this;
  }
  getId(): string | null {
    return this.attributes['id'];
  }
  setId(id: string | null): Tied {
    this.attributes['id'] = id;
    return this;
  }
  getLineType(): 'dashed' | 'dotted' | 'solid' | 'wavy' | null {
    return this.attributes['line-type'];
  }
  setLineType(lineType: 'dashed' | 'dotted' | 'solid' | 'wavy' | null): Tied {
    this.attributes['line-type'] = lineType;
    return this;
  }
  getNumber(): number | null {
    return this.attributes['number'];
  }
  setNumber(number: number | null): Tied {
    this.attributes['number'] = number;
    return this;
  }
  getOrientation(): 'over' | 'under' | null {
    return this.attributes['orientation'];
  }
  setOrientation(orientation: 'over' | 'under' | null): Tied {
    this.attributes['orientation'] = orientation;
    return this;
  }
  getPlacement(): 'above' | 'below' | null {
    return this.attributes['placement'];
  }
  setPlacement(placement: 'above' | 'below' | null): Tied {
    this.attributes['placement'] = placement;
    return this;
  }
  getRelativeX(): number | null {
    return this.attributes['relative-x'];
  }
  setRelativeX(relativeX: number | null): Tied {
    this.attributes['relative-x'] = relativeX;
    return this;
  }
  getRelativeY(): number | null {
    return this.attributes['relative-y'];
  }
  setRelativeY(relativeY: number | null): Tied {
    this.attributes['relative-y'] = relativeY;
    return this;
  }
  getSpaceLength(): number | null {
    return this.attributes['space-length'];
  }
  setSpaceLength(spaceLength: number | null): Tied {
    this.attributes['space-length'] = spaceLength;
    return this;
  }
}

export type SlurAttributes = {
  type: 'start' | 'stop' | 'continue';
  'bezier-x': number | null;
  'bezier-x2': number | null;
  'bezier-y': number | null;
  'bezier-y2': number | null;
  color: string | null;
  'dash-length': number | null;
  'default-x': number | null;
  'default-y': number | null;
  id: string | null;
  'line-type': 'dashed' | 'dotted' | 'solid' | 'wavy' | null;
  number: number | null;
  orientation: 'over' | 'under' | null;
  placement: 'above' | 'below' | null;
  'relative-x': number | null;
  'relative-y': number | null;
  'space-length': number | null;
};

export type SlurContents = [];

export class Slur implements XMLElement<'slur', SlurAttributes, SlurContents> {
  static readonly schema = {
    name: 'slur',
    attributes: {
      type: { type: 'required', value: { type: 'choices', choices: ['start', 'stop', 'continue'] } },
      'bezier-x': { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      'bezier-x2': { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      'bezier-y': { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      'bezier-y2': { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
      'dash-length': { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      'default-x': {
        type: 'label',
        label: 'default-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'default-y': {
        type: 'label',
        label: 'default-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      id: { type: 'optional', value: { type: 'regex', pattern: /[A-Za-z_][A-Za-z0-9.-_]*/, zero: '_' } },
      'line-type': { type: 'optional', value: { type: 'choices', choices: ['dashed', 'dotted', 'solid', 'wavy'] } },
      number: { type: 'optional', value: { type: 'int', min: 1, max: 16 } },
      orientation: { type: 'optional', value: { type: 'choices', choices: ['over', 'under'] } },
      placement: { type: 'optional', value: { type: 'choices', choices: ['above', 'below'] } },
      'relative-x': {
        type: 'label',
        label: 'relative-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'relative-y': {
        type: 'label',
        label: 'relative-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'space-length': { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
    },
    contents: [],
  } as const;

  readonly schema = Slur.schema;

  attributes: SlurAttributes;
  contents: SlurContents;

  constructor(opts?: { attributes?: Partial<SlurAttributes>; contents?: SlurContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Slur.schema);
    this.contents = opts?.contents ?? operations.zero(Slur.schema.contents);
  }
  getType(): 'start' | 'stop' | 'continue' {
    return this.attributes['type'];
  }
  setType(type: 'start' | 'stop' | 'continue'): Slur {
    this.attributes['type'] = type;
    return this;
  }
  getBezierX(): number | null {
    return this.attributes['bezier-x'];
  }
  setBezierX(bezierX: number | null): Slur {
    this.attributes['bezier-x'] = bezierX;
    return this;
  }
  getBezierX2(): number | null {
    return this.attributes['bezier-x2'];
  }
  setBezierX2(bezierX2: number | null): Slur {
    this.attributes['bezier-x2'] = bezierX2;
    return this;
  }
  getBezierY(): number | null {
    return this.attributes['bezier-y'];
  }
  setBezierY(bezierY: number | null): Slur {
    this.attributes['bezier-y'] = bezierY;
    return this;
  }
  getBezierY2(): number | null {
    return this.attributes['bezier-y2'];
  }
  setBezierY2(bezierY2: number | null): Slur {
    this.attributes['bezier-y2'] = bezierY2;
    return this;
  }
  getColor(): string | null {
    return this.attributes['color'];
  }
  setColor(color: string | null): Slur {
    this.attributes['color'] = color;
    return this;
  }
  getDashLength(): number | null {
    return this.attributes['dash-length'];
  }
  setDashLength(dashLength: number | null): Slur {
    this.attributes['dash-length'] = dashLength;
    return this;
  }
  getDefaultX(): number | null {
    return this.attributes['default-x'];
  }
  setDefaultX(defaultX: number | null): Slur {
    this.attributes['default-x'] = defaultX;
    return this;
  }
  getDefaultY(): number | null {
    return this.attributes['default-y'];
  }
  setDefaultY(defaultY: number | null): Slur {
    this.attributes['default-y'] = defaultY;
    return this;
  }
  getId(): string | null {
    return this.attributes['id'];
  }
  setId(id: string | null): Slur {
    this.attributes['id'] = id;
    return this;
  }
  getLineType(): 'dashed' | 'dotted' | 'solid' | 'wavy' | null {
    return this.attributes['line-type'];
  }
  setLineType(lineType: 'dashed' | 'dotted' | 'solid' | 'wavy' | null): Slur {
    this.attributes['line-type'] = lineType;
    return this;
  }
  getNumber(): number | null {
    return this.attributes['number'];
  }
  setNumber(number: number | null): Slur {
    this.attributes['number'] = number;
    return this;
  }
  getOrientation(): 'over' | 'under' | null {
    return this.attributes['orientation'];
  }
  setOrientation(orientation: 'over' | 'under' | null): Slur {
    this.attributes['orientation'] = orientation;
    return this;
  }
  getPlacement(): 'above' | 'below' | null {
    return this.attributes['placement'];
  }
  setPlacement(placement: 'above' | 'below' | null): Slur {
    this.attributes['placement'] = placement;
    return this;
  }
  getRelativeX(): number | null {
    return this.attributes['relative-x'];
  }
  setRelativeX(relativeX: number | null): Slur {
    this.attributes['relative-x'] = relativeX;
    return this;
  }
  getRelativeY(): number | null {
    return this.attributes['relative-y'];
  }
  setRelativeY(relativeY: number | null): Slur {
    this.attributes['relative-y'] = relativeY;
    return this;
  }
  getSpaceLength(): number | null {
    return this.attributes['space-length'];
  }
  setSpaceLength(spaceLength: number | null): Slur {
    this.attributes['space-length'] = spaceLength;
    return this;
  }
}

export type TupletNumberAttributes = {
  color: string | null;
  'font-family': string | null;
  'font-size': 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null;
  'font-style': 'normal' | 'italic' | null;
  'font-weight': 'normal' | 'bold' | null;
};

export type TupletNumberContents = [number];

export class TupletNumber implements XMLElement<'tuplet-number', TupletNumberAttributes, TupletNumberContents> {
  static readonly schema = {
    name: 'tuplet-number',
    attributes: {
      color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
      'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
      'font-size': {
        type: 'optional',
        value: {
          type: 'choices',
          choices: [
            { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
            { type: 'float', min: -Infinity, max: Infinity },
          ],
        },
      },
      'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
      'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
    },
    contents: [
      { type: 'label', label: 'value', value: { type: 'required', value: { type: 'int', min: 0, max: Infinity } } },
    ],
  } as const;

  readonly schema = TupletNumber.schema;

  attributes: TupletNumberAttributes;
  contents: TupletNumberContents;

  constructor(opts?: { attributes?: Partial<TupletNumberAttributes>; contents?: TupletNumberContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, TupletNumber.schema);
    this.contents = opts?.contents ?? operations.zero(TupletNumber.schema.contents);
  }
  getColor(): string | null {
    return this.attributes['color'];
  }
  setColor(color: string | null): TupletNumber {
    this.attributes['color'] = color;
    return this;
  }
  getFontFamily(): string | null {
    return this.attributes['font-family'];
  }
  setFontFamily(fontFamily: string | null): TupletNumber {
    this.attributes['font-family'] = fontFamily;
    return this;
  }
  getFontSize(): 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null {
    return this.attributes['font-size'];
  }
  setFontSize(
    fontSize: 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null
  ): TupletNumber {
    this.attributes['font-size'] = fontSize;
    return this;
  }
  getFontStyle(): 'normal' | 'italic' | null {
    return this.attributes['font-style'];
  }
  setFontStyle(fontStyle: 'normal' | 'italic' | null): TupletNumber {
    this.attributes['font-style'] = fontStyle;
    return this;
  }
  getFontWeight(): 'normal' | 'bold' | null {
    return this.attributes['font-weight'];
  }
  setFontWeight(fontWeight: 'normal' | 'bold' | null): TupletNumber {
    this.attributes['font-weight'] = fontWeight;
    return this;
  }
  getValue(): number {
    return this.contents[0];
  }
  setValue(value: number): TupletNumber {
    this.contents[0] = value;
    return this;
  }
}

export type TupletTypeAttributes = {
  color: string | null;
  'font-family': string | null;
  'font-size': 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null;
  'font-style': 'normal' | 'italic' | null;
  'font-weight': 'normal' | 'bold' | null;
};

export type TupletTypeContents = [
  | 'whole'
  | '1024th'
  | '512th'
  | '256th'
  | '128th'
  | '64th'
  | '32nd'
  | '16th'
  | 'eighth'
  | 'half'
  | 'quarter'
  | 'whole'
  | 'breve'
  | 'long'
  | 'maxima'
];

export class TupletType implements XMLElement<'tuplet-type', TupletTypeAttributes, TupletTypeContents> {
  static readonly schema = {
    name: 'tuplet-type',
    attributes: {
      color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
      'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
      'font-size': {
        type: 'optional',
        value: {
          type: 'choices',
          choices: [
            { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
            { type: 'float', min: -Infinity, max: Infinity },
          ],
        },
      },
      'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
      'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
    },
    contents: [
      {
        type: 'label',
        label: 'note-type-value',
        value: {
          type: 'choices',
          choices: [
            'whole',
            '1024th',
            '512th',
            '256th',
            '128th',
            '64th',
            '32nd',
            '16th',
            'eighth',
            'half',
            'quarter',
            'whole',
            'breve',
            'long',
            'maxima',
          ],
        },
      },
    ],
  } as const;

  readonly schema = TupletType.schema;

  attributes: TupletTypeAttributes;
  contents: TupletTypeContents;

  constructor(opts?: { attributes?: Partial<TupletTypeAttributes>; contents?: TupletTypeContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, TupletType.schema);
    this.contents = opts?.contents ?? operations.zero(TupletType.schema.contents);
  }
  getColor(): string | null {
    return this.attributes['color'];
  }
  setColor(color: string | null): TupletType {
    this.attributes['color'] = color;
    return this;
  }
  getFontFamily(): string | null {
    return this.attributes['font-family'];
  }
  setFontFamily(fontFamily: string | null): TupletType {
    this.attributes['font-family'] = fontFamily;
    return this;
  }
  getFontSize(): 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null {
    return this.attributes['font-size'];
  }
  setFontSize(
    fontSize: 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null
  ): TupletType {
    this.attributes['font-size'] = fontSize;
    return this;
  }
  getFontStyle(): 'normal' | 'italic' | null {
    return this.attributes['font-style'];
  }
  setFontStyle(fontStyle: 'normal' | 'italic' | null): TupletType {
    this.attributes['font-style'] = fontStyle;
    return this;
  }
  getFontWeight(): 'normal' | 'bold' | null {
    return this.attributes['font-weight'];
  }
  setFontWeight(fontWeight: 'normal' | 'bold' | null): TupletType {
    this.attributes['font-weight'] = fontWeight;
    return this;
  }
  getNoteTypeValue():
    | 'whole'
    | '1024th'
    | '512th'
    | '256th'
    | '128th'
    | '64th'
    | '32nd'
    | '16th'
    | 'eighth'
    | 'half'
    | 'quarter'
    | 'whole'
    | 'breve'
    | 'long'
    | 'maxima' {
    return this.contents[0];
  }
  setNoteTypeValue(
    noteTypeValue:
      | 'whole'
      | '1024th'
      | '512th'
      | '256th'
      | '128th'
      | '64th'
      | '32nd'
      | '16th'
      | 'eighth'
      | 'half'
      | 'quarter'
      | 'whole'
      | 'breve'
      | 'long'
      | 'maxima'
  ): TupletType {
    this.contents[0] = noteTypeValue;
    return this;
  }
}

export type TupletDotAttributes = {
  color: string | null;
  'font-family': string | null;
  'font-size': 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null;
  'font-style': 'normal' | 'italic' | null;
  'font-weight': 'normal' | 'bold' | null;
};

export type TupletDotContents = [];

export class TupletDot implements XMLElement<'tuplet-dot', TupletDotAttributes, TupletDotContents> {
  static readonly schema = {
    name: 'tuplet-dot',
    attributes: {
      color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
      'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
      'font-size': {
        type: 'optional',
        value: {
          type: 'choices',
          choices: [
            { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
            { type: 'float', min: -Infinity, max: Infinity },
          ],
        },
      },
      'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
      'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
    },
    contents: [],
  } as const;

  readonly schema = TupletDot.schema;

  attributes: TupletDotAttributes;
  contents: TupletDotContents;

  constructor(opts?: { attributes?: Partial<TupletDotAttributes>; contents?: TupletDotContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, TupletDot.schema);
    this.contents = opts?.contents ?? operations.zero(TupletDot.schema.contents);
  }
  getColor(): string | null {
    return this.attributes['color'];
  }
  setColor(color: string | null): TupletDot {
    this.attributes['color'] = color;
    return this;
  }
  getFontFamily(): string | null {
    return this.attributes['font-family'];
  }
  setFontFamily(fontFamily: string | null): TupletDot {
    this.attributes['font-family'] = fontFamily;
    return this;
  }
  getFontSize(): 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null {
    return this.attributes['font-size'];
  }
  setFontSize(
    fontSize: 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null
  ): TupletDot {
    this.attributes['font-size'] = fontSize;
    return this;
  }
  getFontStyle(): 'normal' | 'italic' | null {
    return this.attributes['font-style'];
  }
  setFontStyle(fontStyle: 'normal' | 'italic' | null): TupletDot {
    this.attributes['font-style'] = fontStyle;
    return this;
  }
  getFontWeight(): 'normal' | 'bold' | null {
    return this.attributes['font-weight'];
  }
  setFontWeight(fontWeight: 'normal' | 'bold' | null): TupletDot {
    this.attributes['font-weight'] = fontWeight;
    return this;
  }
}

export type TupletActualAttributes = Record<string, unknown>;

export type TupletActualContents = [TupletNumber | null, TupletType | null, Array<TupletDot>];

export class TupletActual implements XMLElement<'tuplet-actual', TupletActualAttributes, TupletActualContents> {
  static readonly schema = {
    name: 'tuplet-actual',
    attributes: {},
    contents: [
      { type: 'optional', value: TupletNumber },
      { type: 'optional', value: TupletType },
      { type: 'label', label: 'tuplet-dots', value: { type: 'zeroOrMore', value: TupletDot } },
    ],
  } as const;

  readonly schema = TupletActual.schema;

  attributes: TupletActualAttributes;
  contents: TupletActualContents;

  constructor(opts?: { attributes?: Partial<TupletActualAttributes>; contents?: TupletActualContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, TupletActual.schema);
    this.contents = opts?.contents ?? operations.zero(TupletActual.schema.contents);
  }

  getTupletNumber(): TupletNumber | null {
    return this.contents[0];
  }
  setTupletNumber(tupletNumber: TupletNumber | null): TupletActual {
    this.contents[0] = tupletNumber;
    return this;
  }
  getTupletType(): TupletType | null {
    return this.contents[1];
  }
  setTupletType(tupletType: TupletType | null): TupletActual {
    this.contents[1] = tupletType;
    return this;
  }
  getTupletDots(): Array<TupletDot> {
    return this.contents[2];
  }
  setTupletDots(tupletDots: Array<TupletDot>): TupletActual {
    this.contents[2] = tupletDots;
    return this;
  }
}

export type TupletNormalAttributes = Record<string, unknown>;

export type TupletNormalContents = [TupletNumber | null, TupletType | null, Array<TupletDot>];

export class TupletNormal implements XMLElement<'tuplet-normal', TupletNormalAttributes, TupletNormalContents> {
  static readonly schema = {
    name: 'tuplet-normal',
    attributes: {},
    contents: [
      { type: 'optional', value: TupletNumber },
      { type: 'optional', value: TupletType },
      { type: 'label', label: 'tuplet-dots', value: { type: 'zeroOrMore', value: TupletDot } },
    ],
  } as const;

  readonly schema = TupletNormal.schema;

  attributes: TupletNormalAttributes;
  contents: TupletNormalContents;

  constructor(opts?: { attributes?: Partial<TupletNormalAttributes>; contents?: TupletNormalContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, TupletNormal.schema);
    this.contents = opts?.contents ?? operations.zero(TupletNormal.schema.contents);
  }

  getTupletNumber(): TupletNumber | null {
    return this.contents[0];
  }
  setTupletNumber(tupletNumber: TupletNumber | null): TupletNormal {
    this.contents[0] = tupletNumber;
    return this;
  }
  getTupletType(): TupletType | null {
    return this.contents[1];
  }
  setTupletType(tupletType: TupletType | null): TupletNormal {
    this.contents[1] = tupletType;
    return this;
  }
  getTupletDots(): Array<TupletDot> {
    return this.contents[2];
  }
  setTupletDots(tupletDots: Array<TupletDot>): TupletNormal {
    this.contents[2] = tupletDots;
    return this;
  }
}

export type TupletAttributes = {
  type: 'start' | 'stop' | null;
  bracket: 'yes' | 'no' | null;
  'default-x': number | null;
  'default-y': number | null;
  id: string | null;
  'line-shape': 'straight' | 'curved' | null;
  number: number | null;
  placement: 'above' | 'below' | null;
  'relative-x': number | null;
  'relative-y': number | null;
  'show-number': 'none' | 'actual' | 'both' | null;
  'show-type': 'none' | 'actual' | 'both' | null;
};

export type TupletContents = [TupletActual | null, TupletNormal | null];

export class Tuplet implements XMLElement<'tuplet', TupletAttributes, TupletContents> {
  static readonly schema = {
    name: 'tuplet',
    attributes: {
      type: { type: 'optional', value: { type: 'choices', choices: ['start', 'stop'] } },
      bracket: { type: 'optional', value: { type: 'choices', choices: ['yes', 'no'] } },
      'default-x': {
        type: 'label',
        label: 'default-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'default-y': {
        type: 'label',
        label: 'default-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      id: { type: 'optional', value: { type: 'regex', pattern: /[A-Za-z_][A-Za-z0-9.-_]*/, zero: '_' } },
      'line-shape': { type: 'optional', value: { type: 'choices', choices: ['straight', 'curved'] } },
      number: { type: 'optional', value: { type: 'int', min: 1, max: 16 } },
      placement: { type: 'optional', value: { type: 'choices', choices: ['above', 'below'] } },
      'relative-x': {
        type: 'label',
        label: 'relative-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'relative-y': {
        type: 'label',
        label: 'relative-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'show-number': { type: 'optional', value: { type: 'choices', choices: ['none', 'actual', 'both'] } },
      'show-type': { type: 'optional', value: { type: 'choices', choices: ['none', 'actual', 'both'] } },
    },
    contents: [
      { type: 'optional', value: TupletActual },
      { type: 'optional', value: TupletNormal },
    ],
  } as const;

  readonly schema = Tuplet.schema;

  attributes: TupletAttributes;
  contents: TupletContents;

  constructor(opts?: { attributes?: Partial<TupletAttributes>; contents?: TupletContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Tuplet.schema);
    this.contents = opts?.contents ?? operations.zero(Tuplet.schema.contents);
  }
  getType(): 'start' | 'stop' | null {
    return this.attributes['type'];
  }
  setType(type: 'start' | 'stop' | null): Tuplet {
    this.attributes['type'] = type;
    return this;
  }
  getBracket(): 'yes' | 'no' | null {
    return this.attributes['bracket'];
  }
  setBracket(bracket: 'yes' | 'no' | null): Tuplet {
    this.attributes['bracket'] = bracket;
    return this;
  }
  getDefaultX(): number | null {
    return this.attributes['default-x'];
  }
  setDefaultX(defaultX: number | null): Tuplet {
    this.attributes['default-x'] = defaultX;
    return this;
  }
  getDefaultY(): number | null {
    return this.attributes['default-y'];
  }
  setDefaultY(defaultY: number | null): Tuplet {
    this.attributes['default-y'] = defaultY;
    return this;
  }
  getId(): string | null {
    return this.attributes['id'];
  }
  setId(id: string | null): Tuplet {
    this.attributes['id'] = id;
    return this;
  }
  getLineShape(): 'straight' | 'curved' | null {
    return this.attributes['line-shape'];
  }
  setLineShape(lineShape: 'straight' | 'curved' | null): Tuplet {
    this.attributes['line-shape'] = lineShape;
    return this;
  }
  getNumber(): number | null {
    return this.attributes['number'];
  }
  setNumber(number: number | null): Tuplet {
    this.attributes['number'] = number;
    return this;
  }
  getPlacement(): 'above' | 'below' | null {
    return this.attributes['placement'];
  }
  setPlacement(placement: 'above' | 'below' | null): Tuplet {
    this.attributes['placement'] = placement;
    return this;
  }
  getRelativeX(): number | null {
    return this.attributes['relative-x'];
  }
  setRelativeX(relativeX: number | null): Tuplet {
    this.attributes['relative-x'] = relativeX;
    return this;
  }
  getRelativeY(): number | null {
    return this.attributes['relative-y'];
  }
  setRelativeY(relativeY: number | null): Tuplet {
    this.attributes['relative-y'] = relativeY;
    return this;
  }
  getShowNumber(): 'none' | 'actual' | 'both' | null {
    return this.attributes['show-number'];
  }
  setShowNumber(showNumber: 'none' | 'actual' | 'both' | null): Tuplet {
    this.attributes['show-number'] = showNumber;
    return this;
  }
  getShowType(): 'none' | 'actual' | 'both' | null {
    return this.attributes['show-type'];
  }
  setShowType(showType: 'none' | 'actual' | 'both' | null): Tuplet {
    this.attributes['show-type'] = showType;
    return this;
  }
  getTupletActual(): TupletActual | null {
    return this.contents[0];
  }
  setTupletActual(tupletActual: TupletActual | null): Tuplet {
    this.contents[0] = tupletActual;
    return this;
  }
  getTupletNormal(): TupletNormal | null {
    return this.contents[1];
  }
  setTupletNormal(tupletNormal: TupletNormal | null): Tuplet {
    this.contents[1] = tupletNormal;
    return this;
  }
}

export type GlissandoAttributes = {
  type: 'start' | 'stop';
  color: string | null;
  'dash-length': number | null;
  'default-x': number | null;
  'default-y': number | null;
  'font-family': string | null;
  'font-size': 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null;
  'font-style': 'normal' | 'italic' | null;
  'font-weight': 'normal' | 'bold' | null;
  id: string | null;
  'line-type': 'dashed' | 'dotted' | 'solid' | 'wavy' | null;
  number: number | null;
  'relative-x': number | null;
  'relative-y': number | null;
  'space-length': number | null;
};

export type GlissandoContents = [string];

export class Glissando implements XMLElement<'glissando', GlissandoAttributes, GlissandoContents> {
  static readonly schema = {
    name: 'glissando',
    attributes: {
      type: { type: 'required', value: { type: 'choices', choices: ['start', 'stop'] } },
      color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
      'dash-length': { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      'default-x': {
        type: 'label',
        label: 'default-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'default-y': {
        type: 'label',
        label: 'default-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
      'font-size': {
        type: 'optional',
        value: {
          type: 'choices',
          choices: [
            { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
            { type: 'float', min: -Infinity, max: Infinity },
          ],
        },
      },
      'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
      'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
      id: { type: 'optional', value: { type: 'regex', pattern: /[A-Za-z_][A-Za-z0-9.-_]*/, zero: '_' } },
      'line-type': { type: 'optional', value: { type: 'choices', choices: ['dashed', 'dotted', 'solid', 'wavy'] } },
      number: { type: 'optional', value: { type: 'int', min: 1, max: 16 } },
      'relative-x': {
        type: 'label',
        label: 'relative-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'relative-y': {
        type: 'label',
        label: 'relative-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'space-length': { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
    },
    contents: [{ type: 'required', value: { type: 'string' } }],
  } as const;

  readonly schema = Glissando.schema;

  attributes: GlissandoAttributes;
  contents: GlissandoContents;

  constructor(opts?: { attributes?: Partial<GlissandoAttributes>; contents?: GlissandoContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Glissando.schema);
    this.contents = opts?.contents ?? operations.zero(Glissando.schema.contents);
  }
  getType(): 'start' | 'stop' {
    return this.attributes['type'];
  }
  setType(type: 'start' | 'stop'): Glissando {
    this.attributes['type'] = type;
    return this;
  }
  getColor(): string | null {
    return this.attributes['color'];
  }
  setColor(color: string | null): Glissando {
    this.attributes['color'] = color;
    return this;
  }
  getDashLength(): number | null {
    return this.attributes['dash-length'];
  }
  setDashLength(dashLength: number | null): Glissando {
    this.attributes['dash-length'] = dashLength;
    return this;
  }
  getDefaultX(): number | null {
    return this.attributes['default-x'];
  }
  setDefaultX(defaultX: number | null): Glissando {
    this.attributes['default-x'] = defaultX;
    return this;
  }
  getDefaultY(): number | null {
    return this.attributes['default-y'];
  }
  setDefaultY(defaultY: number | null): Glissando {
    this.attributes['default-y'] = defaultY;
    return this;
  }
  getFontFamily(): string | null {
    return this.attributes['font-family'];
  }
  setFontFamily(fontFamily: string | null): Glissando {
    this.attributes['font-family'] = fontFamily;
    return this;
  }
  getFontSize(): 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null {
    return this.attributes['font-size'];
  }
  setFontSize(
    fontSize: 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null
  ): Glissando {
    this.attributes['font-size'] = fontSize;
    return this;
  }
  getFontStyle(): 'normal' | 'italic' | null {
    return this.attributes['font-style'];
  }
  setFontStyle(fontStyle: 'normal' | 'italic' | null): Glissando {
    this.attributes['font-style'] = fontStyle;
    return this;
  }
  getFontWeight(): 'normal' | 'bold' | null {
    return this.attributes['font-weight'];
  }
  setFontWeight(fontWeight: 'normal' | 'bold' | null): Glissando {
    this.attributes['font-weight'] = fontWeight;
    return this;
  }
  getId(): string | null {
    return this.attributes['id'];
  }
  setId(id: string | null): Glissando {
    this.attributes['id'] = id;
    return this;
  }
  getLineType(): 'dashed' | 'dotted' | 'solid' | 'wavy' | null {
    return this.attributes['line-type'];
  }
  setLineType(lineType: 'dashed' | 'dotted' | 'solid' | 'wavy' | null): Glissando {
    this.attributes['line-type'] = lineType;
    return this;
  }
  getNumber(): number | null {
    return this.attributes['number'];
  }
  setNumber(number: number | null): Glissando {
    this.attributes['number'] = number;
    return this;
  }
  getRelativeX(): number | null {
    return this.attributes['relative-x'];
  }
  setRelativeX(relativeX: number | null): Glissando {
    this.attributes['relative-x'] = relativeX;
    return this;
  }
  getRelativeY(): number | null {
    return this.attributes['relative-y'];
  }
  setRelativeY(relativeY: number | null): Glissando {
    this.attributes['relative-y'] = relativeY;
    return this;
  }
  getSpaceLength(): number | null {
    return this.attributes['space-length'];
  }
  setSpaceLength(spaceLength: number | null): Glissando {
    this.attributes['space-length'] = spaceLength;
    return this;
  }
  getText(): string {
    return this.contents[0];
  }
  setText(text: string): Glissando {
    this.contents[0] = text;
    return this;
  }
}

export type SlideAttributes = {
  type: 'start' | 'stop';
  accelerate: 'yes' | 'no' | null;
  beats: number | null;
  color: string | null;
  'dash-length': number | null;
  'default-x': number | null;
  'default-y': number | null;
  'first-beat': number | null;
  'font-family': string | null;
  'font-size': 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null;
  'font-style': 'normal' | 'italic' | null;
  'font-weight': 'normal' | 'bold' | null;
  id: string | null;
  'last-beat': number | null;
  'line-type': 'dashed' | 'dotted' | 'solid' | 'wavy' | null;
  number: number | null;
  'relative-x': number | null;
  'relative-y': number | null;
  'space-length': number | null;
};

export type SlideContents = [string];

export class Slide implements XMLElement<'slide', SlideAttributes, SlideContents> {
  static readonly schema = {
    name: 'slide',
    attributes: {
      type: { type: 'required', value: { type: 'choices', choices: ['start', 'stop'] } },
      accelerate: { type: 'optional', value: { type: 'choices', choices: ['yes', 'no'] } },
      beats: { type: 'optional', value: { type: 'float', min: 2, max: Infinity } },
      color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
      'dash-length': { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      'default-x': {
        type: 'label',
        label: 'default-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'default-y': {
        type: 'label',
        label: 'default-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'first-beat': { type: 'optional', value: { type: 'float', min: 0, max: 100 } },
      'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
      'font-size': {
        type: 'optional',
        value: {
          type: 'choices',
          choices: [
            { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
            { type: 'float', min: -Infinity, max: Infinity },
          ],
        },
      },
      'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
      'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
      id: { type: 'optional', value: { type: 'regex', pattern: /[A-Za-z_][A-Za-z0-9.-_]*/, zero: '_' } },
      'last-beat': { type: 'optional', value: { type: 'float', min: 0, max: 100 } },
      'line-type': { type: 'optional', value: { type: 'choices', choices: ['dashed', 'dotted', 'solid', 'wavy'] } },
      number: { type: 'optional', value: { type: 'int', min: 1, max: 16 } },
      'relative-x': {
        type: 'label',
        label: 'relative-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'relative-y': {
        type: 'label',
        label: 'relative-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'space-length': { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
    },
    contents: [{ type: 'required', value: { type: 'string' } }],
  } as const;

  readonly schema = Slide.schema;

  attributes: SlideAttributes;
  contents: SlideContents;

  constructor(opts?: { attributes?: Partial<SlideAttributes>; contents?: SlideContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Slide.schema);
    this.contents = opts?.contents ?? operations.zero(Slide.schema.contents);
  }
  getType(): 'start' | 'stop' {
    return this.attributes['type'];
  }
  setType(type: 'start' | 'stop'): Slide {
    this.attributes['type'] = type;
    return this;
  }
  getAccelerate(): 'yes' | 'no' | null {
    return this.attributes['accelerate'];
  }
  setAccelerate(accelerate: 'yes' | 'no' | null): Slide {
    this.attributes['accelerate'] = accelerate;
    return this;
  }
  getBeats(): number | null {
    return this.attributes['beats'];
  }
  setBeats(beats: number | null): Slide {
    this.attributes['beats'] = beats;
    return this;
  }
  getColor(): string | null {
    return this.attributes['color'];
  }
  setColor(color: string | null): Slide {
    this.attributes['color'] = color;
    return this;
  }
  getDashLength(): number | null {
    return this.attributes['dash-length'];
  }
  setDashLength(dashLength: number | null): Slide {
    this.attributes['dash-length'] = dashLength;
    return this;
  }
  getDefaultX(): number | null {
    return this.attributes['default-x'];
  }
  setDefaultX(defaultX: number | null): Slide {
    this.attributes['default-x'] = defaultX;
    return this;
  }
  getDefaultY(): number | null {
    return this.attributes['default-y'];
  }
  setDefaultY(defaultY: number | null): Slide {
    this.attributes['default-y'] = defaultY;
    return this;
  }
  getFirstBeat(): number | null {
    return this.attributes['first-beat'];
  }
  setFirstBeat(firstBeat: number | null): Slide {
    this.attributes['first-beat'] = firstBeat;
    return this;
  }
  getFontFamily(): string | null {
    return this.attributes['font-family'];
  }
  setFontFamily(fontFamily: string | null): Slide {
    this.attributes['font-family'] = fontFamily;
    return this;
  }
  getFontSize(): 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null {
    return this.attributes['font-size'];
  }
  setFontSize(
    fontSize: 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null
  ): Slide {
    this.attributes['font-size'] = fontSize;
    return this;
  }
  getFontStyle(): 'normal' | 'italic' | null {
    return this.attributes['font-style'];
  }
  setFontStyle(fontStyle: 'normal' | 'italic' | null): Slide {
    this.attributes['font-style'] = fontStyle;
    return this;
  }
  getFontWeight(): 'normal' | 'bold' | null {
    return this.attributes['font-weight'];
  }
  setFontWeight(fontWeight: 'normal' | 'bold' | null): Slide {
    this.attributes['font-weight'] = fontWeight;
    return this;
  }
  getId(): string | null {
    return this.attributes['id'];
  }
  setId(id: string | null): Slide {
    this.attributes['id'] = id;
    return this;
  }
  getLastBeat(): number | null {
    return this.attributes['last-beat'];
  }
  setLastBeat(lastBeat: number | null): Slide {
    this.attributes['last-beat'] = lastBeat;
    return this;
  }
  getLineType(): 'dashed' | 'dotted' | 'solid' | 'wavy' | null {
    return this.attributes['line-type'];
  }
  setLineType(lineType: 'dashed' | 'dotted' | 'solid' | 'wavy' | null): Slide {
    this.attributes['line-type'] = lineType;
    return this;
  }
  getNumber(): number | null {
    return this.attributes['number'];
  }
  setNumber(number: number | null): Slide {
    this.attributes['number'] = number;
    return this;
  }
  getRelativeX(): number | null {
    return this.attributes['relative-x'];
  }
  setRelativeX(relativeX: number | null): Slide {
    this.attributes['relative-x'] = relativeX;
    return this;
  }
  getRelativeY(): number | null {
    return this.attributes['relative-y'];
  }
  setRelativeY(relativeY: number | null): Slide {
    this.attributes['relative-y'] = relativeY;
    return this;
  }
  getSpaceLength(): number | null {
    return this.attributes['space-length'];
  }
  setSpaceLength(spaceLength: number | null): Slide {
    this.attributes['space-length'] = spaceLength;
    return this;
  }
  getText(): string {
    return this.contents[0];
  }
  setText(text: string): Slide {
    this.contents[0] = text;
    return this;
  }
}

export type TrillMarkAttributes = {
  acccelerate: 'yes' | 'no' | null;
  beats: number | null;
  color: string | null;
  'default-x': number | null;
  'default-y': number | null;
  'font-family': string | null;
  'font-size': 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null;
  'font-style': 'normal' | 'italic' | null;
  'font-weight': 'normal' | 'bold' | null;
  'last-beat': number | null;
  placement: 'above' | 'below' | null;
  'relative-x': number | null;
  'relative-y': number | null;
  'second-beat': number | null;
  'start-note': 'below' | 'main' | 'upper' | null;
  'trill-step': 'unison' | 'half' | 'whole' | null;
  'two-note-turn': 'none' | 'whole' | 'half' | null;
};

export type TrillMarkContents = [];

export class TrillMark implements XMLElement<'trill-mark', TrillMarkAttributes, TrillMarkContents> {
  static readonly schema = {
    name: 'trill-mark',
    attributes: {
      acccelerate: { type: 'optional', value: { type: 'choices', choices: ['yes', 'no'] } },
      beats: { type: 'optional', value: { type: 'float', min: 2, max: Infinity } },
      color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
      'default-x': {
        type: 'label',
        label: 'default-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'default-y': {
        type: 'label',
        label: 'default-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
      'font-size': {
        type: 'optional',
        value: {
          type: 'choices',
          choices: [
            { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
            { type: 'float', min: -Infinity, max: Infinity },
          ],
        },
      },
      'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
      'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
      'last-beat': { type: 'optional', value: { type: 'float', min: 0, max: 100 } },
      placement: { type: 'optional', value: { type: 'choices', choices: ['above', 'below'] } },
      'relative-x': {
        type: 'label',
        label: 'relative-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'relative-y': {
        type: 'label',
        label: 'relative-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'second-beat': { type: 'optional', value: { type: 'float', min: 0, max: 100 } },
      'start-note': { type: 'optional', value: { type: 'choices', choices: ['below', 'main', 'upper'] } },
      'trill-step': { type: 'optional', value: { type: 'choices', choices: ['unison', 'half', 'whole'] } },
      'two-note-turn': { type: 'optional', value: { type: 'choices', choices: ['none', 'whole', 'half'] } },
    },
    contents: [],
  } as const;

  readonly schema = TrillMark.schema;

  attributes: TrillMarkAttributes;
  contents: TrillMarkContents;

  constructor(opts?: { attributes?: Partial<TrillMarkAttributes>; contents?: TrillMarkContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, TrillMark.schema);
    this.contents = opts?.contents ?? operations.zero(TrillMark.schema.contents);
  }
  getAcccelerate(): 'yes' | 'no' | null {
    return this.attributes['acccelerate'];
  }
  setAcccelerate(acccelerate: 'yes' | 'no' | null): TrillMark {
    this.attributes['acccelerate'] = acccelerate;
    return this;
  }
  getBeats(): number | null {
    return this.attributes['beats'];
  }
  setBeats(beats: number | null): TrillMark {
    this.attributes['beats'] = beats;
    return this;
  }
  getColor(): string | null {
    return this.attributes['color'];
  }
  setColor(color: string | null): TrillMark {
    this.attributes['color'] = color;
    return this;
  }
  getDefaultX(): number | null {
    return this.attributes['default-x'];
  }
  setDefaultX(defaultX: number | null): TrillMark {
    this.attributes['default-x'] = defaultX;
    return this;
  }
  getDefaultY(): number | null {
    return this.attributes['default-y'];
  }
  setDefaultY(defaultY: number | null): TrillMark {
    this.attributes['default-y'] = defaultY;
    return this;
  }
  getFontFamily(): string | null {
    return this.attributes['font-family'];
  }
  setFontFamily(fontFamily: string | null): TrillMark {
    this.attributes['font-family'] = fontFamily;
    return this;
  }
  getFontSize(): 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null {
    return this.attributes['font-size'];
  }
  setFontSize(
    fontSize: 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null
  ): TrillMark {
    this.attributes['font-size'] = fontSize;
    return this;
  }
  getFontStyle(): 'normal' | 'italic' | null {
    return this.attributes['font-style'];
  }
  setFontStyle(fontStyle: 'normal' | 'italic' | null): TrillMark {
    this.attributes['font-style'] = fontStyle;
    return this;
  }
  getFontWeight(): 'normal' | 'bold' | null {
    return this.attributes['font-weight'];
  }
  setFontWeight(fontWeight: 'normal' | 'bold' | null): TrillMark {
    this.attributes['font-weight'] = fontWeight;
    return this;
  }
  getLastBeat(): number | null {
    return this.attributes['last-beat'];
  }
  setLastBeat(lastBeat: number | null): TrillMark {
    this.attributes['last-beat'] = lastBeat;
    return this;
  }
  getPlacement(): 'above' | 'below' | null {
    return this.attributes['placement'];
  }
  setPlacement(placement: 'above' | 'below' | null): TrillMark {
    this.attributes['placement'] = placement;
    return this;
  }
  getRelativeX(): number | null {
    return this.attributes['relative-x'];
  }
  setRelativeX(relativeX: number | null): TrillMark {
    this.attributes['relative-x'] = relativeX;
    return this;
  }
  getRelativeY(): number | null {
    return this.attributes['relative-y'];
  }
  setRelativeY(relativeY: number | null): TrillMark {
    this.attributes['relative-y'] = relativeY;
    return this;
  }
  getSecondBeat(): number | null {
    return this.attributes['second-beat'];
  }
  setSecondBeat(secondBeat: number | null): TrillMark {
    this.attributes['second-beat'] = secondBeat;
    return this;
  }
  getStartNote(): 'below' | 'main' | 'upper' | null {
    return this.attributes['start-note'];
  }
  setStartNote(startNote: 'below' | 'main' | 'upper' | null): TrillMark {
    this.attributes['start-note'] = startNote;
    return this;
  }
  getTrillStep(): 'unison' | 'half' | 'whole' | null {
    return this.attributes['trill-step'];
  }
  setTrillStep(trillStep: 'unison' | 'half' | 'whole' | null): TrillMark {
    this.attributes['trill-step'] = trillStep;
    return this;
  }
  getTwoNoteTurn(): 'none' | 'whole' | 'half' | null {
    return this.attributes['two-note-turn'];
  }
  setTwoNoteTurn(twoNoteTurn: 'none' | 'whole' | 'half' | null): TrillMark {
    this.attributes['two-note-turn'] = twoNoteTurn;
    return this;
  }
}

export type TurnAttributes = {
  accelerate: 'yes' | 'no' | null;
  beats: number | null;
  color: string | null;
  'default-x': number | null;
  'default-y': number | null;
  'font-family': string | null;
  'font-size': 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null;
  'font-style': 'normal' | 'italic' | null;
  'font-weight': 'normal' | 'bold' | null;
  'last-beat': number | null;
  placement: 'above' | 'below' | null;
  'relative-x': number | null;
  'relative-y': number | null;
  'second-beat': number | null;
  slash: 'yes' | 'no' | null;
  'start-note': 'below' | 'main' | 'upper' | null;
  'trill-step': 'unison' | 'half' | 'whole' | null;
  'two-note-turn': 'none' | 'whole' | 'half' | null;
};

export type TurnContents = [];

export class Turn implements XMLElement<'turn', TurnAttributes, TurnContents> {
  static readonly schema = {
    name: 'turn',
    attributes: {
      accelerate: { type: 'optional', value: { type: 'choices', choices: ['yes', 'no'] } },
      beats: { type: 'optional', value: { type: 'float', min: 2, max: Infinity } },
      color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
      'default-x': {
        type: 'label',
        label: 'default-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'default-y': {
        type: 'label',
        label: 'default-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
      'font-size': {
        type: 'optional',
        value: {
          type: 'choices',
          choices: [
            { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
            { type: 'float', min: -Infinity, max: Infinity },
          ],
        },
      },
      'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
      'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
      'last-beat': { type: 'optional', value: { type: 'float', min: 0, max: 100 } },
      placement: { type: 'optional', value: { type: 'choices', choices: ['above', 'below'] } },
      'relative-x': {
        type: 'label',
        label: 'relative-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'relative-y': {
        type: 'label',
        label: 'relative-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'second-beat': { type: 'optional', value: { type: 'float', min: 0, max: 100 } },
      slash: { type: 'optional', value: { type: 'choices', choices: ['yes', 'no'] } },
      'start-note': { type: 'optional', value: { type: 'choices', choices: ['below', 'main', 'upper'] } },
      'trill-step': { type: 'optional', value: { type: 'choices', choices: ['unison', 'half', 'whole'] } },
      'two-note-turn': { type: 'optional', value: { type: 'choices', choices: ['none', 'whole', 'half'] } },
    },
    contents: [],
  } as const;

  readonly schema = Turn.schema;

  attributes: TurnAttributes;
  contents: TurnContents;

  constructor(opts?: { attributes?: Partial<TurnAttributes>; contents?: TurnContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Turn.schema);
    this.contents = opts?.contents ?? operations.zero(Turn.schema.contents);
  }
  getAccelerate(): 'yes' | 'no' | null {
    return this.attributes['accelerate'];
  }
  setAccelerate(accelerate: 'yes' | 'no' | null): Turn {
    this.attributes['accelerate'] = accelerate;
    return this;
  }
  getBeats(): number | null {
    return this.attributes['beats'];
  }
  setBeats(beats: number | null): Turn {
    this.attributes['beats'] = beats;
    return this;
  }
  getColor(): string | null {
    return this.attributes['color'];
  }
  setColor(color: string | null): Turn {
    this.attributes['color'] = color;
    return this;
  }
  getDefaultX(): number | null {
    return this.attributes['default-x'];
  }
  setDefaultX(defaultX: number | null): Turn {
    this.attributes['default-x'] = defaultX;
    return this;
  }
  getDefaultY(): number | null {
    return this.attributes['default-y'];
  }
  setDefaultY(defaultY: number | null): Turn {
    this.attributes['default-y'] = defaultY;
    return this;
  }
  getFontFamily(): string | null {
    return this.attributes['font-family'];
  }
  setFontFamily(fontFamily: string | null): Turn {
    this.attributes['font-family'] = fontFamily;
    return this;
  }
  getFontSize(): 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null {
    return this.attributes['font-size'];
  }
  setFontSize(
    fontSize: 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null
  ): Turn {
    this.attributes['font-size'] = fontSize;
    return this;
  }
  getFontStyle(): 'normal' | 'italic' | null {
    return this.attributes['font-style'];
  }
  setFontStyle(fontStyle: 'normal' | 'italic' | null): Turn {
    this.attributes['font-style'] = fontStyle;
    return this;
  }
  getFontWeight(): 'normal' | 'bold' | null {
    return this.attributes['font-weight'];
  }
  setFontWeight(fontWeight: 'normal' | 'bold' | null): Turn {
    this.attributes['font-weight'] = fontWeight;
    return this;
  }
  getLastBeat(): number | null {
    return this.attributes['last-beat'];
  }
  setLastBeat(lastBeat: number | null): Turn {
    this.attributes['last-beat'] = lastBeat;
    return this;
  }
  getPlacement(): 'above' | 'below' | null {
    return this.attributes['placement'];
  }
  setPlacement(placement: 'above' | 'below' | null): Turn {
    this.attributes['placement'] = placement;
    return this;
  }
  getRelativeX(): number | null {
    return this.attributes['relative-x'];
  }
  setRelativeX(relativeX: number | null): Turn {
    this.attributes['relative-x'] = relativeX;
    return this;
  }
  getRelativeY(): number | null {
    return this.attributes['relative-y'];
  }
  setRelativeY(relativeY: number | null): Turn {
    this.attributes['relative-y'] = relativeY;
    return this;
  }
  getSecondBeat(): number | null {
    return this.attributes['second-beat'];
  }
  setSecondBeat(secondBeat: number | null): Turn {
    this.attributes['second-beat'] = secondBeat;
    return this;
  }
  getSlash(): 'yes' | 'no' | null {
    return this.attributes['slash'];
  }
  setSlash(slash: 'yes' | 'no' | null): Turn {
    this.attributes['slash'] = slash;
    return this;
  }
  getStartNote(): 'below' | 'main' | 'upper' | null {
    return this.attributes['start-note'];
  }
  setStartNote(startNote: 'below' | 'main' | 'upper' | null): Turn {
    this.attributes['start-note'] = startNote;
    return this;
  }
  getTrillStep(): 'unison' | 'half' | 'whole' | null {
    return this.attributes['trill-step'];
  }
  setTrillStep(trillStep: 'unison' | 'half' | 'whole' | null): Turn {
    this.attributes['trill-step'] = trillStep;
    return this;
  }
  getTwoNoteTurn(): 'none' | 'whole' | 'half' | null {
    return this.attributes['two-note-turn'];
  }
  setTwoNoteTurn(twoNoteTurn: 'none' | 'whole' | 'half' | null): Turn {
    this.attributes['two-note-turn'] = twoNoteTurn;
    return this;
  }
}

export type DelayedTurnAttributes = {
  accelerate: 'yes' | 'no' | null;
  beats: number | null;
  color: string | null;
  'default-x': number | null;
  'default-y': number | null;
  'font-family': string | null;
  'font-size': 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null;
  'font-style': 'normal' | 'italic' | null;
  'font-weight': 'normal' | 'bold' | null;
  'last-beat': number | null;
  placement: 'above' | 'below' | null;
  'relative-x': number | null;
  'relative-y': number | null;
  'second-beat': number | null;
  slash: 'yes' | 'no' | null;
  'start-note': 'below' | 'main' | 'upper' | null;
  'trill-step': 'unison' | 'half' | 'whole' | null;
  'two-note-turn': 'none' | 'whole' | 'half' | null;
};

export type DelayedTurnContents = [];

export class DelayedTurn implements XMLElement<'delayed-turn', DelayedTurnAttributes, DelayedTurnContents> {
  static readonly schema = {
    name: 'delayed-turn',
    attributes: {
      accelerate: { type: 'optional', value: { type: 'choices', choices: ['yes', 'no'] } },
      beats: { type: 'optional', value: { type: 'float', min: 2, max: Infinity } },
      color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
      'default-x': {
        type: 'label',
        label: 'default-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'default-y': {
        type: 'label',
        label: 'default-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
      'font-size': {
        type: 'optional',
        value: {
          type: 'choices',
          choices: [
            { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
            { type: 'float', min: -Infinity, max: Infinity },
          ],
        },
      },
      'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
      'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
      'last-beat': { type: 'optional', value: { type: 'float', min: 0, max: 100 } },
      placement: { type: 'optional', value: { type: 'choices', choices: ['above', 'below'] } },
      'relative-x': {
        type: 'label',
        label: 'relative-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'relative-y': {
        type: 'label',
        label: 'relative-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'second-beat': { type: 'optional', value: { type: 'float', min: 0, max: 100 } },
      slash: { type: 'optional', value: { type: 'choices', choices: ['yes', 'no'] } },
      'start-note': { type: 'optional', value: { type: 'choices', choices: ['below', 'main', 'upper'] } },
      'trill-step': { type: 'optional', value: { type: 'choices', choices: ['unison', 'half', 'whole'] } },
      'two-note-turn': { type: 'optional', value: { type: 'choices', choices: ['none', 'whole', 'half'] } },
    },
    contents: [],
  } as const;

  readonly schema = DelayedTurn.schema;

  attributes: DelayedTurnAttributes;
  contents: DelayedTurnContents;

  constructor(opts?: { attributes?: Partial<DelayedTurnAttributes>; contents?: DelayedTurnContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, DelayedTurn.schema);
    this.contents = opts?.contents ?? operations.zero(DelayedTurn.schema.contents);
  }
  getAccelerate(): 'yes' | 'no' | null {
    return this.attributes['accelerate'];
  }
  setAccelerate(accelerate: 'yes' | 'no' | null): DelayedTurn {
    this.attributes['accelerate'] = accelerate;
    return this;
  }
  getBeats(): number | null {
    return this.attributes['beats'];
  }
  setBeats(beats: number | null): DelayedTurn {
    this.attributes['beats'] = beats;
    return this;
  }
  getColor(): string | null {
    return this.attributes['color'];
  }
  setColor(color: string | null): DelayedTurn {
    this.attributes['color'] = color;
    return this;
  }
  getDefaultX(): number | null {
    return this.attributes['default-x'];
  }
  setDefaultX(defaultX: number | null): DelayedTurn {
    this.attributes['default-x'] = defaultX;
    return this;
  }
  getDefaultY(): number | null {
    return this.attributes['default-y'];
  }
  setDefaultY(defaultY: number | null): DelayedTurn {
    this.attributes['default-y'] = defaultY;
    return this;
  }
  getFontFamily(): string | null {
    return this.attributes['font-family'];
  }
  setFontFamily(fontFamily: string | null): DelayedTurn {
    this.attributes['font-family'] = fontFamily;
    return this;
  }
  getFontSize(): 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null {
    return this.attributes['font-size'];
  }
  setFontSize(
    fontSize: 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null
  ): DelayedTurn {
    this.attributes['font-size'] = fontSize;
    return this;
  }
  getFontStyle(): 'normal' | 'italic' | null {
    return this.attributes['font-style'];
  }
  setFontStyle(fontStyle: 'normal' | 'italic' | null): DelayedTurn {
    this.attributes['font-style'] = fontStyle;
    return this;
  }
  getFontWeight(): 'normal' | 'bold' | null {
    return this.attributes['font-weight'];
  }
  setFontWeight(fontWeight: 'normal' | 'bold' | null): DelayedTurn {
    this.attributes['font-weight'] = fontWeight;
    return this;
  }
  getLastBeat(): number | null {
    return this.attributes['last-beat'];
  }
  setLastBeat(lastBeat: number | null): DelayedTurn {
    this.attributes['last-beat'] = lastBeat;
    return this;
  }
  getPlacement(): 'above' | 'below' | null {
    return this.attributes['placement'];
  }
  setPlacement(placement: 'above' | 'below' | null): DelayedTurn {
    this.attributes['placement'] = placement;
    return this;
  }
  getRelativeX(): number | null {
    return this.attributes['relative-x'];
  }
  setRelativeX(relativeX: number | null): DelayedTurn {
    this.attributes['relative-x'] = relativeX;
    return this;
  }
  getRelativeY(): number | null {
    return this.attributes['relative-y'];
  }
  setRelativeY(relativeY: number | null): DelayedTurn {
    this.attributes['relative-y'] = relativeY;
    return this;
  }
  getSecondBeat(): number | null {
    return this.attributes['second-beat'];
  }
  setSecondBeat(secondBeat: number | null): DelayedTurn {
    this.attributes['second-beat'] = secondBeat;
    return this;
  }
  getSlash(): 'yes' | 'no' | null {
    return this.attributes['slash'];
  }
  setSlash(slash: 'yes' | 'no' | null): DelayedTurn {
    this.attributes['slash'] = slash;
    return this;
  }
  getStartNote(): 'below' | 'main' | 'upper' | null {
    return this.attributes['start-note'];
  }
  setStartNote(startNote: 'below' | 'main' | 'upper' | null): DelayedTurn {
    this.attributes['start-note'] = startNote;
    return this;
  }
  getTrillStep(): 'unison' | 'half' | 'whole' | null {
    return this.attributes['trill-step'];
  }
  setTrillStep(trillStep: 'unison' | 'half' | 'whole' | null): DelayedTurn {
    this.attributes['trill-step'] = trillStep;
    return this;
  }
  getTwoNoteTurn(): 'none' | 'whole' | 'half' | null {
    return this.attributes['two-note-turn'];
  }
  setTwoNoteTurn(twoNoteTurn: 'none' | 'whole' | 'half' | null): DelayedTurn {
    this.attributes['two-note-turn'] = twoNoteTurn;
    return this;
  }
}

export type InvertedTurnAttributes = {
  accelerate: 'yes' | 'no' | null;
  beats: number | null;
  color: string | null;
  'default-x': number | null;
  'default-y': number | null;
  'font-family': string | null;
  'font-size': 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null;
  'font-style': 'normal' | 'italic' | null;
  'font-weight': 'normal' | 'bold' | null;
  'last-beat': number | null;
  placement: 'above' | 'below' | null;
  'relative-x': number | null;
  'relative-y': number | null;
  'second-beat': number | null;
  slash: 'yes' | 'no' | null;
  'start-note': 'below' | 'main' | 'upper' | null;
  'trill-step': 'unison' | 'half' | 'whole' | null;
  'two-note-turn': 'none' | 'whole' | 'half' | null;
};

export type InvertedTurnContents = [];

export class InvertedTurn implements XMLElement<'inverted-turn', InvertedTurnAttributes, InvertedTurnContents> {
  static readonly schema = {
    name: 'inverted-turn',
    attributes: {
      accelerate: { type: 'optional', value: { type: 'choices', choices: ['yes', 'no'] } },
      beats: { type: 'optional', value: { type: 'float', min: 2, max: Infinity } },
      color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
      'default-x': {
        type: 'label',
        label: 'default-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'default-y': {
        type: 'label',
        label: 'default-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
      'font-size': {
        type: 'optional',
        value: {
          type: 'choices',
          choices: [
            { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
            { type: 'float', min: -Infinity, max: Infinity },
          ],
        },
      },
      'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
      'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
      'last-beat': { type: 'optional', value: { type: 'float', min: 0, max: 100 } },
      placement: { type: 'optional', value: { type: 'choices', choices: ['above', 'below'] } },
      'relative-x': {
        type: 'label',
        label: 'relative-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'relative-y': {
        type: 'label',
        label: 'relative-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'second-beat': { type: 'optional', value: { type: 'float', min: 0, max: 100 } },
      slash: { type: 'optional', value: { type: 'choices', choices: ['yes', 'no'] } },
      'start-note': { type: 'optional', value: { type: 'choices', choices: ['below', 'main', 'upper'] } },
      'trill-step': { type: 'optional', value: { type: 'choices', choices: ['unison', 'half', 'whole'] } },
      'two-note-turn': { type: 'optional', value: { type: 'choices', choices: ['none', 'whole', 'half'] } },
    },
    contents: [],
  } as const;

  readonly schema = InvertedTurn.schema;

  attributes: InvertedTurnAttributes;
  contents: InvertedTurnContents;

  constructor(opts?: { attributes?: Partial<InvertedTurnAttributes>; contents?: InvertedTurnContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, InvertedTurn.schema);
    this.contents = opts?.contents ?? operations.zero(InvertedTurn.schema.contents);
  }
  getAccelerate(): 'yes' | 'no' | null {
    return this.attributes['accelerate'];
  }
  setAccelerate(accelerate: 'yes' | 'no' | null): InvertedTurn {
    this.attributes['accelerate'] = accelerate;
    return this;
  }
  getBeats(): number | null {
    return this.attributes['beats'];
  }
  setBeats(beats: number | null): InvertedTurn {
    this.attributes['beats'] = beats;
    return this;
  }
  getColor(): string | null {
    return this.attributes['color'];
  }
  setColor(color: string | null): InvertedTurn {
    this.attributes['color'] = color;
    return this;
  }
  getDefaultX(): number | null {
    return this.attributes['default-x'];
  }
  setDefaultX(defaultX: number | null): InvertedTurn {
    this.attributes['default-x'] = defaultX;
    return this;
  }
  getDefaultY(): number | null {
    return this.attributes['default-y'];
  }
  setDefaultY(defaultY: number | null): InvertedTurn {
    this.attributes['default-y'] = defaultY;
    return this;
  }
  getFontFamily(): string | null {
    return this.attributes['font-family'];
  }
  setFontFamily(fontFamily: string | null): InvertedTurn {
    this.attributes['font-family'] = fontFamily;
    return this;
  }
  getFontSize(): 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null {
    return this.attributes['font-size'];
  }
  setFontSize(
    fontSize: 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null
  ): InvertedTurn {
    this.attributes['font-size'] = fontSize;
    return this;
  }
  getFontStyle(): 'normal' | 'italic' | null {
    return this.attributes['font-style'];
  }
  setFontStyle(fontStyle: 'normal' | 'italic' | null): InvertedTurn {
    this.attributes['font-style'] = fontStyle;
    return this;
  }
  getFontWeight(): 'normal' | 'bold' | null {
    return this.attributes['font-weight'];
  }
  setFontWeight(fontWeight: 'normal' | 'bold' | null): InvertedTurn {
    this.attributes['font-weight'] = fontWeight;
    return this;
  }
  getLastBeat(): number | null {
    return this.attributes['last-beat'];
  }
  setLastBeat(lastBeat: number | null): InvertedTurn {
    this.attributes['last-beat'] = lastBeat;
    return this;
  }
  getPlacement(): 'above' | 'below' | null {
    return this.attributes['placement'];
  }
  setPlacement(placement: 'above' | 'below' | null): InvertedTurn {
    this.attributes['placement'] = placement;
    return this;
  }
  getRelativeX(): number | null {
    return this.attributes['relative-x'];
  }
  setRelativeX(relativeX: number | null): InvertedTurn {
    this.attributes['relative-x'] = relativeX;
    return this;
  }
  getRelativeY(): number | null {
    return this.attributes['relative-y'];
  }
  setRelativeY(relativeY: number | null): InvertedTurn {
    this.attributes['relative-y'] = relativeY;
    return this;
  }
  getSecondBeat(): number | null {
    return this.attributes['second-beat'];
  }
  setSecondBeat(secondBeat: number | null): InvertedTurn {
    this.attributes['second-beat'] = secondBeat;
    return this;
  }
  getSlash(): 'yes' | 'no' | null {
    return this.attributes['slash'];
  }
  setSlash(slash: 'yes' | 'no' | null): InvertedTurn {
    this.attributes['slash'] = slash;
    return this;
  }
  getStartNote(): 'below' | 'main' | 'upper' | null {
    return this.attributes['start-note'];
  }
  setStartNote(startNote: 'below' | 'main' | 'upper' | null): InvertedTurn {
    this.attributes['start-note'] = startNote;
    return this;
  }
  getTrillStep(): 'unison' | 'half' | 'whole' | null {
    return this.attributes['trill-step'];
  }
  setTrillStep(trillStep: 'unison' | 'half' | 'whole' | null): InvertedTurn {
    this.attributes['trill-step'] = trillStep;
    return this;
  }
  getTwoNoteTurn(): 'none' | 'whole' | 'half' | null {
    return this.attributes['two-note-turn'];
  }
  setTwoNoteTurn(twoNoteTurn: 'none' | 'whole' | 'half' | null): InvertedTurn {
    this.attributes['two-note-turn'] = twoNoteTurn;
    return this;
  }
}

export type DelayedInvertedTurnAttributes = {
  accelerate: 'yes' | 'no' | null;
  beats: number | null;
  color: string | null;
  'default-x': number | null;
  'default-y': number | null;
  'font-family': string | null;
  'font-size': 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null;
  'font-style': 'normal' | 'italic' | null;
  'font-weight': 'normal' | 'bold' | null;
  'last-beat': number | null;
  placement: 'above' | 'below' | null;
  'relative-x': number | null;
  'relative-y': number | null;
  'second-beat': number | null;
  slash: 'yes' | 'no' | null;
  'start-note': 'below' | 'main' | 'upper' | null;
  'trill-step': 'unison' | 'half' | 'whole' | null;
  'two-note-turn': 'none' | 'whole' | 'half' | null;
};

export type DelayedInvertedTurnContents = [];

export class DelayedInvertedTurn
  implements XMLElement<'delayed-inverted-turn', DelayedInvertedTurnAttributes, DelayedInvertedTurnContents>
{
  static readonly schema = {
    name: 'delayed-inverted-turn',
    attributes: {
      accelerate: { type: 'optional', value: { type: 'choices', choices: ['yes', 'no'] } },
      beats: { type: 'optional', value: { type: 'float', min: 2, max: Infinity } },
      color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
      'default-x': {
        type: 'label',
        label: 'default-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'default-y': {
        type: 'label',
        label: 'default-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
      'font-size': {
        type: 'optional',
        value: {
          type: 'choices',
          choices: [
            { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
            { type: 'float', min: -Infinity, max: Infinity },
          ],
        },
      },
      'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
      'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
      'last-beat': { type: 'optional', value: { type: 'float', min: 0, max: 100 } },
      placement: { type: 'optional', value: { type: 'choices', choices: ['above', 'below'] } },
      'relative-x': {
        type: 'label',
        label: 'relative-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'relative-y': {
        type: 'label',
        label: 'relative-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'second-beat': { type: 'optional', value: { type: 'float', min: 0, max: 100 } },
      slash: { type: 'optional', value: { type: 'choices', choices: ['yes', 'no'] } },
      'start-note': { type: 'optional', value: { type: 'choices', choices: ['below', 'main', 'upper'] } },
      'trill-step': { type: 'optional', value: { type: 'choices', choices: ['unison', 'half', 'whole'] } },
      'two-note-turn': { type: 'optional', value: { type: 'choices', choices: ['none', 'whole', 'half'] } },
    },
    contents: [],
  } as const;

  readonly schema = DelayedInvertedTurn.schema;

  attributes: DelayedInvertedTurnAttributes;
  contents: DelayedInvertedTurnContents;

  constructor(opts?: { attributes?: Partial<DelayedInvertedTurnAttributes>; contents?: DelayedInvertedTurnContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, DelayedInvertedTurn.schema);
    this.contents = opts?.contents ?? operations.zero(DelayedInvertedTurn.schema.contents);
  }
  getAccelerate(): 'yes' | 'no' | null {
    return this.attributes['accelerate'];
  }
  setAccelerate(accelerate: 'yes' | 'no' | null): DelayedInvertedTurn {
    this.attributes['accelerate'] = accelerate;
    return this;
  }
  getBeats(): number | null {
    return this.attributes['beats'];
  }
  setBeats(beats: number | null): DelayedInvertedTurn {
    this.attributes['beats'] = beats;
    return this;
  }
  getColor(): string | null {
    return this.attributes['color'];
  }
  setColor(color: string | null): DelayedInvertedTurn {
    this.attributes['color'] = color;
    return this;
  }
  getDefaultX(): number | null {
    return this.attributes['default-x'];
  }
  setDefaultX(defaultX: number | null): DelayedInvertedTurn {
    this.attributes['default-x'] = defaultX;
    return this;
  }
  getDefaultY(): number | null {
    return this.attributes['default-y'];
  }
  setDefaultY(defaultY: number | null): DelayedInvertedTurn {
    this.attributes['default-y'] = defaultY;
    return this;
  }
  getFontFamily(): string | null {
    return this.attributes['font-family'];
  }
  setFontFamily(fontFamily: string | null): DelayedInvertedTurn {
    this.attributes['font-family'] = fontFamily;
    return this;
  }
  getFontSize(): 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null {
    return this.attributes['font-size'];
  }
  setFontSize(
    fontSize: 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null
  ): DelayedInvertedTurn {
    this.attributes['font-size'] = fontSize;
    return this;
  }
  getFontStyle(): 'normal' | 'italic' | null {
    return this.attributes['font-style'];
  }
  setFontStyle(fontStyle: 'normal' | 'italic' | null): DelayedInvertedTurn {
    this.attributes['font-style'] = fontStyle;
    return this;
  }
  getFontWeight(): 'normal' | 'bold' | null {
    return this.attributes['font-weight'];
  }
  setFontWeight(fontWeight: 'normal' | 'bold' | null): DelayedInvertedTurn {
    this.attributes['font-weight'] = fontWeight;
    return this;
  }
  getLastBeat(): number | null {
    return this.attributes['last-beat'];
  }
  setLastBeat(lastBeat: number | null): DelayedInvertedTurn {
    this.attributes['last-beat'] = lastBeat;
    return this;
  }
  getPlacement(): 'above' | 'below' | null {
    return this.attributes['placement'];
  }
  setPlacement(placement: 'above' | 'below' | null): DelayedInvertedTurn {
    this.attributes['placement'] = placement;
    return this;
  }
  getRelativeX(): number | null {
    return this.attributes['relative-x'];
  }
  setRelativeX(relativeX: number | null): DelayedInvertedTurn {
    this.attributes['relative-x'] = relativeX;
    return this;
  }
  getRelativeY(): number | null {
    return this.attributes['relative-y'];
  }
  setRelativeY(relativeY: number | null): DelayedInvertedTurn {
    this.attributes['relative-y'] = relativeY;
    return this;
  }
  getSecondBeat(): number | null {
    return this.attributes['second-beat'];
  }
  setSecondBeat(secondBeat: number | null): DelayedInvertedTurn {
    this.attributes['second-beat'] = secondBeat;
    return this;
  }
  getSlash(): 'yes' | 'no' | null {
    return this.attributes['slash'];
  }
  setSlash(slash: 'yes' | 'no' | null): DelayedInvertedTurn {
    this.attributes['slash'] = slash;
    return this;
  }
  getStartNote(): 'below' | 'main' | 'upper' | null {
    return this.attributes['start-note'];
  }
  setStartNote(startNote: 'below' | 'main' | 'upper' | null): DelayedInvertedTurn {
    this.attributes['start-note'] = startNote;
    return this;
  }
  getTrillStep(): 'unison' | 'half' | 'whole' | null {
    return this.attributes['trill-step'];
  }
  setTrillStep(trillStep: 'unison' | 'half' | 'whole' | null): DelayedInvertedTurn {
    this.attributes['trill-step'] = trillStep;
    return this;
  }
  getTwoNoteTurn(): 'none' | 'whole' | 'half' | null {
    return this.attributes['two-note-turn'];
  }
  setTwoNoteTurn(twoNoteTurn: 'none' | 'whole' | 'half' | null): DelayedInvertedTurn {
    this.attributes['two-note-turn'] = twoNoteTurn;
    return this;
  }
}

export type VerticalTurnAttributes = {
  accelerate: 'yes' | 'no' | null;
  beats: number | null;
  color: string | null;
  'default-x': number | null;
  'default-y': number | null;
  'font-family': string | null;
  'font-size': 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null;
  'font-style': 'normal' | 'italic' | null;
  'font-weight': 'normal' | 'bold' | null;
  'last-beat': number | null;
  placement: 'above' | 'below' | null;
  'relative-x': number | null;
  'relative-y': number | null;
  'second-beat': number | null;
  'start-note': 'below' | 'main' | 'upper' | null;
  'trill-step': 'unison' | 'half' | 'whole' | null;
  'two-note-turn': 'none' | 'whole' | 'half' | null;
};

export type VerticalTurnContents = [];

export class VerticalTurn implements XMLElement<'vertical-turn', VerticalTurnAttributes, VerticalTurnContents> {
  static readonly schema = {
    name: 'vertical-turn',
    attributes: {
      accelerate: { type: 'optional', value: { type: 'choices', choices: ['yes', 'no'] } },
      beats: { type: 'optional', value: { type: 'float', min: 2, max: Infinity } },
      color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
      'default-x': {
        type: 'label',
        label: 'default-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'default-y': {
        type: 'label',
        label: 'default-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
      'font-size': {
        type: 'optional',
        value: {
          type: 'choices',
          choices: [
            { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
            { type: 'float', min: -Infinity, max: Infinity },
          ],
        },
      },
      'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
      'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
      'last-beat': { type: 'optional', value: { type: 'float', min: 0, max: 100 } },
      placement: { type: 'optional', value: { type: 'choices', choices: ['above', 'below'] } },
      'relative-x': {
        type: 'label',
        label: 'relative-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'relative-y': {
        type: 'label',
        label: 'relative-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'second-beat': { type: 'optional', value: { type: 'float', min: 0, max: 100 } },
      'start-note': { type: 'optional', value: { type: 'choices', choices: ['below', 'main', 'upper'] } },
      'trill-step': { type: 'optional', value: { type: 'choices', choices: ['unison', 'half', 'whole'] } },
      'two-note-turn': { type: 'optional', value: { type: 'choices', choices: ['none', 'whole', 'half'] } },
    },
    contents: [],
  } as const;

  readonly schema = VerticalTurn.schema;

  attributes: VerticalTurnAttributes;
  contents: VerticalTurnContents;

  constructor(opts?: { attributes?: Partial<VerticalTurnAttributes>; contents?: VerticalTurnContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, VerticalTurn.schema);
    this.contents = opts?.contents ?? operations.zero(VerticalTurn.schema.contents);
  }
  getAccelerate(): 'yes' | 'no' | null {
    return this.attributes['accelerate'];
  }
  setAccelerate(accelerate: 'yes' | 'no' | null): VerticalTurn {
    this.attributes['accelerate'] = accelerate;
    return this;
  }
  getBeats(): number | null {
    return this.attributes['beats'];
  }
  setBeats(beats: number | null): VerticalTurn {
    this.attributes['beats'] = beats;
    return this;
  }
  getColor(): string | null {
    return this.attributes['color'];
  }
  setColor(color: string | null): VerticalTurn {
    this.attributes['color'] = color;
    return this;
  }
  getDefaultX(): number | null {
    return this.attributes['default-x'];
  }
  setDefaultX(defaultX: number | null): VerticalTurn {
    this.attributes['default-x'] = defaultX;
    return this;
  }
  getDefaultY(): number | null {
    return this.attributes['default-y'];
  }
  setDefaultY(defaultY: number | null): VerticalTurn {
    this.attributes['default-y'] = defaultY;
    return this;
  }
  getFontFamily(): string | null {
    return this.attributes['font-family'];
  }
  setFontFamily(fontFamily: string | null): VerticalTurn {
    this.attributes['font-family'] = fontFamily;
    return this;
  }
  getFontSize(): 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null {
    return this.attributes['font-size'];
  }
  setFontSize(
    fontSize: 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null
  ): VerticalTurn {
    this.attributes['font-size'] = fontSize;
    return this;
  }
  getFontStyle(): 'normal' | 'italic' | null {
    return this.attributes['font-style'];
  }
  setFontStyle(fontStyle: 'normal' | 'italic' | null): VerticalTurn {
    this.attributes['font-style'] = fontStyle;
    return this;
  }
  getFontWeight(): 'normal' | 'bold' | null {
    return this.attributes['font-weight'];
  }
  setFontWeight(fontWeight: 'normal' | 'bold' | null): VerticalTurn {
    this.attributes['font-weight'] = fontWeight;
    return this;
  }
  getLastBeat(): number | null {
    return this.attributes['last-beat'];
  }
  setLastBeat(lastBeat: number | null): VerticalTurn {
    this.attributes['last-beat'] = lastBeat;
    return this;
  }
  getPlacement(): 'above' | 'below' | null {
    return this.attributes['placement'];
  }
  setPlacement(placement: 'above' | 'below' | null): VerticalTurn {
    this.attributes['placement'] = placement;
    return this;
  }
  getRelativeX(): number | null {
    return this.attributes['relative-x'];
  }
  setRelativeX(relativeX: number | null): VerticalTurn {
    this.attributes['relative-x'] = relativeX;
    return this;
  }
  getRelativeY(): number | null {
    return this.attributes['relative-y'];
  }
  setRelativeY(relativeY: number | null): VerticalTurn {
    this.attributes['relative-y'] = relativeY;
    return this;
  }
  getSecondBeat(): number | null {
    return this.attributes['second-beat'];
  }
  setSecondBeat(secondBeat: number | null): VerticalTurn {
    this.attributes['second-beat'] = secondBeat;
    return this;
  }
  getStartNote(): 'below' | 'main' | 'upper' | null {
    return this.attributes['start-note'];
  }
  setStartNote(startNote: 'below' | 'main' | 'upper' | null): VerticalTurn {
    this.attributes['start-note'] = startNote;
    return this;
  }
  getTrillStep(): 'unison' | 'half' | 'whole' | null {
    return this.attributes['trill-step'];
  }
  setTrillStep(trillStep: 'unison' | 'half' | 'whole' | null): VerticalTurn {
    this.attributes['trill-step'] = trillStep;
    return this;
  }
  getTwoNoteTurn(): 'none' | 'whole' | 'half' | null {
    return this.attributes['two-note-turn'];
  }
  setTwoNoteTurn(twoNoteTurn: 'none' | 'whole' | 'half' | null): VerticalTurn {
    this.attributes['two-note-turn'] = twoNoteTurn;
    return this;
  }
}

export type InvertedVerticalTurnAttributes = {
  accelerate: 'yes' | 'no' | null;
  beats: number | null;
  color: string | null;
  'default-x': number | null;
  'default-y': number | null;
  'font-family': string | null;
  'font-size': 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null;
  'font-style': 'normal' | 'italic' | null;
  'font-weight': 'normal' | 'bold' | null;
  'last-beat': number | null;
  placement: 'above' | 'below' | null;
  'relative-x': number | null;
  'relative-y': number | null;
  'second-beat': number | null;
  'start-note': 'below' | 'main' | 'upper' | null;
  'trill-step': 'unison' | 'half' | 'whole' | null;
  'two-note-turn': 'none' | 'whole' | 'half' | null;
};

export type InvertedVerticalTurnContents = [];

export class InvertedVerticalTurn
  implements XMLElement<'inverted-vertical-turn', InvertedVerticalTurnAttributes, InvertedVerticalTurnContents>
{
  static readonly schema = {
    name: 'inverted-vertical-turn',
    attributes: {
      accelerate: { type: 'optional', value: { type: 'choices', choices: ['yes', 'no'] } },
      beats: { type: 'optional', value: { type: 'float', min: 2, max: Infinity } },
      color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
      'default-x': {
        type: 'label',
        label: 'default-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'default-y': {
        type: 'label',
        label: 'default-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
      'font-size': {
        type: 'optional',
        value: {
          type: 'choices',
          choices: [
            { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
            { type: 'float', min: -Infinity, max: Infinity },
          ],
        },
      },
      'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
      'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
      'last-beat': { type: 'optional', value: { type: 'float', min: 0, max: 100 } },
      placement: { type: 'optional', value: { type: 'choices', choices: ['above', 'below'] } },
      'relative-x': {
        type: 'label',
        label: 'relative-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'relative-y': {
        type: 'label',
        label: 'relative-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'second-beat': { type: 'optional', value: { type: 'float', min: 0, max: 100 } },
      'start-note': { type: 'optional', value: { type: 'choices', choices: ['below', 'main', 'upper'] } },
      'trill-step': { type: 'optional', value: { type: 'choices', choices: ['unison', 'half', 'whole'] } },
      'two-note-turn': { type: 'optional', value: { type: 'choices', choices: ['none', 'whole', 'half'] } },
    },
    contents: [],
  } as const;

  readonly schema = InvertedVerticalTurn.schema;

  attributes: InvertedVerticalTurnAttributes;
  contents: InvertedVerticalTurnContents;

  constructor(opts?: {
    attributes?: Partial<InvertedVerticalTurnAttributes>;
    contents?: InvertedVerticalTurnContents;
  }) {
    this.attributes = operations.merge(opts?.attributes || {}, InvertedVerticalTurn.schema);
    this.contents = opts?.contents ?? operations.zero(InvertedVerticalTurn.schema.contents);
  }
  getAccelerate(): 'yes' | 'no' | null {
    return this.attributes['accelerate'];
  }
  setAccelerate(accelerate: 'yes' | 'no' | null): InvertedVerticalTurn {
    this.attributes['accelerate'] = accelerate;
    return this;
  }
  getBeats(): number | null {
    return this.attributes['beats'];
  }
  setBeats(beats: number | null): InvertedVerticalTurn {
    this.attributes['beats'] = beats;
    return this;
  }
  getColor(): string | null {
    return this.attributes['color'];
  }
  setColor(color: string | null): InvertedVerticalTurn {
    this.attributes['color'] = color;
    return this;
  }
  getDefaultX(): number | null {
    return this.attributes['default-x'];
  }
  setDefaultX(defaultX: number | null): InvertedVerticalTurn {
    this.attributes['default-x'] = defaultX;
    return this;
  }
  getDefaultY(): number | null {
    return this.attributes['default-y'];
  }
  setDefaultY(defaultY: number | null): InvertedVerticalTurn {
    this.attributes['default-y'] = defaultY;
    return this;
  }
  getFontFamily(): string | null {
    return this.attributes['font-family'];
  }
  setFontFamily(fontFamily: string | null): InvertedVerticalTurn {
    this.attributes['font-family'] = fontFamily;
    return this;
  }
  getFontSize(): 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null {
    return this.attributes['font-size'];
  }
  setFontSize(
    fontSize: 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null
  ): InvertedVerticalTurn {
    this.attributes['font-size'] = fontSize;
    return this;
  }
  getFontStyle(): 'normal' | 'italic' | null {
    return this.attributes['font-style'];
  }
  setFontStyle(fontStyle: 'normal' | 'italic' | null): InvertedVerticalTurn {
    this.attributes['font-style'] = fontStyle;
    return this;
  }
  getFontWeight(): 'normal' | 'bold' | null {
    return this.attributes['font-weight'];
  }
  setFontWeight(fontWeight: 'normal' | 'bold' | null): InvertedVerticalTurn {
    this.attributes['font-weight'] = fontWeight;
    return this;
  }
  getLastBeat(): number | null {
    return this.attributes['last-beat'];
  }
  setLastBeat(lastBeat: number | null): InvertedVerticalTurn {
    this.attributes['last-beat'] = lastBeat;
    return this;
  }
  getPlacement(): 'above' | 'below' | null {
    return this.attributes['placement'];
  }
  setPlacement(placement: 'above' | 'below' | null): InvertedVerticalTurn {
    this.attributes['placement'] = placement;
    return this;
  }
  getRelativeX(): number | null {
    return this.attributes['relative-x'];
  }
  setRelativeX(relativeX: number | null): InvertedVerticalTurn {
    this.attributes['relative-x'] = relativeX;
    return this;
  }
  getRelativeY(): number | null {
    return this.attributes['relative-y'];
  }
  setRelativeY(relativeY: number | null): InvertedVerticalTurn {
    this.attributes['relative-y'] = relativeY;
    return this;
  }
  getSecondBeat(): number | null {
    return this.attributes['second-beat'];
  }
  setSecondBeat(secondBeat: number | null): InvertedVerticalTurn {
    this.attributes['second-beat'] = secondBeat;
    return this;
  }
  getStartNote(): 'below' | 'main' | 'upper' | null {
    return this.attributes['start-note'];
  }
  setStartNote(startNote: 'below' | 'main' | 'upper' | null): InvertedVerticalTurn {
    this.attributes['start-note'] = startNote;
    return this;
  }
  getTrillStep(): 'unison' | 'half' | 'whole' | null {
    return this.attributes['trill-step'];
  }
  setTrillStep(trillStep: 'unison' | 'half' | 'whole' | null): InvertedVerticalTurn {
    this.attributes['trill-step'] = trillStep;
    return this;
  }
  getTwoNoteTurn(): 'none' | 'whole' | 'half' | null {
    return this.attributes['two-note-turn'];
  }
  setTwoNoteTurn(twoNoteTurn: 'none' | 'whole' | 'half' | null): InvertedVerticalTurn {
    this.attributes['two-note-turn'] = twoNoteTurn;
    return this;
  }
}

export type ShakeAttributes = {
  accelerate: 'yes' | 'no' | null;
  beats: number | null;
  color: string | null;
  'default-x': number | null;
  'default-y': number | null;
  'font-family': string | null;
  'font-size': 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null;
  'font-style': 'normal' | 'italic' | null;
  'font-weight': 'normal' | 'bold' | null;
  'last-beat': number | null;
  placement: 'above' | 'below' | null;
  'relative-x': number | null;
  'relative-y': number | null;
  'second-beat': number | null;
  'start-note': 'below' | 'main' | 'upper' | null;
  'trill-step': 'unison' | 'half' | 'whole' | null;
  'two-note-turn': 'none' | 'whole' | 'half' | null;
};

export type ShakeContents = [];

export class Shake implements XMLElement<'shake', ShakeAttributes, ShakeContents> {
  static readonly schema = {
    name: 'shake',
    attributes: {
      accelerate: { type: 'optional', value: { type: 'choices', choices: ['yes', 'no'] } },
      beats: { type: 'optional', value: { type: 'float', min: 2, max: Infinity } },
      color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
      'default-x': {
        type: 'label',
        label: 'default-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'default-y': {
        type: 'label',
        label: 'default-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
      'font-size': {
        type: 'optional',
        value: {
          type: 'choices',
          choices: [
            { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
            { type: 'float', min: -Infinity, max: Infinity },
          ],
        },
      },
      'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
      'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
      'last-beat': { type: 'optional', value: { type: 'float', min: 0, max: 100 } },
      placement: { type: 'optional', value: { type: 'choices', choices: ['above', 'below'] } },
      'relative-x': {
        type: 'label',
        label: 'relative-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'relative-y': {
        type: 'label',
        label: 'relative-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'second-beat': { type: 'optional', value: { type: 'float', min: 0, max: 100 } },
      'start-note': { type: 'optional', value: { type: 'choices', choices: ['below', 'main', 'upper'] } },
      'trill-step': { type: 'optional', value: { type: 'choices', choices: ['unison', 'half', 'whole'] } },
      'two-note-turn': { type: 'optional', value: { type: 'choices', choices: ['none', 'whole', 'half'] } },
    },
    contents: [],
  } as const;

  readonly schema = Shake.schema;

  attributes: ShakeAttributes;
  contents: ShakeContents;

  constructor(opts?: { attributes?: Partial<ShakeAttributes>; contents?: ShakeContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Shake.schema);
    this.contents = opts?.contents ?? operations.zero(Shake.schema.contents);
  }
  getAccelerate(): 'yes' | 'no' | null {
    return this.attributes['accelerate'];
  }
  setAccelerate(accelerate: 'yes' | 'no' | null): Shake {
    this.attributes['accelerate'] = accelerate;
    return this;
  }
  getBeats(): number | null {
    return this.attributes['beats'];
  }
  setBeats(beats: number | null): Shake {
    this.attributes['beats'] = beats;
    return this;
  }
  getColor(): string | null {
    return this.attributes['color'];
  }
  setColor(color: string | null): Shake {
    this.attributes['color'] = color;
    return this;
  }
  getDefaultX(): number | null {
    return this.attributes['default-x'];
  }
  setDefaultX(defaultX: number | null): Shake {
    this.attributes['default-x'] = defaultX;
    return this;
  }
  getDefaultY(): number | null {
    return this.attributes['default-y'];
  }
  setDefaultY(defaultY: number | null): Shake {
    this.attributes['default-y'] = defaultY;
    return this;
  }
  getFontFamily(): string | null {
    return this.attributes['font-family'];
  }
  setFontFamily(fontFamily: string | null): Shake {
    this.attributes['font-family'] = fontFamily;
    return this;
  }
  getFontSize(): 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null {
    return this.attributes['font-size'];
  }
  setFontSize(
    fontSize: 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null
  ): Shake {
    this.attributes['font-size'] = fontSize;
    return this;
  }
  getFontStyle(): 'normal' | 'italic' | null {
    return this.attributes['font-style'];
  }
  setFontStyle(fontStyle: 'normal' | 'italic' | null): Shake {
    this.attributes['font-style'] = fontStyle;
    return this;
  }
  getFontWeight(): 'normal' | 'bold' | null {
    return this.attributes['font-weight'];
  }
  setFontWeight(fontWeight: 'normal' | 'bold' | null): Shake {
    this.attributes['font-weight'] = fontWeight;
    return this;
  }
  getLastBeat(): number | null {
    return this.attributes['last-beat'];
  }
  setLastBeat(lastBeat: number | null): Shake {
    this.attributes['last-beat'] = lastBeat;
    return this;
  }
  getPlacement(): 'above' | 'below' | null {
    return this.attributes['placement'];
  }
  setPlacement(placement: 'above' | 'below' | null): Shake {
    this.attributes['placement'] = placement;
    return this;
  }
  getRelativeX(): number | null {
    return this.attributes['relative-x'];
  }
  setRelativeX(relativeX: number | null): Shake {
    this.attributes['relative-x'] = relativeX;
    return this;
  }
  getRelativeY(): number | null {
    return this.attributes['relative-y'];
  }
  setRelativeY(relativeY: number | null): Shake {
    this.attributes['relative-y'] = relativeY;
    return this;
  }
  getSecondBeat(): number | null {
    return this.attributes['second-beat'];
  }
  setSecondBeat(secondBeat: number | null): Shake {
    this.attributes['second-beat'] = secondBeat;
    return this;
  }
  getStartNote(): 'below' | 'main' | 'upper' | null {
    return this.attributes['start-note'];
  }
  setStartNote(startNote: 'below' | 'main' | 'upper' | null): Shake {
    this.attributes['start-note'] = startNote;
    return this;
  }
  getTrillStep(): 'unison' | 'half' | 'whole' | null {
    return this.attributes['trill-step'];
  }
  setTrillStep(trillStep: 'unison' | 'half' | 'whole' | null): Shake {
    this.attributes['trill-step'] = trillStep;
    return this;
  }
  getTwoNoteTurn(): 'none' | 'whole' | 'half' | null {
    return this.attributes['two-note-turn'];
  }
  setTwoNoteTurn(twoNoteTurn: 'none' | 'whole' | 'half' | null): Shake {
    this.attributes['two-note-turn'] = twoNoteTurn;
    return this;
  }
}

export type WavyLineAttributes = {
  type: 'start' | 'stop' | 'continue';
  accelerate: 'yes' | 'no' | null;
  beats: number | null;
  color: string | null;
  'default-x': number | null;
  'default-y': number | null;
  'last-beat': number | null;
  number: number | null;
  placement: 'above' | 'below' | null;
  'relative-x': number | null;
  'relative-y': number | null;
  'second-beat': number | null;
  smufl: string | null;
  'start-note': 'below' | 'main' | 'upper' | null;
  'trill-step': 'unison' | 'half' | 'whole' | null;
  'two-note-turn': 'none' | 'whole' | 'half' | null;
};

export type WavyLineContents = [];

export class WavyLine implements XMLElement<'wavy-line', WavyLineAttributes, WavyLineContents> {
  static readonly schema = {
    name: 'wavy-line',
    attributes: {
      type: { type: 'required', value: { type: 'choices', choices: ['start', 'stop', 'continue'] } },
      accelerate: { type: 'optional', value: { type: 'choices', choices: ['yes', 'no'] } },
      beats: { type: 'optional', value: { type: 'float', min: 2, max: Infinity } },
      color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
      'default-x': {
        type: 'label',
        label: 'default-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'default-y': {
        type: 'label',
        label: 'default-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'last-beat': { type: 'optional', value: { type: 'float', min: 0, max: 100 } },
      number: { type: 'optional', value: { type: 'int', min: 1, max: 16 } },
      placement: { type: 'optional', value: { type: 'choices', choices: ['above', 'below'] } },
      'relative-x': {
        type: 'label',
        label: 'relative-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'relative-y': {
        type: 'label',
        label: 'relative-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'second-beat': { type: 'optional', value: { type: 'float', min: 0, max: 100 } },
      smufl: {
        type: 'optional',
        value: { type: 'regex', pattern: /(wiggle)|(guitar\c*VibratoStroke)/, zero: 'wiggle' },
      },
      'start-note': { type: 'optional', value: { type: 'choices', choices: ['below', 'main', 'upper'] } },
      'trill-step': { type: 'optional', value: { type: 'choices', choices: ['unison', 'half', 'whole'] } },
      'two-note-turn': { type: 'optional', value: { type: 'choices', choices: ['none', 'whole', 'half'] } },
    },
    contents: [],
  } as const;

  readonly schema = WavyLine.schema;

  attributes: WavyLineAttributes;
  contents: WavyLineContents;

  constructor(opts?: { attributes?: Partial<WavyLineAttributes>; contents?: WavyLineContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, WavyLine.schema);
    this.contents = opts?.contents ?? operations.zero(WavyLine.schema.contents);
  }
  getType(): 'start' | 'stop' | 'continue' {
    return this.attributes['type'];
  }
  setType(type: 'start' | 'stop' | 'continue'): WavyLine {
    this.attributes['type'] = type;
    return this;
  }
  getAccelerate(): 'yes' | 'no' | null {
    return this.attributes['accelerate'];
  }
  setAccelerate(accelerate: 'yes' | 'no' | null): WavyLine {
    this.attributes['accelerate'] = accelerate;
    return this;
  }
  getBeats(): number | null {
    return this.attributes['beats'];
  }
  setBeats(beats: number | null): WavyLine {
    this.attributes['beats'] = beats;
    return this;
  }
  getColor(): string | null {
    return this.attributes['color'];
  }
  setColor(color: string | null): WavyLine {
    this.attributes['color'] = color;
    return this;
  }
  getDefaultX(): number | null {
    return this.attributes['default-x'];
  }
  setDefaultX(defaultX: number | null): WavyLine {
    this.attributes['default-x'] = defaultX;
    return this;
  }
  getDefaultY(): number | null {
    return this.attributes['default-y'];
  }
  setDefaultY(defaultY: number | null): WavyLine {
    this.attributes['default-y'] = defaultY;
    return this;
  }
  getLastBeat(): number | null {
    return this.attributes['last-beat'];
  }
  setLastBeat(lastBeat: number | null): WavyLine {
    this.attributes['last-beat'] = lastBeat;
    return this;
  }
  getNumber(): number | null {
    return this.attributes['number'];
  }
  setNumber(number: number | null): WavyLine {
    this.attributes['number'] = number;
    return this;
  }
  getPlacement(): 'above' | 'below' | null {
    return this.attributes['placement'];
  }
  setPlacement(placement: 'above' | 'below' | null): WavyLine {
    this.attributes['placement'] = placement;
    return this;
  }
  getRelativeX(): number | null {
    return this.attributes['relative-x'];
  }
  setRelativeX(relativeX: number | null): WavyLine {
    this.attributes['relative-x'] = relativeX;
    return this;
  }
  getRelativeY(): number | null {
    return this.attributes['relative-y'];
  }
  setRelativeY(relativeY: number | null): WavyLine {
    this.attributes['relative-y'] = relativeY;
    return this;
  }
  getSecondBeat(): number | null {
    return this.attributes['second-beat'];
  }
  setSecondBeat(secondBeat: number | null): WavyLine {
    this.attributes['second-beat'] = secondBeat;
    return this;
  }
  getSmufl(): string | null {
    return this.attributes['smufl'];
  }
  setSmufl(smufl: string | null): WavyLine {
    this.attributes['smufl'] = smufl;
    return this;
  }
  getStartNote(): 'below' | 'main' | 'upper' | null {
    return this.attributes['start-note'];
  }
  setStartNote(startNote: 'below' | 'main' | 'upper' | null): WavyLine {
    this.attributes['start-note'] = startNote;
    return this;
  }
  getTrillStep(): 'unison' | 'half' | 'whole' | null {
    return this.attributes['trill-step'];
  }
  setTrillStep(trillStep: 'unison' | 'half' | 'whole' | null): WavyLine {
    this.attributes['trill-step'] = trillStep;
    return this;
  }
  getTwoNoteTurn(): 'none' | 'whole' | 'half' | null {
    return this.attributes['two-note-turn'];
  }
  setTwoNoteTurn(twoNoteTurn: 'none' | 'whole' | 'half' | null): WavyLine {
    this.attributes['two-note-turn'] = twoNoteTurn;
    return this;
  }
}

export type MordentAttributes = {
  accelerate: 'yes' | 'no' | null;
  approach: 'above' | 'below' | null;
  beats: number | null;
  color: string | null;
  'default-x': number | null;
  'default-y': number | null;
  departure: 'above' | 'below' | null;
  'font-family': string | null;
  'font-size': 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null;
  'font-style': 'normal' | 'italic' | null;
  'font-weight': 'normal' | 'bold' | null;
  'last-beat': number | null;
  long: 'yes' | 'no' | null;
  placement: 'above' | 'below' | null;
  'relative-x': number | null;
  'relative-y': number | null;
  'second-beat': number | null;
  'start-note': 'below' | 'main' | 'upper' | null;
  'trill-step': 'unison' | 'half' | 'whole' | null;
  'two-note-turn': 'none' | 'whole' | 'half' | null;
};

export type MordentContents = [];

export class Mordent implements XMLElement<'mordent', MordentAttributes, MordentContents> {
  static readonly schema = {
    name: 'mordent',
    attributes: {
      accelerate: { type: 'optional', value: { type: 'choices', choices: ['yes', 'no'] } },
      approach: { type: 'optional', value: { type: 'choices', choices: ['above', 'below'] } },
      beats: { type: 'optional', value: { type: 'float', min: 2, max: Infinity } },
      color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
      'default-x': {
        type: 'label',
        label: 'default-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'default-y': {
        type: 'label',
        label: 'default-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      departure: { type: 'optional', value: { type: 'choices', choices: ['above', 'below'] } },
      'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
      'font-size': {
        type: 'optional',
        value: {
          type: 'choices',
          choices: [
            { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
            { type: 'float', min: -Infinity, max: Infinity },
          ],
        },
      },
      'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
      'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
      'last-beat': { type: 'optional', value: { type: 'float', min: 0, max: 100 } },
      long: { type: 'optional', value: { type: 'choices', choices: ['yes', 'no'] } },
      placement: { type: 'optional', value: { type: 'choices', choices: ['above', 'below'] } },
      'relative-x': {
        type: 'label',
        label: 'relative-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'relative-y': {
        type: 'label',
        label: 'relative-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'second-beat': { type: 'optional', value: { type: 'float', min: 0, max: 100 } },
      'start-note': { type: 'optional', value: { type: 'choices', choices: ['below', 'main', 'upper'] } },
      'trill-step': { type: 'optional', value: { type: 'choices', choices: ['unison', 'half', 'whole'] } },
      'two-note-turn': { type: 'optional', value: { type: 'choices', choices: ['none', 'whole', 'half'] } },
    },
    contents: [],
  } as const;

  readonly schema = Mordent.schema;

  attributes: MordentAttributes;
  contents: MordentContents;

  constructor(opts?: { attributes?: Partial<MordentAttributes>; contents?: MordentContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Mordent.schema);
    this.contents = opts?.contents ?? operations.zero(Mordent.schema.contents);
  }
  getAccelerate(): 'yes' | 'no' | null {
    return this.attributes['accelerate'];
  }
  setAccelerate(accelerate: 'yes' | 'no' | null): Mordent {
    this.attributes['accelerate'] = accelerate;
    return this;
  }
  getApproach(): 'above' | 'below' | null {
    return this.attributes['approach'];
  }
  setApproach(approach: 'above' | 'below' | null): Mordent {
    this.attributes['approach'] = approach;
    return this;
  }
  getBeats(): number | null {
    return this.attributes['beats'];
  }
  setBeats(beats: number | null): Mordent {
    this.attributes['beats'] = beats;
    return this;
  }
  getColor(): string | null {
    return this.attributes['color'];
  }
  setColor(color: string | null): Mordent {
    this.attributes['color'] = color;
    return this;
  }
  getDefaultX(): number | null {
    return this.attributes['default-x'];
  }
  setDefaultX(defaultX: number | null): Mordent {
    this.attributes['default-x'] = defaultX;
    return this;
  }
  getDefaultY(): number | null {
    return this.attributes['default-y'];
  }
  setDefaultY(defaultY: number | null): Mordent {
    this.attributes['default-y'] = defaultY;
    return this;
  }
  getDeparture(): 'above' | 'below' | null {
    return this.attributes['departure'];
  }
  setDeparture(departure: 'above' | 'below' | null): Mordent {
    this.attributes['departure'] = departure;
    return this;
  }
  getFontFamily(): string | null {
    return this.attributes['font-family'];
  }
  setFontFamily(fontFamily: string | null): Mordent {
    this.attributes['font-family'] = fontFamily;
    return this;
  }
  getFontSize(): 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null {
    return this.attributes['font-size'];
  }
  setFontSize(
    fontSize: 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null
  ): Mordent {
    this.attributes['font-size'] = fontSize;
    return this;
  }
  getFontStyle(): 'normal' | 'italic' | null {
    return this.attributes['font-style'];
  }
  setFontStyle(fontStyle: 'normal' | 'italic' | null): Mordent {
    this.attributes['font-style'] = fontStyle;
    return this;
  }
  getFontWeight(): 'normal' | 'bold' | null {
    return this.attributes['font-weight'];
  }
  setFontWeight(fontWeight: 'normal' | 'bold' | null): Mordent {
    this.attributes['font-weight'] = fontWeight;
    return this;
  }
  getLastBeat(): number | null {
    return this.attributes['last-beat'];
  }
  setLastBeat(lastBeat: number | null): Mordent {
    this.attributes['last-beat'] = lastBeat;
    return this;
  }
  getLong(): 'yes' | 'no' | null {
    return this.attributes['long'];
  }
  setLong(long: 'yes' | 'no' | null): Mordent {
    this.attributes['long'] = long;
    return this;
  }
  getPlacement(): 'above' | 'below' | null {
    return this.attributes['placement'];
  }
  setPlacement(placement: 'above' | 'below' | null): Mordent {
    this.attributes['placement'] = placement;
    return this;
  }
  getRelativeX(): number | null {
    return this.attributes['relative-x'];
  }
  setRelativeX(relativeX: number | null): Mordent {
    this.attributes['relative-x'] = relativeX;
    return this;
  }
  getRelativeY(): number | null {
    return this.attributes['relative-y'];
  }
  setRelativeY(relativeY: number | null): Mordent {
    this.attributes['relative-y'] = relativeY;
    return this;
  }
  getSecondBeat(): number | null {
    return this.attributes['second-beat'];
  }
  setSecondBeat(secondBeat: number | null): Mordent {
    this.attributes['second-beat'] = secondBeat;
    return this;
  }
  getStartNote(): 'below' | 'main' | 'upper' | null {
    return this.attributes['start-note'];
  }
  setStartNote(startNote: 'below' | 'main' | 'upper' | null): Mordent {
    this.attributes['start-note'] = startNote;
    return this;
  }
  getTrillStep(): 'unison' | 'half' | 'whole' | null {
    return this.attributes['trill-step'];
  }
  setTrillStep(trillStep: 'unison' | 'half' | 'whole' | null): Mordent {
    this.attributes['trill-step'] = trillStep;
    return this;
  }
  getTwoNoteTurn(): 'none' | 'whole' | 'half' | null {
    return this.attributes['two-note-turn'];
  }
  setTwoNoteTurn(twoNoteTurn: 'none' | 'whole' | 'half' | null): Mordent {
    this.attributes['two-note-turn'] = twoNoteTurn;
    return this;
  }
}

export type InvertedMordentAttributes = {
  accelerate: 'yes' | 'no' | null;
  approach: 'above' | 'below' | null;
  beats: number | null;
  color: string | null;
  'default-x': number | null;
  'default-y': number | null;
  departure: 'above' | 'below' | null;
  'font-family': string | null;
  'font-size': 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null;
  'font-style': 'normal' | 'italic' | null;
  'font-weight': 'normal' | 'bold' | null;
  'last-beat': number | null;
  long: 'yes' | 'no' | null;
  placement: 'above' | 'below' | null;
  'relative-x': number | null;
  'relative-y': number | null;
  'second-beat': number | null;
  'start-note': 'below' | 'main' | 'upper' | null;
  'trill-step': 'unison' | 'half' | 'whole' | null;
  'two-note-turn': 'none' | 'whole' | 'half' | null;
};

export type InvertedMordentContents = [];

export class InvertedMordent
  implements XMLElement<'inverted-mordent', InvertedMordentAttributes, InvertedMordentContents>
{
  static readonly schema = {
    name: 'inverted-mordent',
    attributes: {
      accelerate: { type: 'optional', value: { type: 'choices', choices: ['yes', 'no'] } },
      approach: { type: 'optional', value: { type: 'choices', choices: ['above', 'below'] } },
      beats: { type: 'optional', value: { type: 'float', min: 2, max: Infinity } },
      color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
      'default-x': {
        type: 'label',
        label: 'default-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'default-y': {
        type: 'label',
        label: 'default-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      departure: { type: 'optional', value: { type: 'choices', choices: ['above', 'below'] } },
      'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
      'font-size': {
        type: 'optional',
        value: {
          type: 'choices',
          choices: [
            { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
            { type: 'float', min: -Infinity, max: Infinity },
          ],
        },
      },
      'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
      'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
      'last-beat': { type: 'optional', value: { type: 'float', min: 0, max: 100 } },
      long: { type: 'optional', value: { type: 'choices', choices: ['yes', 'no'] } },
      placement: { type: 'optional', value: { type: 'choices', choices: ['above', 'below'] } },
      'relative-x': {
        type: 'label',
        label: 'relative-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'relative-y': {
        type: 'label',
        label: 'relative-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'second-beat': { type: 'optional', value: { type: 'float', min: 0, max: 100 } },
      'start-note': { type: 'optional', value: { type: 'choices', choices: ['below', 'main', 'upper'] } },
      'trill-step': { type: 'optional', value: { type: 'choices', choices: ['unison', 'half', 'whole'] } },
      'two-note-turn': { type: 'optional', value: { type: 'choices', choices: ['none', 'whole', 'half'] } },
    },
    contents: [],
  } as const;

  readonly schema = InvertedMordent.schema;

  attributes: InvertedMordentAttributes;
  contents: InvertedMordentContents;

  constructor(opts?: { attributes?: Partial<InvertedMordentAttributes>; contents?: InvertedMordentContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, InvertedMordent.schema);
    this.contents = opts?.contents ?? operations.zero(InvertedMordent.schema.contents);
  }
  getAccelerate(): 'yes' | 'no' | null {
    return this.attributes['accelerate'];
  }
  setAccelerate(accelerate: 'yes' | 'no' | null): InvertedMordent {
    this.attributes['accelerate'] = accelerate;
    return this;
  }
  getApproach(): 'above' | 'below' | null {
    return this.attributes['approach'];
  }
  setApproach(approach: 'above' | 'below' | null): InvertedMordent {
    this.attributes['approach'] = approach;
    return this;
  }
  getBeats(): number | null {
    return this.attributes['beats'];
  }
  setBeats(beats: number | null): InvertedMordent {
    this.attributes['beats'] = beats;
    return this;
  }
  getColor(): string | null {
    return this.attributes['color'];
  }
  setColor(color: string | null): InvertedMordent {
    this.attributes['color'] = color;
    return this;
  }
  getDefaultX(): number | null {
    return this.attributes['default-x'];
  }
  setDefaultX(defaultX: number | null): InvertedMordent {
    this.attributes['default-x'] = defaultX;
    return this;
  }
  getDefaultY(): number | null {
    return this.attributes['default-y'];
  }
  setDefaultY(defaultY: number | null): InvertedMordent {
    this.attributes['default-y'] = defaultY;
    return this;
  }
  getDeparture(): 'above' | 'below' | null {
    return this.attributes['departure'];
  }
  setDeparture(departure: 'above' | 'below' | null): InvertedMordent {
    this.attributes['departure'] = departure;
    return this;
  }
  getFontFamily(): string | null {
    return this.attributes['font-family'];
  }
  setFontFamily(fontFamily: string | null): InvertedMordent {
    this.attributes['font-family'] = fontFamily;
    return this;
  }
  getFontSize(): 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null {
    return this.attributes['font-size'];
  }
  setFontSize(
    fontSize: 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null
  ): InvertedMordent {
    this.attributes['font-size'] = fontSize;
    return this;
  }
  getFontStyle(): 'normal' | 'italic' | null {
    return this.attributes['font-style'];
  }
  setFontStyle(fontStyle: 'normal' | 'italic' | null): InvertedMordent {
    this.attributes['font-style'] = fontStyle;
    return this;
  }
  getFontWeight(): 'normal' | 'bold' | null {
    return this.attributes['font-weight'];
  }
  setFontWeight(fontWeight: 'normal' | 'bold' | null): InvertedMordent {
    this.attributes['font-weight'] = fontWeight;
    return this;
  }
  getLastBeat(): number | null {
    return this.attributes['last-beat'];
  }
  setLastBeat(lastBeat: number | null): InvertedMordent {
    this.attributes['last-beat'] = lastBeat;
    return this;
  }
  getLong(): 'yes' | 'no' | null {
    return this.attributes['long'];
  }
  setLong(long: 'yes' | 'no' | null): InvertedMordent {
    this.attributes['long'] = long;
    return this;
  }
  getPlacement(): 'above' | 'below' | null {
    return this.attributes['placement'];
  }
  setPlacement(placement: 'above' | 'below' | null): InvertedMordent {
    this.attributes['placement'] = placement;
    return this;
  }
  getRelativeX(): number | null {
    return this.attributes['relative-x'];
  }
  setRelativeX(relativeX: number | null): InvertedMordent {
    this.attributes['relative-x'] = relativeX;
    return this;
  }
  getRelativeY(): number | null {
    return this.attributes['relative-y'];
  }
  setRelativeY(relativeY: number | null): InvertedMordent {
    this.attributes['relative-y'] = relativeY;
    return this;
  }
  getSecondBeat(): number | null {
    return this.attributes['second-beat'];
  }
  setSecondBeat(secondBeat: number | null): InvertedMordent {
    this.attributes['second-beat'] = secondBeat;
    return this;
  }
  getStartNote(): 'below' | 'main' | 'upper' | null {
    return this.attributes['start-note'];
  }
  setStartNote(startNote: 'below' | 'main' | 'upper' | null): InvertedMordent {
    this.attributes['start-note'] = startNote;
    return this;
  }
  getTrillStep(): 'unison' | 'half' | 'whole' | null {
    return this.attributes['trill-step'];
  }
  setTrillStep(trillStep: 'unison' | 'half' | 'whole' | null): InvertedMordent {
    this.attributes['trill-step'] = trillStep;
    return this;
  }
  getTwoNoteTurn(): 'none' | 'whole' | 'half' | null {
    return this.attributes['two-note-turn'];
  }
  setTwoNoteTurn(twoNoteTurn: 'none' | 'whole' | 'half' | null): InvertedMordent {
    this.attributes['two-note-turn'] = twoNoteTurn;
    return this;
  }
}

export type SchleiferAttributes = {
  color: string | null;
  'default-x': number | null;
  'default-y': number | null;
  'font-family': string | null;
  'font-size': 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null;
  'font-style': 'normal' | 'italic' | null;
  'font-weight': 'normal' | 'bold' | null;
  placement: 'above' | 'below' | null;
  'relative-x': number | null;
  'relative-y': number | null;
};

export type SchleiferContents = [];

export class Schleifer implements XMLElement<'schleifer', SchleiferAttributes, SchleiferContents> {
  static readonly schema = {
    name: 'schleifer',
    attributes: {
      color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
      'default-x': {
        type: 'label',
        label: 'default-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'default-y': {
        type: 'label',
        label: 'default-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
      'font-size': {
        type: 'optional',
        value: {
          type: 'choices',
          choices: [
            { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
            { type: 'float', min: -Infinity, max: Infinity },
          ],
        },
      },
      'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
      'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
      placement: { type: 'optional', value: { type: 'choices', choices: ['above', 'below'] } },
      'relative-x': {
        type: 'label',
        label: 'relative-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'relative-y': {
        type: 'label',
        label: 'relative-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
    },
    contents: [],
  } as const;

  readonly schema = Schleifer.schema;

  attributes: SchleiferAttributes;
  contents: SchleiferContents;

  constructor(opts?: { attributes?: Partial<SchleiferAttributes>; contents?: SchleiferContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Schleifer.schema);
    this.contents = opts?.contents ?? operations.zero(Schleifer.schema.contents);
  }
  getColor(): string | null {
    return this.attributes['color'];
  }
  setColor(color: string | null): Schleifer {
    this.attributes['color'] = color;
    return this;
  }
  getDefaultX(): number | null {
    return this.attributes['default-x'];
  }
  setDefaultX(defaultX: number | null): Schleifer {
    this.attributes['default-x'] = defaultX;
    return this;
  }
  getDefaultY(): number | null {
    return this.attributes['default-y'];
  }
  setDefaultY(defaultY: number | null): Schleifer {
    this.attributes['default-y'] = defaultY;
    return this;
  }
  getFontFamily(): string | null {
    return this.attributes['font-family'];
  }
  setFontFamily(fontFamily: string | null): Schleifer {
    this.attributes['font-family'] = fontFamily;
    return this;
  }
  getFontSize(): 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null {
    return this.attributes['font-size'];
  }
  setFontSize(
    fontSize: 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null
  ): Schleifer {
    this.attributes['font-size'] = fontSize;
    return this;
  }
  getFontStyle(): 'normal' | 'italic' | null {
    return this.attributes['font-style'];
  }
  setFontStyle(fontStyle: 'normal' | 'italic' | null): Schleifer {
    this.attributes['font-style'] = fontStyle;
    return this;
  }
  getFontWeight(): 'normal' | 'bold' | null {
    return this.attributes['font-weight'];
  }
  setFontWeight(fontWeight: 'normal' | 'bold' | null): Schleifer {
    this.attributes['font-weight'] = fontWeight;
    return this;
  }
  getPlacement(): 'above' | 'below' | null {
    return this.attributes['placement'];
  }
  setPlacement(placement: 'above' | 'below' | null): Schleifer {
    this.attributes['placement'] = placement;
    return this;
  }
  getRelativeX(): number | null {
    return this.attributes['relative-x'];
  }
  setRelativeX(relativeX: number | null): Schleifer {
    this.attributes['relative-x'] = relativeX;
    return this;
  }
  getRelativeY(): number | null {
    return this.attributes['relative-y'];
  }
  setRelativeY(relativeY: number | null): Schleifer {
    this.attributes['relative-y'] = relativeY;
    return this;
  }
}

export type TremoloAttributes = {
  color: string | null;
  'default-x': number | null;
  'default-y': number | null;
  'font-family': string | null;
  'font-size': 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null;
  'font-style': 'normal' | 'italic' | null;
  'font-weight': 'normal' | 'bold' | null;
  placement: 'above' | 'below' | null;
  'relative-x': number | null;
  'relative-y': number | null;
  smufl: string | null;
  type: 'start' | 'stop' | 'single' | 'unmeasured' | null;
};

export type TremoloContents = [number];

export class Tremolo implements XMLElement<'tremolo', TremoloAttributes, TremoloContents> {
  static readonly schema = {
    name: 'tremolo',
    attributes: {
      color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
      'default-x': {
        type: 'label',
        label: 'default-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'default-y': {
        type: 'label',
        label: 'default-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
      'font-size': {
        type: 'optional',
        value: {
          type: 'choices',
          choices: [
            { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
            { type: 'float', min: -Infinity, max: Infinity },
          ],
        },
      },
      'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
      'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
      placement: { type: 'optional', value: { type: 'choices', choices: ['above', 'below'] } },
      'relative-x': {
        type: 'label',
        label: 'relative-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'relative-y': {
        type: 'label',
        label: 'relative-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      smufl: { type: 'optional', value: { type: 'string' } },
      type: { type: 'optional', value: { type: 'choices', choices: ['start', 'stop', 'single', 'unmeasured'] } },
    },
    contents: [
      { type: 'required', value: { type: 'label', label: 'tremolo-marks', value: { type: 'int', min: 0, max: 8 } } },
    ],
  } as const;

  readonly schema = Tremolo.schema;

  attributes: TremoloAttributes;
  contents: TremoloContents;

  constructor(opts?: { attributes?: Partial<TremoloAttributes>; contents?: TremoloContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Tremolo.schema);
    this.contents = opts?.contents ?? operations.zero(Tremolo.schema.contents);
  }
  getColor(): string | null {
    return this.attributes['color'];
  }
  setColor(color: string | null): Tremolo {
    this.attributes['color'] = color;
    return this;
  }
  getDefaultX(): number | null {
    return this.attributes['default-x'];
  }
  setDefaultX(defaultX: number | null): Tremolo {
    this.attributes['default-x'] = defaultX;
    return this;
  }
  getDefaultY(): number | null {
    return this.attributes['default-y'];
  }
  setDefaultY(defaultY: number | null): Tremolo {
    this.attributes['default-y'] = defaultY;
    return this;
  }
  getFontFamily(): string | null {
    return this.attributes['font-family'];
  }
  setFontFamily(fontFamily: string | null): Tremolo {
    this.attributes['font-family'] = fontFamily;
    return this;
  }
  getFontSize(): 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null {
    return this.attributes['font-size'];
  }
  setFontSize(
    fontSize: 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null
  ): Tremolo {
    this.attributes['font-size'] = fontSize;
    return this;
  }
  getFontStyle(): 'normal' | 'italic' | null {
    return this.attributes['font-style'];
  }
  setFontStyle(fontStyle: 'normal' | 'italic' | null): Tremolo {
    this.attributes['font-style'] = fontStyle;
    return this;
  }
  getFontWeight(): 'normal' | 'bold' | null {
    return this.attributes['font-weight'];
  }
  setFontWeight(fontWeight: 'normal' | 'bold' | null): Tremolo {
    this.attributes['font-weight'] = fontWeight;
    return this;
  }
  getPlacement(): 'above' | 'below' | null {
    return this.attributes['placement'];
  }
  setPlacement(placement: 'above' | 'below' | null): Tremolo {
    this.attributes['placement'] = placement;
    return this;
  }
  getRelativeX(): number | null {
    return this.attributes['relative-x'];
  }
  setRelativeX(relativeX: number | null): Tremolo {
    this.attributes['relative-x'] = relativeX;
    return this;
  }
  getRelativeY(): number | null {
    return this.attributes['relative-y'];
  }
  setRelativeY(relativeY: number | null): Tremolo {
    this.attributes['relative-y'] = relativeY;
    return this;
  }
  getSmufl(): string | null {
    return this.attributes['smufl'];
  }
  setSmufl(smufl: string | null): Tremolo {
    this.attributes['smufl'] = smufl;
    return this;
  }
  getType(): 'start' | 'stop' | 'single' | 'unmeasured' | null {
    return this.attributes['type'];
  }
  setType(type: 'start' | 'stop' | 'single' | 'unmeasured' | null): Tremolo {
    this.attributes['type'] = type;
    return this;
  }
  getTremoloMarks(): number {
    return this.contents[0];
  }
  setTremoloMarks(tremoloMarks: number): Tremolo {
    this.contents[0] = tremoloMarks;
    return this;
  }
}

export type HaydnAttributes = {
  accelerate: 'yes' | 'no' | null;
  beats: number | null;
  color: string | null;
  'default-x': number | null;
  'default-y': number | null;
  'font-family': string | null;
  'font-size': 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null;
  'font-style': 'normal' | 'italic' | null;
  'font-weight': 'normal' | 'bold' | null;
  'last-beat': number | null;
  placement: 'above' | 'below' | null;
  'relative-x': number | null;
  'relative-y': number | null;
  'second-beat': number | null;
  'start-note': 'below' | 'main' | 'upper' | null;
  'trill-step': 'unison' | 'half' | 'whole' | null;
  'two-note-turn': 'none' | 'whole' | 'half' | null;
};

export type HaydnContents = [];

export class Haydn implements XMLElement<'haydn', HaydnAttributes, HaydnContents> {
  static readonly schema = {
    name: 'haydn',
    attributes: {
      accelerate: { type: 'optional', value: { type: 'choices', choices: ['yes', 'no'] } },
      beats: { type: 'optional', value: { type: 'float', min: 2, max: Infinity } },
      color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
      'default-x': {
        type: 'label',
        label: 'default-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'default-y': {
        type: 'label',
        label: 'default-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
      'font-size': {
        type: 'optional',
        value: {
          type: 'choices',
          choices: [
            { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
            { type: 'float', min: -Infinity, max: Infinity },
          ],
        },
      },
      'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
      'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
      'last-beat': { type: 'optional', value: { type: 'float', min: 0, max: 100 } },
      placement: { type: 'optional', value: { type: 'choices', choices: ['above', 'below'] } },
      'relative-x': {
        type: 'label',
        label: 'relative-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'relative-y': {
        type: 'label',
        label: 'relative-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'second-beat': { type: 'optional', value: { type: 'float', min: 0, max: 100 } },
      'start-note': { type: 'optional', value: { type: 'choices', choices: ['below', 'main', 'upper'] } },
      'trill-step': { type: 'optional', value: { type: 'choices', choices: ['unison', 'half', 'whole'] } },
      'two-note-turn': { type: 'optional', value: { type: 'choices', choices: ['none', 'whole', 'half'] } },
    },
    contents: [],
  } as const;

  readonly schema = Haydn.schema;

  attributes: HaydnAttributes;
  contents: HaydnContents;

  constructor(opts?: { attributes?: Partial<HaydnAttributes>; contents?: HaydnContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Haydn.schema);
    this.contents = opts?.contents ?? operations.zero(Haydn.schema.contents);
  }
  getAccelerate(): 'yes' | 'no' | null {
    return this.attributes['accelerate'];
  }
  setAccelerate(accelerate: 'yes' | 'no' | null): Haydn {
    this.attributes['accelerate'] = accelerate;
    return this;
  }
  getBeats(): number | null {
    return this.attributes['beats'];
  }
  setBeats(beats: number | null): Haydn {
    this.attributes['beats'] = beats;
    return this;
  }
  getColor(): string | null {
    return this.attributes['color'];
  }
  setColor(color: string | null): Haydn {
    this.attributes['color'] = color;
    return this;
  }
  getDefaultX(): number | null {
    return this.attributes['default-x'];
  }
  setDefaultX(defaultX: number | null): Haydn {
    this.attributes['default-x'] = defaultX;
    return this;
  }
  getDefaultY(): number | null {
    return this.attributes['default-y'];
  }
  setDefaultY(defaultY: number | null): Haydn {
    this.attributes['default-y'] = defaultY;
    return this;
  }
  getFontFamily(): string | null {
    return this.attributes['font-family'];
  }
  setFontFamily(fontFamily: string | null): Haydn {
    this.attributes['font-family'] = fontFamily;
    return this;
  }
  getFontSize(): 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null {
    return this.attributes['font-size'];
  }
  setFontSize(
    fontSize: 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null
  ): Haydn {
    this.attributes['font-size'] = fontSize;
    return this;
  }
  getFontStyle(): 'normal' | 'italic' | null {
    return this.attributes['font-style'];
  }
  setFontStyle(fontStyle: 'normal' | 'italic' | null): Haydn {
    this.attributes['font-style'] = fontStyle;
    return this;
  }
  getFontWeight(): 'normal' | 'bold' | null {
    return this.attributes['font-weight'];
  }
  setFontWeight(fontWeight: 'normal' | 'bold' | null): Haydn {
    this.attributes['font-weight'] = fontWeight;
    return this;
  }
  getLastBeat(): number | null {
    return this.attributes['last-beat'];
  }
  setLastBeat(lastBeat: number | null): Haydn {
    this.attributes['last-beat'] = lastBeat;
    return this;
  }
  getPlacement(): 'above' | 'below' | null {
    return this.attributes['placement'];
  }
  setPlacement(placement: 'above' | 'below' | null): Haydn {
    this.attributes['placement'] = placement;
    return this;
  }
  getRelativeX(): number | null {
    return this.attributes['relative-x'];
  }
  setRelativeX(relativeX: number | null): Haydn {
    this.attributes['relative-x'] = relativeX;
    return this;
  }
  getRelativeY(): number | null {
    return this.attributes['relative-y'];
  }
  setRelativeY(relativeY: number | null): Haydn {
    this.attributes['relative-y'] = relativeY;
    return this;
  }
  getSecondBeat(): number | null {
    return this.attributes['second-beat'];
  }
  setSecondBeat(secondBeat: number | null): Haydn {
    this.attributes['second-beat'] = secondBeat;
    return this;
  }
  getStartNote(): 'below' | 'main' | 'upper' | null {
    return this.attributes['start-note'];
  }
  setStartNote(startNote: 'below' | 'main' | 'upper' | null): Haydn {
    this.attributes['start-note'] = startNote;
    return this;
  }
  getTrillStep(): 'unison' | 'half' | 'whole' | null {
    return this.attributes['trill-step'];
  }
  setTrillStep(trillStep: 'unison' | 'half' | 'whole' | null): Haydn {
    this.attributes['trill-step'] = trillStep;
    return this;
  }
  getTwoNoteTurn(): 'none' | 'whole' | 'half' | null {
    return this.attributes['two-note-turn'];
  }
  setTwoNoteTurn(twoNoteTurn: 'none' | 'whole' | 'half' | null): Haydn {
    this.attributes['two-note-turn'] = twoNoteTurn;
    return this;
  }
}

export type OtherOrnamentAttributes = {
  color: string | null;
  'default-x': number | null;
  'default-y': number | null;
  'font-family': string | null;
  'font-size': 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null;
  'font-style': 'normal' | 'italic' | null;
  'font-weight': 'normal' | 'bold' | null;
  placement: 'above' | 'below' | null;
  'relative-x': number | null;
  'relative-y': number | null;
  smufl: string | null;
};

export type OtherOrnamentContents = [string];

export class OtherOrnament implements XMLElement<'other-ornament', OtherOrnamentAttributes, OtherOrnamentContents> {
  static readonly schema = {
    name: 'other-ornament',
    attributes: {
      color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
      'default-x': {
        type: 'label',
        label: 'default-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'default-y': {
        type: 'label',
        label: 'default-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
      'font-size': {
        type: 'optional',
        value: {
          type: 'choices',
          choices: [
            { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
            { type: 'float', min: -Infinity, max: Infinity },
          ],
        },
      },
      'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
      'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
      placement: { type: 'optional', value: { type: 'choices', choices: ['above', 'below'] } },
      'relative-x': {
        type: 'label',
        label: 'relative-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'relative-y': {
        type: 'label',
        label: 'relative-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      smufl: { type: 'optional', value: { type: 'string' } },
    },
    contents: [{ type: 'required', value: { type: 'string' } }],
  } as const;

  readonly schema = OtherOrnament.schema;

  attributes: OtherOrnamentAttributes;
  contents: OtherOrnamentContents;

  constructor(opts?: { attributes?: Partial<OtherOrnamentAttributes>; contents?: OtherOrnamentContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, OtherOrnament.schema);
    this.contents = opts?.contents ?? operations.zero(OtherOrnament.schema.contents);
  }
  getColor(): string | null {
    return this.attributes['color'];
  }
  setColor(color: string | null): OtherOrnament {
    this.attributes['color'] = color;
    return this;
  }
  getDefaultX(): number | null {
    return this.attributes['default-x'];
  }
  setDefaultX(defaultX: number | null): OtherOrnament {
    this.attributes['default-x'] = defaultX;
    return this;
  }
  getDefaultY(): number | null {
    return this.attributes['default-y'];
  }
  setDefaultY(defaultY: number | null): OtherOrnament {
    this.attributes['default-y'] = defaultY;
    return this;
  }
  getFontFamily(): string | null {
    return this.attributes['font-family'];
  }
  setFontFamily(fontFamily: string | null): OtherOrnament {
    this.attributes['font-family'] = fontFamily;
    return this;
  }
  getFontSize(): 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null {
    return this.attributes['font-size'];
  }
  setFontSize(
    fontSize: 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null
  ): OtherOrnament {
    this.attributes['font-size'] = fontSize;
    return this;
  }
  getFontStyle(): 'normal' | 'italic' | null {
    return this.attributes['font-style'];
  }
  setFontStyle(fontStyle: 'normal' | 'italic' | null): OtherOrnament {
    this.attributes['font-style'] = fontStyle;
    return this;
  }
  getFontWeight(): 'normal' | 'bold' | null {
    return this.attributes['font-weight'];
  }
  setFontWeight(fontWeight: 'normal' | 'bold' | null): OtherOrnament {
    this.attributes['font-weight'] = fontWeight;
    return this;
  }
  getPlacement(): 'above' | 'below' | null {
    return this.attributes['placement'];
  }
  setPlacement(placement: 'above' | 'below' | null): OtherOrnament {
    this.attributes['placement'] = placement;
    return this;
  }
  getRelativeX(): number | null {
    return this.attributes['relative-x'];
  }
  setRelativeX(relativeX: number | null): OtherOrnament {
    this.attributes['relative-x'] = relativeX;
    return this;
  }
  getRelativeY(): number | null {
    return this.attributes['relative-y'];
  }
  setRelativeY(relativeY: number | null): OtherOrnament {
    this.attributes['relative-y'] = relativeY;
    return this;
  }
  getSmufl(): string | null {
    return this.attributes['smufl'];
  }
  setSmufl(smufl: string | null): OtherOrnament {
    this.attributes['smufl'] = smufl;
    return this;
  }
  getText(): string {
    return this.contents[0];
  }
  setText(text: string): OtherOrnament {
    this.contents[0] = text;
    return this;
  }
}

export type AccidentalMarkAttributes = {
  bracket: 'yes' | 'no' | null;
  color: string | null;
  'default-x': number | null;
  'default-y': number | null;
  'font-family': string | null;
  'font-size': 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null;
  'font-style': 'normal' | 'italic' | null;
  'font-weight': 'normal' | 'bold' | null;
  id: string | null;
  parentheses: 'yes' | 'no' | null;
  placement: 'above' | 'below' | null;
  'relative-x': number | null;
  'relative-y': number | null;
  size: 'cue' | 'full' | 'grace-cue' | 'large' | null;
  smufl: string | null;
};

export type AccidentalMarkContents = [
  | 'other'
  | 'sharp'
  | 'natural'
  | 'flat'
  | 'double-sharp'
  | 'sharp-sharp'
  | 'flat-flat'
  | 'natural-sharp'
  | 'natural-flat'
  | 'quarter-flat'
  | 'quarter-sharp'
  | 'three-quarters-flat'
  | 'three-quarters-sharp'
  | 'sharp-down'
  | 'sharp-up'
  | 'natural-down'
  | 'natural-up'
  | 'flat-down'
  | 'flat-up'
  | 'double-sharp-down'
  | 'double-sharp-up'
  | 'flat-flat-down'
  | 'flat-flat-up'
  | 'arrow-down'
  | 'arrow-up'
  | 'triple-sharp'
  | 'triple-flat'
  | 'slash-quarter-sharp'
  | 'slash-sharp'
  | 'slash-flat'
  | 'double-slash-flat'
  | 'sharp-1'
  | 'sharp-2'
  | 'sharp-3'
  | 'sharp-5'
  | 'flat-1'
  | 'flat-2'
  | 'flat-3'
  | 'flat-4'
  | 'sori'
  | 'koron'
];

export class AccidentalMark implements XMLElement<'accidental-mark', AccidentalMarkAttributes, AccidentalMarkContents> {
  static readonly schema = {
    name: 'accidental-mark',
    attributes: {
      bracket: { type: 'optional', value: { type: 'choices', choices: ['yes', 'no'] } },
      color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
      'default-x': {
        type: 'label',
        label: 'default-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'default-y': {
        type: 'label',
        label: 'default-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
      'font-size': {
        type: 'optional',
        value: {
          type: 'choices',
          choices: [
            { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
            { type: 'float', min: -Infinity, max: Infinity },
          ],
        },
      },
      'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
      'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
      id: { type: 'optional', value: { type: 'regex', pattern: /[A-Za-z_][A-Za-z0-9.-_]*/, zero: '_' } },
      parentheses: { type: 'optional', value: { type: 'choices', choices: ['yes', 'no'] } },
      placement: { type: 'optional', value: { type: 'choices', choices: ['above', 'below'] } },
      'relative-x': {
        type: 'label',
        label: 'relative-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'relative-y': {
        type: 'label',
        label: 'relative-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      size: { type: 'optional', value: { type: 'choices', choices: ['cue', 'full', 'grace-cue', 'large'] } },
      smufl: {
        type: 'optional',
        value: { type: 'regex', pattern: /(acc|medRenFla|medRenNatura|medRenShar|kievanAccidental)/, zero: 'acc' },
      },
    },
    contents: [
      {
        type: 'required',
        value: {
          type: 'label',
          label: 'accidental-value',
          value: {
            type: 'choices',
            choices: [
              'other',
              'sharp',
              'natural',
              'flat',
              'double-sharp',
              'sharp-sharp',
              'flat-flat',
              'natural-sharp',
              'natural-flat',
              'quarter-flat',
              'quarter-sharp',
              'three-quarters-flat',
              'three-quarters-sharp',
              'sharp-down',
              'sharp-up',
              'natural-down',
              'natural-up',
              'flat-down',
              'flat-up',
              'double-sharp-down',
              'double-sharp-up',
              'flat-flat-down',
              'flat-flat-up',
              'arrow-down',
              'arrow-up',
              'triple-sharp',
              'triple-flat',
              'slash-quarter-sharp',
              'slash-sharp',
              'slash-flat',
              'double-slash-flat',
              'sharp-1',
              'sharp-2',
              'sharp-3',
              'sharp-5',
              'flat-1',
              'flat-2',
              'flat-3',
              'flat-4',
              'sori',
              'koron',
            ],
          },
        },
      },
    ],
  } as const;

  readonly schema = AccidentalMark.schema;

  attributes: AccidentalMarkAttributes;
  contents: AccidentalMarkContents;

  constructor(opts?: { attributes?: Partial<AccidentalMarkAttributes>; contents?: AccidentalMarkContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, AccidentalMark.schema);
    this.contents = opts?.contents ?? operations.zero(AccidentalMark.schema.contents);
  }
  getBracket(): 'yes' | 'no' | null {
    return this.attributes['bracket'];
  }
  setBracket(bracket: 'yes' | 'no' | null): AccidentalMark {
    this.attributes['bracket'] = bracket;
    return this;
  }
  getColor(): string | null {
    return this.attributes['color'];
  }
  setColor(color: string | null): AccidentalMark {
    this.attributes['color'] = color;
    return this;
  }
  getDefaultX(): number | null {
    return this.attributes['default-x'];
  }
  setDefaultX(defaultX: number | null): AccidentalMark {
    this.attributes['default-x'] = defaultX;
    return this;
  }
  getDefaultY(): number | null {
    return this.attributes['default-y'];
  }
  setDefaultY(defaultY: number | null): AccidentalMark {
    this.attributes['default-y'] = defaultY;
    return this;
  }
  getFontFamily(): string | null {
    return this.attributes['font-family'];
  }
  setFontFamily(fontFamily: string | null): AccidentalMark {
    this.attributes['font-family'] = fontFamily;
    return this;
  }
  getFontSize(): 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null {
    return this.attributes['font-size'];
  }
  setFontSize(
    fontSize: 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null
  ): AccidentalMark {
    this.attributes['font-size'] = fontSize;
    return this;
  }
  getFontStyle(): 'normal' | 'italic' | null {
    return this.attributes['font-style'];
  }
  setFontStyle(fontStyle: 'normal' | 'italic' | null): AccidentalMark {
    this.attributes['font-style'] = fontStyle;
    return this;
  }
  getFontWeight(): 'normal' | 'bold' | null {
    return this.attributes['font-weight'];
  }
  setFontWeight(fontWeight: 'normal' | 'bold' | null): AccidentalMark {
    this.attributes['font-weight'] = fontWeight;
    return this;
  }
  getId(): string | null {
    return this.attributes['id'];
  }
  setId(id: string | null): AccidentalMark {
    this.attributes['id'] = id;
    return this;
  }
  getParentheses(): 'yes' | 'no' | null {
    return this.attributes['parentheses'];
  }
  setParentheses(parentheses: 'yes' | 'no' | null): AccidentalMark {
    this.attributes['parentheses'] = parentheses;
    return this;
  }
  getPlacement(): 'above' | 'below' | null {
    return this.attributes['placement'];
  }
  setPlacement(placement: 'above' | 'below' | null): AccidentalMark {
    this.attributes['placement'] = placement;
    return this;
  }
  getRelativeX(): number | null {
    return this.attributes['relative-x'];
  }
  setRelativeX(relativeX: number | null): AccidentalMark {
    this.attributes['relative-x'] = relativeX;
    return this;
  }
  getRelativeY(): number | null {
    return this.attributes['relative-y'];
  }
  setRelativeY(relativeY: number | null): AccidentalMark {
    this.attributes['relative-y'] = relativeY;
    return this;
  }
  getSize(): 'cue' | 'full' | 'grace-cue' | 'large' | null {
    return this.attributes['size'];
  }
  setSize(size: 'cue' | 'full' | 'grace-cue' | 'large' | null): AccidentalMark {
    this.attributes['size'] = size;
    return this;
  }
  getSmufl(): string | null {
    return this.attributes['smufl'];
  }
  setSmufl(smufl: string | null): AccidentalMark {
    this.attributes['smufl'] = smufl;
    return this;
  }
  getAccidentalValue():
    | 'other'
    | 'sharp'
    | 'natural'
    | 'flat'
    | 'double-sharp'
    | 'sharp-sharp'
    | 'flat-flat'
    | 'natural-sharp'
    | 'natural-flat'
    | 'quarter-flat'
    | 'quarter-sharp'
    | 'three-quarters-flat'
    | 'three-quarters-sharp'
    | 'sharp-down'
    | 'sharp-up'
    | 'natural-down'
    | 'natural-up'
    | 'flat-down'
    | 'flat-up'
    | 'double-sharp-down'
    | 'double-sharp-up'
    | 'flat-flat-down'
    | 'flat-flat-up'
    | 'arrow-down'
    | 'arrow-up'
    | 'triple-sharp'
    | 'triple-flat'
    | 'slash-quarter-sharp'
    | 'slash-sharp'
    | 'slash-flat'
    | 'double-slash-flat'
    | 'sharp-1'
    | 'sharp-2'
    | 'sharp-3'
    | 'sharp-5'
    | 'flat-1'
    | 'flat-2'
    | 'flat-3'
    | 'flat-4'
    | 'sori'
    | 'koron' {
    return this.contents[0];
  }
  setAccidentalValue(
    accidentalValue:
      | 'other'
      | 'sharp'
      | 'natural'
      | 'flat'
      | 'double-sharp'
      | 'sharp-sharp'
      | 'flat-flat'
      | 'natural-sharp'
      | 'natural-flat'
      | 'quarter-flat'
      | 'quarter-sharp'
      | 'three-quarters-flat'
      | 'three-quarters-sharp'
      | 'sharp-down'
      | 'sharp-up'
      | 'natural-down'
      | 'natural-up'
      | 'flat-down'
      | 'flat-up'
      | 'double-sharp-down'
      | 'double-sharp-up'
      | 'flat-flat-down'
      | 'flat-flat-up'
      | 'arrow-down'
      | 'arrow-up'
      | 'triple-sharp'
      | 'triple-flat'
      | 'slash-quarter-sharp'
      | 'slash-sharp'
      | 'slash-flat'
      | 'double-slash-flat'
      | 'sharp-1'
      | 'sharp-2'
      | 'sharp-3'
      | 'sharp-5'
      | 'flat-1'
      | 'flat-2'
      | 'flat-3'
      | 'flat-4'
      | 'sori'
      | 'koron'
  ): AccidentalMark {
    this.contents[0] = accidentalValue;
    return this;
  }
}

export type OrnamentsAttributes = { id: string | null };

export type OrnamentsContents = [
  Array<
    | TrillMark
    | Turn
    | DelayedTurn
    | InvertedTurn
    | DelayedInvertedTurn
    | VerticalTurn
    | InvertedVerticalTurn
    | Shake
    | WavyLine
    | Mordent
    | InvertedMordent
    | Schleifer
    | Tremolo
    | Haydn
    | OtherOrnament
  >,
  Array<AccidentalMark>
];

export class Ornaments implements XMLElement<'ornaments', OrnamentsAttributes, OrnamentsContents> {
  static readonly schema = {
    name: 'ornaments',
    attributes: { id: { type: 'optional', value: { type: 'regex', pattern: /[A-Za-z_][A-Za-z0-9.-_]*/, zero: '_' } } },
    contents: [
      {
        type: 'label',
        label: 'ornaments-values',
        value: {
          type: 'zeroOrMore',
          value: {
            type: 'choices',
            choices: [
              TrillMark,
              Turn,
              DelayedTurn,
              InvertedTurn,
              DelayedInvertedTurn,
              VerticalTurn,
              InvertedVerticalTurn,
              Shake,
              WavyLine,
              Mordent,
              InvertedMordent,
              Schleifer,
              Tremolo,
              Haydn,
              OtherOrnament,
            ],
          },
        },
      },
      { type: 'label', label: 'accidental-marks', value: { type: 'zeroOrMore', value: AccidentalMark } },
    ],
  } as const;

  readonly schema = Ornaments.schema;

  attributes: OrnamentsAttributes;
  contents: OrnamentsContents;

  constructor(opts?: { attributes?: Partial<OrnamentsAttributes>; contents?: OrnamentsContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Ornaments.schema);
    this.contents = opts?.contents ?? operations.zero(Ornaments.schema.contents);
  }
  getId(): string | null {
    return this.attributes['id'];
  }
  setId(id: string | null): Ornaments {
    this.attributes['id'] = id;
    return this;
  }
  getOrnamentsValues(): Array<
    | TrillMark
    | Turn
    | DelayedTurn
    | InvertedTurn
    | DelayedInvertedTurn
    | VerticalTurn
    | InvertedVerticalTurn
    | Shake
    | WavyLine
    | Mordent
    | InvertedMordent
    | Schleifer
    | Tremolo
    | Haydn
    | OtherOrnament
  > {
    return this.contents[0];
  }
  setOrnamentsValues(
    ornamentsValues: Array<
      | TrillMark
      | Turn
      | DelayedTurn
      | InvertedTurn
      | DelayedInvertedTurn
      | VerticalTurn
      | InvertedVerticalTurn
      | Shake
      | WavyLine
      | Mordent
      | InvertedMordent
      | Schleifer
      | Tremolo
      | Haydn
      | OtherOrnament
    >
  ): Ornaments {
    this.contents[0] = ornamentsValues;
    return this;
  }
  getAccidentalMarks(): Array<AccidentalMark> {
    return this.contents[1];
  }
  setAccidentalMarks(accidentalMarks: Array<AccidentalMark>): Ornaments {
    this.contents[1] = accidentalMarks;
    return this;
  }
}

export type UpBowAttributes = {
  color: string | null;
  'default-x': number | null;
  'default-y': number | null;
  'font-family': string | null;
  'font-size': 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null;
  'font-style': 'normal' | 'italic' | null;
  'font-weight': 'normal' | 'bold' | null;
  placement: 'above' | 'below' | null;
  'relative-x': number | null;
  'relative-y': number | null;
};

export type UpBowContents = [];

export class UpBow implements XMLElement<'up-bow', UpBowAttributes, UpBowContents> {
  static readonly schema = {
    name: 'up-bow',
    attributes: {
      color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
      'default-x': {
        type: 'label',
        label: 'default-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'default-y': {
        type: 'label',
        label: 'default-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
      'font-size': {
        type: 'optional',
        value: {
          type: 'choices',
          choices: [
            { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
            { type: 'float', min: -Infinity, max: Infinity },
          ],
        },
      },
      'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
      'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
      placement: { type: 'optional', value: { type: 'choices', choices: ['above', 'below'] } },
      'relative-x': {
        type: 'label',
        label: 'relative-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'relative-y': {
        type: 'label',
        label: 'relative-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
    },
    contents: [],
  } as const;

  readonly schema = UpBow.schema;

  attributes: UpBowAttributes;
  contents: UpBowContents;

  constructor(opts?: { attributes?: Partial<UpBowAttributes>; contents?: UpBowContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, UpBow.schema);
    this.contents = opts?.contents ?? operations.zero(UpBow.schema.contents);
  }
  getColor(): string | null {
    return this.attributes['color'];
  }
  setColor(color: string | null): UpBow {
    this.attributes['color'] = color;
    return this;
  }
  getDefaultX(): number | null {
    return this.attributes['default-x'];
  }
  setDefaultX(defaultX: number | null): UpBow {
    this.attributes['default-x'] = defaultX;
    return this;
  }
  getDefaultY(): number | null {
    return this.attributes['default-y'];
  }
  setDefaultY(defaultY: number | null): UpBow {
    this.attributes['default-y'] = defaultY;
    return this;
  }
  getFontFamily(): string | null {
    return this.attributes['font-family'];
  }
  setFontFamily(fontFamily: string | null): UpBow {
    this.attributes['font-family'] = fontFamily;
    return this;
  }
  getFontSize(): 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null {
    return this.attributes['font-size'];
  }
  setFontSize(
    fontSize: 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null
  ): UpBow {
    this.attributes['font-size'] = fontSize;
    return this;
  }
  getFontStyle(): 'normal' | 'italic' | null {
    return this.attributes['font-style'];
  }
  setFontStyle(fontStyle: 'normal' | 'italic' | null): UpBow {
    this.attributes['font-style'] = fontStyle;
    return this;
  }
  getFontWeight(): 'normal' | 'bold' | null {
    return this.attributes['font-weight'];
  }
  setFontWeight(fontWeight: 'normal' | 'bold' | null): UpBow {
    this.attributes['font-weight'] = fontWeight;
    return this;
  }
  getPlacement(): 'above' | 'below' | null {
    return this.attributes['placement'];
  }
  setPlacement(placement: 'above' | 'below' | null): UpBow {
    this.attributes['placement'] = placement;
    return this;
  }
  getRelativeX(): number | null {
    return this.attributes['relative-x'];
  }
  setRelativeX(relativeX: number | null): UpBow {
    this.attributes['relative-x'] = relativeX;
    return this;
  }
  getRelativeY(): number | null {
    return this.attributes['relative-y'];
  }
  setRelativeY(relativeY: number | null): UpBow {
    this.attributes['relative-y'] = relativeY;
    return this;
  }
}

export type DownBowAttributes = {
  color: string | null;
  'default-x': number | null;
  'default-y': number | null;
  'font-family': string | null;
  'font-size': 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null;
  'font-style': 'normal' | 'italic' | null;
  'font-weight': 'normal' | 'bold' | null;
  placement: 'above' | 'below' | null;
  'relative-x': number | null;
  'relative-y': number | null;
};

export type DownBowContents = [];

export class DownBow implements XMLElement<'down-bow', DownBowAttributes, DownBowContents> {
  static readonly schema = {
    name: 'down-bow',
    attributes: {
      color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
      'default-x': {
        type: 'label',
        label: 'default-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'default-y': {
        type: 'label',
        label: 'default-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
      'font-size': {
        type: 'optional',
        value: {
          type: 'choices',
          choices: [
            { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
            { type: 'float', min: -Infinity, max: Infinity },
          ],
        },
      },
      'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
      'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
      placement: { type: 'optional', value: { type: 'choices', choices: ['above', 'below'] } },
      'relative-x': {
        type: 'label',
        label: 'relative-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'relative-y': {
        type: 'label',
        label: 'relative-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
    },
    contents: [],
  } as const;

  readonly schema = DownBow.schema;

  attributes: DownBowAttributes;
  contents: DownBowContents;

  constructor(opts?: { attributes?: Partial<DownBowAttributes>; contents?: DownBowContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, DownBow.schema);
    this.contents = opts?.contents ?? operations.zero(DownBow.schema.contents);
  }
  getColor(): string | null {
    return this.attributes['color'];
  }
  setColor(color: string | null): DownBow {
    this.attributes['color'] = color;
    return this;
  }
  getDefaultX(): number | null {
    return this.attributes['default-x'];
  }
  setDefaultX(defaultX: number | null): DownBow {
    this.attributes['default-x'] = defaultX;
    return this;
  }
  getDefaultY(): number | null {
    return this.attributes['default-y'];
  }
  setDefaultY(defaultY: number | null): DownBow {
    this.attributes['default-y'] = defaultY;
    return this;
  }
  getFontFamily(): string | null {
    return this.attributes['font-family'];
  }
  setFontFamily(fontFamily: string | null): DownBow {
    this.attributes['font-family'] = fontFamily;
    return this;
  }
  getFontSize(): 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null {
    return this.attributes['font-size'];
  }
  setFontSize(
    fontSize: 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null
  ): DownBow {
    this.attributes['font-size'] = fontSize;
    return this;
  }
  getFontStyle(): 'normal' | 'italic' | null {
    return this.attributes['font-style'];
  }
  setFontStyle(fontStyle: 'normal' | 'italic' | null): DownBow {
    this.attributes['font-style'] = fontStyle;
    return this;
  }
  getFontWeight(): 'normal' | 'bold' | null {
    return this.attributes['font-weight'];
  }
  setFontWeight(fontWeight: 'normal' | 'bold' | null): DownBow {
    this.attributes['font-weight'] = fontWeight;
    return this;
  }
  getPlacement(): 'above' | 'below' | null {
    return this.attributes['placement'];
  }
  setPlacement(placement: 'above' | 'below' | null): DownBow {
    this.attributes['placement'] = placement;
    return this;
  }
  getRelativeX(): number | null {
    return this.attributes['relative-x'];
  }
  setRelativeX(relativeX: number | null): DownBow {
    this.attributes['relative-x'] = relativeX;
    return this;
  }
  getRelativeY(): number | null {
    return this.attributes['relative-y'];
  }
  setRelativeY(relativeY: number | null): DownBow {
    this.attributes['relative-y'] = relativeY;
    return this;
  }
}

export type NaturalAttributes = Record<string, unknown>;

export type NaturalContents = [];

export class Natural implements XMLElement<'natural', NaturalAttributes, NaturalContents> {
  static readonly schema = { name: 'natural', attributes: {}, contents: [] } as const;

  readonly schema = Natural.schema;

  attributes: NaturalAttributes;
  contents: NaturalContents;

  constructor(opts?: { attributes?: Partial<NaturalAttributes>; contents?: NaturalContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Natural.schema);
    this.contents = opts?.contents ?? operations.zero(Natural.schema.contents);
  }
}

export type ArtificialAttributes = Record<string, unknown>;

export type ArtificialContents = [];

export class Artificial implements XMLElement<'artificial', ArtificialAttributes, ArtificialContents> {
  static readonly schema = { name: 'artificial', attributes: {}, contents: [] } as const;

  readonly schema = Artificial.schema;

  attributes: ArtificialAttributes;
  contents: ArtificialContents;

  constructor(opts?: { attributes?: Partial<ArtificialAttributes>; contents?: ArtificialContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Artificial.schema);
    this.contents = opts?.contents ?? operations.zero(Artificial.schema.contents);
  }
}

export type BasePitchAttributes = Record<string, unknown>;

export type BasePitchContents = [];

export class BasePitch implements XMLElement<'base-pitch', BasePitchAttributes, BasePitchContents> {
  static readonly schema = { name: 'base-pitch', attributes: {}, contents: [] } as const;

  readonly schema = BasePitch.schema;

  attributes: BasePitchAttributes;
  contents: BasePitchContents;

  constructor(opts?: { attributes?: Partial<BasePitchAttributes>; contents?: BasePitchContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, BasePitch.schema);
    this.contents = opts?.contents ?? operations.zero(BasePitch.schema.contents);
  }
}

export type TouchingPitchAttributes = Record<string, unknown>;

export type TouchingPitchContents = [];

export class TouchingPitch implements XMLElement<'touching-pitch', TouchingPitchAttributes, TouchingPitchContents> {
  static readonly schema = { name: 'touching-pitch', attributes: {}, contents: [] } as const;

  readonly schema = TouchingPitch.schema;

  attributes: TouchingPitchAttributes;
  contents: TouchingPitchContents;

  constructor(opts?: { attributes?: Partial<TouchingPitchAttributes>; contents?: TouchingPitchContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, TouchingPitch.schema);
    this.contents = opts?.contents ?? operations.zero(TouchingPitch.schema.contents);
  }
}

export type SoundingPitchAttributes = Record<string, unknown>;

export type SoundingPitchContents = [];

export class SoundingPitch implements XMLElement<'sounding-pitch', SoundingPitchAttributes, SoundingPitchContents> {
  static readonly schema = { name: 'sounding-pitch', attributes: {}, contents: [] } as const;

  readonly schema = SoundingPitch.schema;

  attributes: SoundingPitchAttributes;
  contents: SoundingPitchContents;

  constructor(opts?: { attributes?: Partial<SoundingPitchAttributes>; contents?: SoundingPitchContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, SoundingPitch.schema);
    this.contents = opts?.contents ?? operations.zero(SoundingPitch.schema.contents);
  }
}

export type HarmonicAttributes = {
  color: string | null;
  'default-x': number | null;
  'default-y': number | null;
  'font-family': string | null;
  'font-size': 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null;
  'font-style': 'normal' | 'italic' | null;
  'font-weight': 'normal' | 'bold' | null;
  placement: 'above' | 'below' | null;
  'print-object': 'yes' | 'no' | null;
  'relative-x': number | null;
  'relative-y': number | null;
};

export type HarmonicContents = [Array<Natural | Artificial>, Array<BasePitch | TouchingPitch | SoundingPitch>];

export class Harmonic implements XMLElement<'harmonic', HarmonicAttributes, HarmonicContents> {
  static readonly schema = {
    name: 'harmonic',
    attributes: {
      color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
      'default-x': {
        type: 'label',
        label: 'default-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'default-y': {
        type: 'label',
        label: 'default-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
      'font-size': {
        type: 'optional',
        value: {
          type: 'choices',
          choices: [
            { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
            { type: 'float', min: -Infinity, max: Infinity },
          ],
        },
      },
      'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
      'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
      placement: { type: 'optional', value: { type: 'choices', choices: ['above', 'below'] } },
      'print-object': { type: 'optional', value: { type: 'choices', choices: ['yes', 'no'] } },
      'relative-x': {
        type: 'label',
        label: 'relative-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'relative-y': {
        type: 'label',
        label: 'relative-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
    },
    contents: [
      {
        type: 'label',
        label: 'types',
        value: { type: 'zeroOrMore', value: { type: 'choices', choices: [Natural, Artificial] } },
      },
      {
        type: 'label',
        label: 'pitches',
        value: { type: 'zeroOrMore', value: { type: 'choices', choices: [BasePitch, TouchingPitch, SoundingPitch] } },
      },
    ],
  } as const;

  readonly schema = Harmonic.schema;

  attributes: HarmonicAttributes;
  contents: HarmonicContents;

  constructor(opts?: { attributes?: Partial<HarmonicAttributes>; contents?: HarmonicContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Harmonic.schema);
    this.contents = opts?.contents ?? operations.zero(Harmonic.schema.contents);
  }
  getColor(): string | null {
    return this.attributes['color'];
  }
  setColor(color: string | null): Harmonic {
    this.attributes['color'] = color;
    return this;
  }
  getDefaultX(): number | null {
    return this.attributes['default-x'];
  }
  setDefaultX(defaultX: number | null): Harmonic {
    this.attributes['default-x'] = defaultX;
    return this;
  }
  getDefaultY(): number | null {
    return this.attributes['default-y'];
  }
  setDefaultY(defaultY: number | null): Harmonic {
    this.attributes['default-y'] = defaultY;
    return this;
  }
  getFontFamily(): string | null {
    return this.attributes['font-family'];
  }
  setFontFamily(fontFamily: string | null): Harmonic {
    this.attributes['font-family'] = fontFamily;
    return this;
  }
  getFontSize(): 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null {
    return this.attributes['font-size'];
  }
  setFontSize(
    fontSize: 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null
  ): Harmonic {
    this.attributes['font-size'] = fontSize;
    return this;
  }
  getFontStyle(): 'normal' | 'italic' | null {
    return this.attributes['font-style'];
  }
  setFontStyle(fontStyle: 'normal' | 'italic' | null): Harmonic {
    this.attributes['font-style'] = fontStyle;
    return this;
  }
  getFontWeight(): 'normal' | 'bold' | null {
    return this.attributes['font-weight'];
  }
  setFontWeight(fontWeight: 'normal' | 'bold' | null): Harmonic {
    this.attributes['font-weight'] = fontWeight;
    return this;
  }
  getPlacement(): 'above' | 'below' | null {
    return this.attributes['placement'];
  }
  setPlacement(placement: 'above' | 'below' | null): Harmonic {
    this.attributes['placement'] = placement;
    return this;
  }
  getPrintObject(): 'yes' | 'no' | null {
    return this.attributes['print-object'];
  }
  setPrintObject(printObject: 'yes' | 'no' | null): Harmonic {
    this.attributes['print-object'] = printObject;
    return this;
  }
  getRelativeX(): number | null {
    return this.attributes['relative-x'];
  }
  setRelativeX(relativeX: number | null): Harmonic {
    this.attributes['relative-x'] = relativeX;
    return this;
  }
  getRelativeY(): number | null {
    return this.attributes['relative-y'];
  }
  setRelativeY(relativeY: number | null): Harmonic {
    this.attributes['relative-y'] = relativeY;
    return this;
  }
  getTypes(): Array<Natural | Artificial> {
    return this.contents[0];
  }
  setTypes(types: Array<Natural | Artificial>): Harmonic {
    this.contents[0] = types;
    return this;
  }
  getPitches(): Array<BasePitch | TouchingPitch | SoundingPitch> {
    return this.contents[1];
  }
  setPitches(pitches: Array<BasePitch | TouchingPitch | SoundingPitch>): Harmonic {
    this.contents[1] = pitches;
    return this;
  }
}

export type OpenStringAttributes = {
  color: string | null;
  'default-x': number | null;
  'default-y': number | null;
  'font-family': string | null;
  'font-size': 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null;
  'font-style': 'normal' | 'italic' | null;
  'font-weight': 'normal' | 'bold' | null;
  placement: 'above' | 'below' | null;
  'relative-x': number | null;
  'relative-y': number | null;
};

export type OpenStringContents = [];

export class OpenString implements XMLElement<'open-string', OpenStringAttributes, OpenStringContents> {
  static readonly schema = {
    name: 'open-string',
    attributes: {
      color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
      'default-x': {
        type: 'label',
        label: 'default-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'default-y': {
        type: 'label',
        label: 'default-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
      'font-size': {
        type: 'optional',
        value: {
          type: 'choices',
          choices: [
            { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
            { type: 'float', min: -Infinity, max: Infinity },
          ],
        },
      },
      'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
      'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
      placement: { type: 'optional', value: { type: 'choices', choices: ['above', 'below'] } },
      'relative-x': {
        type: 'label',
        label: 'relative-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'relative-y': {
        type: 'label',
        label: 'relative-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
    },
    contents: [],
  } as const;

  readonly schema = OpenString.schema;

  attributes: OpenStringAttributes;
  contents: OpenStringContents;

  constructor(opts?: { attributes?: Partial<OpenStringAttributes>; contents?: OpenStringContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, OpenString.schema);
    this.contents = opts?.contents ?? operations.zero(OpenString.schema.contents);
  }
  getColor(): string | null {
    return this.attributes['color'];
  }
  setColor(color: string | null): OpenString {
    this.attributes['color'] = color;
    return this;
  }
  getDefaultX(): number | null {
    return this.attributes['default-x'];
  }
  setDefaultX(defaultX: number | null): OpenString {
    this.attributes['default-x'] = defaultX;
    return this;
  }
  getDefaultY(): number | null {
    return this.attributes['default-y'];
  }
  setDefaultY(defaultY: number | null): OpenString {
    this.attributes['default-y'] = defaultY;
    return this;
  }
  getFontFamily(): string | null {
    return this.attributes['font-family'];
  }
  setFontFamily(fontFamily: string | null): OpenString {
    this.attributes['font-family'] = fontFamily;
    return this;
  }
  getFontSize(): 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null {
    return this.attributes['font-size'];
  }
  setFontSize(
    fontSize: 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null
  ): OpenString {
    this.attributes['font-size'] = fontSize;
    return this;
  }
  getFontStyle(): 'normal' | 'italic' | null {
    return this.attributes['font-style'];
  }
  setFontStyle(fontStyle: 'normal' | 'italic' | null): OpenString {
    this.attributes['font-style'] = fontStyle;
    return this;
  }
  getFontWeight(): 'normal' | 'bold' | null {
    return this.attributes['font-weight'];
  }
  setFontWeight(fontWeight: 'normal' | 'bold' | null): OpenString {
    this.attributes['font-weight'] = fontWeight;
    return this;
  }
  getPlacement(): 'above' | 'below' | null {
    return this.attributes['placement'];
  }
  setPlacement(placement: 'above' | 'below' | null): OpenString {
    this.attributes['placement'] = placement;
    return this;
  }
  getRelativeX(): number | null {
    return this.attributes['relative-x'];
  }
  setRelativeX(relativeX: number | null): OpenString {
    this.attributes['relative-x'] = relativeX;
    return this;
  }
  getRelativeY(): number | null {
    return this.attributes['relative-y'];
  }
  setRelativeY(relativeY: number | null): OpenString {
    this.attributes['relative-y'] = relativeY;
    return this;
  }
}

export type ThumbPositionAttributes = {
  color: string | null;
  'default-x': number | null;
  'default-y': number | null;
  'font-family': string | null;
  'font-size': 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null;
  'font-style': 'normal' | 'italic' | null;
  'font-weight': 'normal' | 'bold' | null;
  placement: 'above' | 'below' | null;
  'relative-x': number | null;
  'relative-y': number | null;
};

export type ThumbPositionContents = [];

export class ThumbPosition implements XMLElement<'thumb-position', ThumbPositionAttributes, ThumbPositionContents> {
  static readonly schema = {
    name: 'thumb-position',
    attributes: {
      color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
      'default-x': {
        type: 'label',
        label: 'default-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'default-y': {
        type: 'label',
        label: 'default-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
      'font-size': {
        type: 'optional',
        value: {
          type: 'choices',
          choices: [
            { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
            { type: 'float', min: -Infinity, max: Infinity },
          ],
        },
      },
      'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
      'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
      placement: { type: 'optional', value: { type: 'choices', choices: ['above', 'below'] } },
      'relative-x': {
        type: 'label',
        label: 'relative-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'relative-y': {
        type: 'label',
        label: 'relative-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
    },
    contents: [],
  } as const;

  readonly schema = ThumbPosition.schema;

  attributes: ThumbPositionAttributes;
  contents: ThumbPositionContents;

  constructor(opts?: { attributes?: Partial<ThumbPositionAttributes>; contents?: ThumbPositionContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, ThumbPosition.schema);
    this.contents = opts?.contents ?? operations.zero(ThumbPosition.schema.contents);
  }
  getColor(): string | null {
    return this.attributes['color'];
  }
  setColor(color: string | null): ThumbPosition {
    this.attributes['color'] = color;
    return this;
  }
  getDefaultX(): number | null {
    return this.attributes['default-x'];
  }
  setDefaultX(defaultX: number | null): ThumbPosition {
    this.attributes['default-x'] = defaultX;
    return this;
  }
  getDefaultY(): number | null {
    return this.attributes['default-y'];
  }
  setDefaultY(defaultY: number | null): ThumbPosition {
    this.attributes['default-y'] = defaultY;
    return this;
  }
  getFontFamily(): string | null {
    return this.attributes['font-family'];
  }
  setFontFamily(fontFamily: string | null): ThumbPosition {
    this.attributes['font-family'] = fontFamily;
    return this;
  }
  getFontSize(): 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null {
    return this.attributes['font-size'];
  }
  setFontSize(
    fontSize: 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null
  ): ThumbPosition {
    this.attributes['font-size'] = fontSize;
    return this;
  }
  getFontStyle(): 'normal' | 'italic' | null {
    return this.attributes['font-style'];
  }
  setFontStyle(fontStyle: 'normal' | 'italic' | null): ThumbPosition {
    this.attributes['font-style'] = fontStyle;
    return this;
  }
  getFontWeight(): 'normal' | 'bold' | null {
    return this.attributes['font-weight'];
  }
  setFontWeight(fontWeight: 'normal' | 'bold' | null): ThumbPosition {
    this.attributes['font-weight'] = fontWeight;
    return this;
  }
  getPlacement(): 'above' | 'below' | null {
    return this.attributes['placement'];
  }
  setPlacement(placement: 'above' | 'below' | null): ThumbPosition {
    this.attributes['placement'] = placement;
    return this;
  }
  getRelativeX(): number | null {
    return this.attributes['relative-x'];
  }
  setRelativeX(relativeX: number | null): ThumbPosition {
    this.attributes['relative-x'] = relativeX;
    return this;
  }
  getRelativeY(): number | null {
    return this.attributes['relative-y'];
  }
  setRelativeY(relativeY: number | null): ThumbPosition {
    this.attributes['relative-y'] = relativeY;
    return this;
  }
}

export type FingeringAttributes = {
  alternate: 'yes' | 'no' | null;
  color: string | null;
  'default-x': number | null;
  'default-y': number | null;
  'font-family': string | null;
  'font-size': 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null;
  'font-style': 'normal' | 'italic' | null;
  'font-weight': 'normal' | 'bold' | null;
  placement: 'above' | 'below' | null;
  'relative-x': number | null;
  'relative-y': number | null;
  substitution: 'yes' | 'no' | null;
};

export type FingeringContents = [string];

export class Fingering implements XMLElement<'fingering', FingeringAttributes, FingeringContents> {
  static readonly schema = {
    name: 'fingering',
    attributes: {
      alternate: { type: 'optional', value: { type: 'choices', choices: ['yes', 'no'] } },
      color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
      'default-x': {
        type: 'label',
        label: 'default-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'default-y': {
        type: 'label',
        label: 'default-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
      'font-size': {
        type: 'optional',
        value: {
          type: 'choices',
          choices: [
            { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
            { type: 'float', min: -Infinity, max: Infinity },
          ],
        },
      },
      'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
      'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
      placement: { type: 'optional', value: { type: 'choices', choices: ['above', 'below'] } },
      'relative-x': {
        type: 'label',
        label: 'relative-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'relative-y': {
        type: 'label',
        label: 'relative-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      substitution: { type: 'optional', value: { type: 'choices', choices: ['yes', 'no'] } },
    },
    contents: [{ type: 'string' }],
  } as const;

  readonly schema = Fingering.schema;

  attributes: FingeringAttributes;
  contents: FingeringContents;

  constructor(opts?: { attributes?: Partial<FingeringAttributes>; contents?: FingeringContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Fingering.schema);
    this.contents = opts?.contents ?? operations.zero(Fingering.schema.contents);
  }
  getAlternate(): 'yes' | 'no' | null {
    return this.attributes['alternate'];
  }
  setAlternate(alternate: 'yes' | 'no' | null): Fingering {
    this.attributes['alternate'] = alternate;
    return this;
  }
  getColor(): string | null {
    return this.attributes['color'];
  }
  setColor(color: string | null): Fingering {
    this.attributes['color'] = color;
    return this;
  }
  getDefaultX(): number | null {
    return this.attributes['default-x'];
  }
  setDefaultX(defaultX: number | null): Fingering {
    this.attributes['default-x'] = defaultX;
    return this;
  }
  getDefaultY(): number | null {
    return this.attributes['default-y'];
  }
  setDefaultY(defaultY: number | null): Fingering {
    this.attributes['default-y'] = defaultY;
    return this;
  }
  getFontFamily(): string | null {
    return this.attributes['font-family'];
  }
  setFontFamily(fontFamily: string | null): Fingering {
    this.attributes['font-family'] = fontFamily;
    return this;
  }
  getFontSize(): 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null {
    return this.attributes['font-size'];
  }
  setFontSize(
    fontSize: 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null
  ): Fingering {
    this.attributes['font-size'] = fontSize;
    return this;
  }
  getFontStyle(): 'normal' | 'italic' | null {
    return this.attributes['font-style'];
  }
  setFontStyle(fontStyle: 'normal' | 'italic' | null): Fingering {
    this.attributes['font-style'] = fontStyle;
    return this;
  }
  getFontWeight(): 'normal' | 'bold' | null {
    return this.attributes['font-weight'];
  }
  setFontWeight(fontWeight: 'normal' | 'bold' | null): Fingering {
    this.attributes['font-weight'] = fontWeight;
    return this;
  }
  getPlacement(): 'above' | 'below' | null {
    return this.attributes['placement'];
  }
  setPlacement(placement: 'above' | 'below' | null): Fingering {
    this.attributes['placement'] = placement;
    return this;
  }
  getRelativeX(): number | null {
    return this.attributes['relative-x'];
  }
  setRelativeX(relativeX: number | null): Fingering {
    this.attributes['relative-x'] = relativeX;
    return this;
  }
  getRelativeY(): number | null {
    return this.attributes['relative-y'];
  }
  setRelativeY(relativeY: number | null): Fingering {
    this.attributes['relative-y'] = relativeY;
    return this;
  }
  getSubstitution(): 'yes' | 'no' | null {
    return this.attributes['substitution'];
  }
  setSubstitution(substitution: 'yes' | 'no' | null): Fingering {
    this.attributes['substitution'] = substitution;
    return this;
  }
  getText(): string {
    return this.contents[0];
  }
  setText(text: string): Fingering {
    this.contents[0] = text;
    return this;
  }
}

export type PluckAttributes = {
  color: string | null;
  'default-x': number | null;
  'default-y': number | null;
  'font-family': string | null;
  'font-size': 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null;
  'font-style': 'normal' | 'italic' | null;
  'font-weight': 'normal' | 'bold' | null;
  placement: 'above' | 'below' | null;
  'relative-x': number | null;
  'relative-y': number | null;
};

export type PluckContents = [string];

export class Pluck implements XMLElement<'pluck', PluckAttributes, PluckContents> {
  static readonly schema = {
    name: 'pluck',
    attributes: {
      color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
      'default-x': {
        type: 'label',
        label: 'default-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'default-y': {
        type: 'label',
        label: 'default-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
      'font-size': {
        type: 'optional',
        value: {
          type: 'choices',
          choices: [
            { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
            { type: 'float', min: -Infinity, max: Infinity },
          ],
        },
      },
      'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
      'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
      placement: { type: 'optional', value: { type: 'choices', choices: ['above', 'below'] } },
      'relative-x': {
        type: 'label',
        label: 'relative-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'relative-y': {
        type: 'label',
        label: 'relative-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
    },
    contents: [{ type: 'required', value: { type: 'string' } }],
  } as const;

  readonly schema = Pluck.schema;

  attributes: PluckAttributes;
  contents: PluckContents;

  constructor(opts?: { attributes?: Partial<PluckAttributes>; contents?: PluckContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Pluck.schema);
    this.contents = opts?.contents ?? operations.zero(Pluck.schema.contents);
  }
  getColor(): string | null {
    return this.attributes['color'];
  }
  setColor(color: string | null): Pluck {
    this.attributes['color'] = color;
    return this;
  }
  getDefaultX(): number | null {
    return this.attributes['default-x'];
  }
  setDefaultX(defaultX: number | null): Pluck {
    this.attributes['default-x'] = defaultX;
    return this;
  }
  getDefaultY(): number | null {
    return this.attributes['default-y'];
  }
  setDefaultY(defaultY: number | null): Pluck {
    this.attributes['default-y'] = defaultY;
    return this;
  }
  getFontFamily(): string | null {
    return this.attributes['font-family'];
  }
  setFontFamily(fontFamily: string | null): Pluck {
    this.attributes['font-family'] = fontFamily;
    return this;
  }
  getFontSize(): 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null {
    return this.attributes['font-size'];
  }
  setFontSize(
    fontSize: 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null
  ): Pluck {
    this.attributes['font-size'] = fontSize;
    return this;
  }
  getFontStyle(): 'normal' | 'italic' | null {
    return this.attributes['font-style'];
  }
  setFontStyle(fontStyle: 'normal' | 'italic' | null): Pluck {
    this.attributes['font-style'] = fontStyle;
    return this;
  }
  getFontWeight(): 'normal' | 'bold' | null {
    return this.attributes['font-weight'];
  }
  setFontWeight(fontWeight: 'normal' | 'bold' | null): Pluck {
    this.attributes['font-weight'] = fontWeight;
    return this;
  }
  getPlacement(): 'above' | 'below' | null {
    return this.attributes['placement'];
  }
  setPlacement(placement: 'above' | 'below' | null): Pluck {
    this.attributes['placement'] = placement;
    return this;
  }
  getRelativeX(): number | null {
    return this.attributes['relative-x'];
  }
  setRelativeX(relativeX: number | null): Pluck {
    this.attributes['relative-x'] = relativeX;
    return this;
  }
  getRelativeY(): number | null {
    return this.attributes['relative-y'];
  }
  setRelativeY(relativeY: number | null): Pluck {
    this.attributes['relative-y'] = relativeY;
    return this;
  }
  getText(): string {
    return this.contents[0];
  }
  setText(text: string): Pluck {
    this.contents[0] = text;
    return this;
  }
}

export type DoubleTongueAttributes = {
  color: string | null;
  'default-x': number | null;
  'default-y': number | null;
  'font-family': string | null;
  'font-size': 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null;
  'font-style': 'normal' | 'italic' | null;
  'font-weight': 'normal' | 'bold' | null;
  placement: 'above' | 'below' | null;
  'relative-x': number | null;
  'relative-y': number | null;
};

export type DoubleTongueContents = [];

export class DoubleTongue implements XMLElement<'double-tongue', DoubleTongueAttributes, DoubleTongueContents> {
  static readonly schema = {
    name: 'double-tongue',
    attributes: {
      color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
      'default-x': {
        type: 'label',
        label: 'default-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'default-y': {
        type: 'label',
        label: 'default-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
      'font-size': {
        type: 'optional',
        value: {
          type: 'choices',
          choices: [
            { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
            { type: 'float', min: -Infinity, max: Infinity },
          ],
        },
      },
      'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
      'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
      placement: { type: 'optional', value: { type: 'choices', choices: ['above', 'below'] } },
      'relative-x': {
        type: 'label',
        label: 'relative-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'relative-y': {
        type: 'label',
        label: 'relative-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
    },
    contents: [],
  } as const;

  readonly schema = DoubleTongue.schema;

  attributes: DoubleTongueAttributes;
  contents: DoubleTongueContents;

  constructor(opts?: { attributes?: Partial<DoubleTongueAttributes>; contents?: DoubleTongueContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, DoubleTongue.schema);
    this.contents = opts?.contents ?? operations.zero(DoubleTongue.schema.contents);
  }
  getColor(): string | null {
    return this.attributes['color'];
  }
  setColor(color: string | null): DoubleTongue {
    this.attributes['color'] = color;
    return this;
  }
  getDefaultX(): number | null {
    return this.attributes['default-x'];
  }
  setDefaultX(defaultX: number | null): DoubleTongue {
    this.attributes['default-x'] = defaultX;
    return this;
  }
  getDefaultY(): number | null {
    return this.attributes['default-y'];
  }
  setDefaultY(defaultY: number | null): DoubleTongue {
    this.attributes['default-y'] = defaultY;
    return this;
  }
  getFontFamily(): string | null {
    return this.attributes['font-family'];
  }
  setFontFamily(fontFamily: string | null): DoubleTongue {
    this.attributes['font-family'] = fontFamily;
    return this;
  }
  getFontSize(): 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null {
    return this.attributes['font-size'];
  }
  setFontSize(
    fontSize: 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null
  ): DoubleTongue {
    this.attributes['font-size'] = fontSize;
    return this;
  }
  getFontStyle(): 'normal' | 'italic' | null {
    return this.attributes['font-style'];
  }
  setFontStyle(fontStyle: 'normal' | 'italic' | null): DoubleTongue {
    this.attributes['font-style'] = fontStyle;
    return this;
  }
  getFontWeight(): 'normal' | 'bold' | null {
    return this.attributes['font-weight'];
  }
  setFontWeight(fontWeight: 'normal' | 'bold' | null): DoubleTongue {
    this.attributes['font-weight'] = fontWeight;
    return this;
  }
  getPlacement(): 'above' | 'below' | null {
    return this.attributes['placement'];
  }
  setPlacement(placement: 'above' | 'below' | null): DoubleTongue {
    this.attributes['placement'] = placement;
    return this;
  }
  getRelativeX(): number | null {
    return this.attributes['relative-x'];
  }
  setRelativeX(relativeX: number | null): DoubleTongue {
    this.attributes['relative-x'] = relativeX;
    return this;
  }
  getRelativeY(): number | null {
    return this.attributes['relative-y'];
  }
  setRelativeY(relativeY: number | null): DoubleTongue {
    this.attributes['relative-y'] = relativeY;
    return this;
  }
}

export type TripleTongueAttributes = {
  color: string | null;
  'default-x': number | null;
  'default-y': number | null;
  'font-family': string | null;
  'font-size': 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null;
  'font-style': 'normal' | 'italic' | null;
  'font-weight': 'normal' | 'bold' | null;
  placement: 'above' | 'below' | null;
  'relative-x': number | null;
  'relative-y': number | null;
};

export type TripleTongueContents = [];

export class TripleTongue implements XMLElement<'triple-tongue', TripleTongueAttributes, TripleTongueContents> {
  static readonly schema = {
    name: 'triple-tongue',
    attributes: {
      color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
      'default-x': {
        type: 'label',
        label: 'default-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'default-y': {
        type: 'label',
        label: 'default-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
      'font-size': {
        type: 'optional',
        value: {
          type: 'choices',
          choices: [
            { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
            { type: 'float', min: -Infinity, max: Infinity },
          ],
        },
      },
      'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
      'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
      placement: { type: 'optional', value: { type: 'choices', choices: ['above', 'below'] } },
      'relative-x': {
        type: 'label',
        label: 'relative-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'relative-y': {
        type: 'label',
        label: 'relative-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
    },
    contents: [],
  } as const;

  readonly schema = TripleTongue.schema;

  attributes: TripleTongueAttributes;
  contents: TripleTongueContents;

  constructor(opts?: { attributes?: Partial<TripleTongueAttributes>; contents?: TripleTongueContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, TripleTongue.schema);
    this.contents = opts?.contents ?? operations.zero(TripleTongue.schema.contents);
  }
  getColor(): string | null {
    return this.attributes['color'];
  }
  setColor(color: string | null): TripleTongue {
    this.attributes['color'] = color;
    return this;
  }
  getDefaultX(): number | null {
    return this.attributes['default-x'];
  }
  setDefaultX(defaultX: number | null): TripleTongue {
    this.attributes['default-x'] = defaultX;
    return this;
  }
  getDefaultY(): number | null {
    return this.attributes['default-y'];
  }
  setDefaultY(defaultY: number | null): TripleTongue {
    this.attributes['default-y'] = defaultY;
    return this;
  }
  getFontFamily(): string | null {
    return this.attributes['font-family'];
  }
  setFontFamily(fontFamily: string | null): TripleTongue {
    this.attributes['font-family'] = fontFamily;
    return this;
  }
  getFontSize(): 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null {
    return this.attributes['font-size'];
  }
  setFontSize(
    fontSize: 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null
  ): TripleTongue {
    this.attributes['font-size'] = fontSize;
    return this;
  }
  getFontStyle(): 'normal' | 'italic' | null {
    return this.attributes['font-style'];
  }
  setFontStyle(fontStyle: 'normal' | 'italic' | null): TripleTongue {
    this.attributes['font-style'] = fontStyle;
    return this;
  }
  getFontWeight(): 'normal' | 'bold' | null {
    return this.attributes['font-weight'];
  }
  setFontWeight(fontWeight: 'normal' | 'bold' | null): TripleTongue {
    this.attributes['font-weight'] = fontWeight;
    return this;
  }
  getPlacement(): 'above' | 'below' | null {
    return this.attributes['placement'];
  }
  setPlacement(placement: 'above' | 'below' | null): TripleTongue {
    this.attributes['placement'] = placement;
    return this;
  }
  getRelativeX(): number | null {
    return this.attributes['relative-x'];
  }
  setRelativeX(relativeX: number | null): TripleTongue {
    this.attributes['relative-x'] = relativeX;
    return this;
  }
  getRelativeY(): number | null {
    return this.attributes['relative-y'];
  }
  setRelativeY(relativeY: number | null): TripleTongue {
    this.attributes['relative-y'] = relativeY;
    return this;
  }
}

export type StoppedAttributes = {
  color: string | null;
  'default-x': number | null;
  'default-y': number | null;
  'font-family': string | null;
  'font-size': 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null;
  'font-style': 'normal' | 'italic' | null;
  'font-weight': 'normal' | 'bold' | null;
  placement: 'above' | 'below' | null;
  'relative-x': number | null;
  'relative-y': number | null;
};

export type StoppedContents = [];

export class Stopped implements XMLElement<'stopped', StoppedAttributes, StoppedContents> {
  static readonly schema = {
    name: 'stopped',
    attributes: {
      color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
      'default-x': {
        type: 'label',
        label: 'default-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'default-y': {
        type: 'label',
        label: 'default-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
      'font-size': {
        type: 'optional',
        value: {
          type: 'choices',
          choices: [
            { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
            { type: 'float', min: -Infinity, max: Infinity },
          ],
        },
      },
      'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
      'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
      placement: { type: 'optional', value: { type: 'choices', choices: ['above', 'below'] } },
      'relative-x': {
        type: 'label',
        label: 'relative-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'relative-y': {
        type: 'label',
        label: 'relative-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
    },
    contents: [],
  } as const;

  readonly schema = Stopped.schema;

  attributes: StoppedAttributes;
  contents: StoppedContents;

  constructor(opts?: { attributes?: Partial<StoppedAttributes>; contents?: StoppedContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Stopped.schema);
    this.contents = opts?.contents ?? operations.zero(Stopped.schema.contents);
  }
  getColor(): string | null {
    return this.attributes['color'];
  }
  setColor(color: string | null): Stopped {
    this.attributes['color'] = color;
    return this;
  }
  getDefaultX(): number | null {
    return this.attributes['default-x'];
  }
  setDefaultX(defaultX: number | null): Stopped {
    this.attributes['default-x'] = defaultX;
    return this;
  }
  getDefaultY(): number | null {
    return this.attributes['default-y'];
  }
  setDefaultY(defaultY: number | null): Stopped {
    this.attributes['default-y'] = defaultY;
    return this;
  }
  getFontFamily(): string | null {
    return this.attributes['font-family'];
  }
  setFontFamily(fontFamily: string | null): Stopped {
    this.attributes['font-family'] = fontFamily;
    return this;
  }
  getFontSize(): 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null {
    return this.attributes['font-size'];
  }
  setFontSize(
    fontSize: 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null
  ): Stopped {
    this.attributes['font-size'] = fontSize;
    return this;
  }
  getFontStyle(): 'normal' | 'italic' | null {
    return this.attributes['font-style'];
  }
  setFontStyle(fontStyle: 'normal' | 'italic' | null): Stopped {
    this.attributes['font-style'] = fontStyle;
    return this;
  }
  getFontWeight(): 'normal' | 'bold' | null {
    return this.attributes['font-weight'];
  }
  setFontWeight(fontWeight: 'normal' | 'bold' | null): Stopped {
    this.attributes['font-weight'] = fontWeight;
    return this;
  }
  getPlacement(): 'above' | 'below' | null {
    return this.attributes['placement'];
  }
  setPlacement(placement: 'above' | 'below' | null): Stopped {
    this.attributes['placement'] = placement;
    return this;
  }
  getRelativeX(): number | null {
    return this.attributes['relative-x'];
  }
  setRelativeX(relativeX: number | null): Stopped {
    this.attributes['relative-x'] = relativeX;
    return this;
  }
  getRelativeY(): number | null {
    return this.attributes['relative-y'];
  }
  setRelativeY(relativeY: number | null): Stopped {
    this.attributes['relative-y'] = relativeY;
    return this;
  }
}

export type SnapPizzicatoAttributes = {
  color: string | null;
  'default-x': number | null;
  'default-y': number | null;
  'font-family': string | null;
  'font-size': 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null;
  'font-style': 'normal' | 'italic' | null;
  'font-weight': 'normal' | 'bold' | null;
  placement: 'above' | 'below' | null;
  'relative-x': number | null;
  'relative-y': number | null;
};

export type SnapPizzicatoContents = [];

export class SnapPizzicato implements XMLElement<'snap-pizzicato', SnapPizzicatoAttributes, SnapPizzicatoContents> {
  static readonly schema = {
    name: 'snap-pizzicato',
    attributes: {
      color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
      'default-x': {
        type: 'label',
        label: 'default-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'default-y': {
        type: 'label',
        label: 'default-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
      'font-size': {
        type: 'optional',
        value: {
          type: 'choices',
          choices: [
            { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
            { type: 'float', min: -Infinity, max: Infinity },
          ],
        },
      },
      'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
      'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
      placement: { type: 'optional', value: { type: 'choices', choices: ['above', 'below'] } },
      'relative-x': {
        type: 'label',
        label: 'relative-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'relative-y': {
        type: 'label',
        label: 'relative-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
    },
    contents: [],
  } as const;

  readonly schema = SnapPizzicato.schema;

  attributes: SnapPizzicatoAttributes;
  contents: SnapPizzicatoContents;

  constructor(opts?: { attributes?: Partial<SnapPizzicatoAttributes>; contents?: SnapPizzicatoContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, SnapPizzicato.schema);
    this.contents = opts?.contents ?? operations.zero(SnapPizzicato.schema.contents);
  }
  getColor(): string | null {
    return this.attributes['color'];
  }
  setColor(color: string | null): SnapPizzicato {
    this.attributes['color'] = color;
    return this;
  }
  getDefaultX(): number | null {
    return this.attributes['default-x'];
  }
  setDefaultX(defaultX: number | null): SnapPizzicato {
    this.attributes['default-x'] = defaultX;
    return this;
  }
  getDefaultY(): number | null {
    return this.attributes['default-y'];
  }
  setDefaultY(defaultY: number | null): SnapPizzicato {
    this.attributes['default-y'] = defaultY;
    return this;
  }
  getFontFamily(): string | null {
    return this.attributes['font-family'];
  }
  setFontFamily(fontFamily: string | null): SnapPizzicato {
    this.attributes['font-family'] = fontFamily;
    return this;
  }
  getFontSize(): 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null {
    return this.attributes['font-size'];
  }
  setFontSize(
    fontSize: 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null
  ): SnapPizzicato {
    this.attributes['font-size'] = fontSize;
    return this;
  }
  getFontStyle(): 'normal' | 'italic' | null {
    return this.attributes['font-style'];
  }
  setFontStyle(fontStyle: 'normal' | 'italic' | null): SnapPizzicato {
    this.attributes['font-style'] = fontStyle;
    return this;
  }
  getFontWeight(): 'normal' | 'bold' | null {
    return this.attributes['font-weight'];
  }
  setFontWeight(fontWeight: 'normal' | 'bold' | null): SnapPizzicato {
    this.attributes['font-weight'] = fontWeight;
    return this;
  }
  getPlacement(): 'above' | 'below' | null {
    return this.attributes['placement'];
  }
  setPlacement(placement: 'above' | 'below' | null): SnapPizzicato {
    this.attributes['placement'] = placement;
    return this;
  }
  getRelativeX(): number | null {
    return this.attributes['relative-x'];
  }
  setRelativeX(relativeX: number | null): SnapPizzicato {
    this.attributes['relative-x'] = relativeX;
    return this;
  }
  getRelativeY(): number | null {
    return this.attributes['relative-y'];
  }
  setRelativeY(relativeY: number | null): SnapPizzicato {
    this.attributes['relative-y'] = relativeY;
    return this;
  }
}

export type FretAttributes = {
  color: string | null;
  'font-family': string | null;
  'font-size': 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null;
  'font-style': 'normal' | 'italic' | null;
  'font-weight': 'normal' | 'bold' | null;
};

export type FretContents = [number];

export class Fret implements XMLElement<'fret', FretAttributes, FretContents> {
  static readonly schema = {
    name: 'fret',
    attributes: {
      color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
      'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
      'font-size': {
        type: 'optional',
        value: {
          type: 'choices',
          choices: [
            { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
            { type: 'float', min: -Infinity, max: Infinity },
          ],
        },
      },
      'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
      'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
    },
    contents: [
      {
        type: 'label',
        label: 'fret-value',
        value: { type: 'required', value: { type: 'int', min: 0, max: Infinity } },
      },
    ],
  } as const;

  readonly schema = Fret.schema;

  attributes: FretAttributes;
  contents: FretContents;

  constructor(opts?: { attributes?: Partial<FretAttributes>; contents?: FretContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Fret.schema);
    this.contents = opts?.contents ?? operations.zero(Fret.schema.contents);
  }
  getColor(): string | null {
    return this.attributes['color'];
  }
  setColor(color: string | null): Fret {
    this.attributes['color'] = color;
    return this;
  }
  getFontFamily(): string | null {
    return this.attributes['font-family'];
  }
  setFontFamily(fontFamily: string | null): Fret {
    this.attributes['font-family'] = fontFamily;
    return this;
  }
  getFontSize(): 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null {
    return this.attributes['font-size'];
  }
  setFontSize(
    fontSize: 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null
  ): Fret {
    this.attributes['font-size'] = fontSize;
    return this;
  }
  getFontStyle(): 'normal' | 'italic' | null {
    return this.attributes['font-style'];
  }
  setFontStyle(fontStyle: 'normal' | 'italic' | null): Fret {
    this.attributes['font-style'] = fontStyle;
    return this;
  }
  getFontWeight(): 'normal' | 'bold' | null {
    return this.attributes['font-weight'];
  }
  setFontWeight(fontWeight: 'normal' | 'bold' | null): Fret {
    this.attributes['font-weight'] = fontWeight;
    return this;
  }
  getFretValue(): number {
    return this.contents[0];
  }
  setFretValue(fretValue: number): Fret {
    this.contents[0] = fretValue;
    return this;
  }
}

export type StringAttributes = {
  color: string | null;
  'default-x': number | null;
  'default-y': number | null;
  'font-family': string | null;
  'font-size': 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null;
  'font-style': 'normal' | 'italic' | null;
  'font-weight': 'normal' | 'bold' | null;
  placement: 'above' | 'below' | null;
  'relative-x': number | null;
  'relative-y': number | null;
};

export type StringContents = [number];

export class String implements XMLElement<'string', StringAttributes, StringContents> {
  static readonly schema = {
    name: 'string',
    attributes: {
      color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
      'default-x': {
        type: 'label',
        label: 'default-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'default-y': {
        type: 'label',
        label: 'default-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
      'font-size': {
        type: 'optional',
        value: {
          type: 'choices',
          choices: [
            { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
            { type: 'float', min: -Infinity, max: Infinity },
          ],
        },
      },
      'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
      'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
      placement: { type: 'optional', value: { type: 'choices', choices: ['above', 'below'] } },
      'relative-x': {
        type: 'label',
        label: 'relative-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'relative-y': {
        type: 'label',
        label: 'relative-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
    },
    contents: [{ type: 'label', label: 'string-number', value: { type: 'int', min: 1, max: Infinity } }],
  } as const;

  readonly schema = String.schema;

  attributes: StringAttributes;
  contents: StringContents;

  constructor(opts?: { attributes?: Partial<StringAttributes>; contents?: StringContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, String.schema);
    this.contents = opts?.contents ?? operations.zero(String.schema.contents);
  }
  getColor(): string | null {
    return this.attributes['color'];
  }
  setColor(color: string | null): String {
    this.attributes['color'] = color;
    return this;
  }
  getDefaultX(): number | null {
    return this.attributes['default-x'];
  }
  setDefaultX(defaultX: number | null): String {
    this.attributes['default-x'] = defaultX;
    return this;
  }
  getDefaultY(): number | null {
    return this.attributes['default-y'];
  }
  setDefaultY(defaultY: number | null): String {
    this.attributes['default-y'] = defaultY;
    return this;
  }
  getFontFamily(): string | null {
    return this.attributes['font-family'];
  }
  setFontFamily(fontFamily: string | null): String {
    this.attributes['font-family'] = fontFamily;
    return this;
  }
  getFontSize(): 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null {
    return this.attributes['font-size'];
  }
  setFontSize(
    fontSize: 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null
  ): String {
    this.attributes['font-size'] = fontSize;
    return this;
  }
  getFontStyle(): 'normal' | 'italic' | null {
    return this.attributes['font-style'];
  }
  setFontStyle(fontStyle: 'normal' | 'italic' | null): String {
    this.attributes['font-style'] = fontStyle;
    return this;
  }
  getFontWeight(): 'normal' | 'bold' | null {
    return this.attributes['font-weight'];
  }
  setFontWeight(fontWeight: 'normal' | 'bold' | null): String {
    this.attributes['font-weight'] = fontWeight;
    return this;
  }
  getPlacement(): 'above' | 'below' | null {
    return this.attributes['placement'];
  }
  setPlacement(placement: 'above' | 'below' | null): String {
    this.attributes['placement'] = placement;
    return this;
  }
  getRelativeX(): number | null {
    return this.attributes['relative-x'];
  }
  setRelativeX(relativeX: number | null): String {
    this.attributes['relative-x'] = relativeX;
    return this;
  }
  getRelativeY(): number | null {
    return this.attributes['relative-y'];
  }
  setRelativeY(relativeY: number | null): String {
    this.attributes['relative-y'] = relativeY;
    return this;
  }
  getStringNumber(): number {
    return this.contents[0];
  }
  setStringNumber(stringNumber: number): String {
    this.contents[0] = stringNumber;
    return this;
  }
}

export type HammerOnAttributes = {
  type: 'start' | 'stop';
  color: string | null;
  'default-x': number | null;
  'default-y': number | null;
  'font-family': string | null;
  'font-size': 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null;
  'font-style': 'normal' | 'italic' | null;
  'font-weight': 'normal' | 'bold' | null;
  number: number | null;
  placement: 'above' | 'below' | null;
  'relative-x': number | null;
  'relative-y': number | null;
};

export type HammerOnContents = [string];

export class HammerOn implements XMLElement<'hammer-on', HammerOnAttributes, HammerOnContents> {
  static readonly schema = {
    name: 'hammer-on',
    attributes: {
      type: { type: 'required', value: { type: 'choices', choices: ['start', 'stop'] } },
      color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
      'default-x': {
        type: 'label',
        label: 'default-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'default-y': {
        type: 'label',
        label: 'default-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
      'font-size': {
        type: 'optional',
        value: {
          type: 'choices',
          choices: [
            { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
            { type: 'float', min: -Infinity, max: Infinity },
          ],
        },
      },
      'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
      'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
      number: { type: 'optional', value: { type: 'int', min: 1, max: 16 } },
      placement: { type: 'optional', value: { type: 'choices', choices: ['above', 'below'] } },
      'relative-x': {
        type: 'label',
        label: 'relative-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'relative-y': {
        type: 'label',
        label: 'relative-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
    },
    contents: [{ type: 'required', value: { type: 'string' } }],
  } as const;

  readonly schema = HammerOn.schema;

  attributes: HammerOnAttributes;
  contents: HammerOnContents;

  constructor(opts?: { attributes?: Partial<HammerOnAttributes>; contents?: HammerOnContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, HammerOn.schema);
    this.contents = opts?.contents ?? operations.zero(HammerOn.schema.contents);
  }
  getType(): 'start' | 'stop' {
    return this.attributes['type'];
  }
  setType(type: 'start' | 'stop'): HammerOn {
    this.attributes['type'] = type;
    return this;
  }
  getColor(): string | null {
    return this.attributes['color'];
  }
  setColor(color: string | null): HammerOn {
    this.attributes['color'] = color;
    return this;
  }
  getDefaultX(): number | null {
    return this.attributes['default-x'];
  }
  setDefaultX(defaultX: number | null): HammerOn {
    this.attributes['default-x'] = defaultX;
    return this;
  }
  getDefaultY(): number | null {
    return this.attributes['default-y'];
  }
  setDefaultY(defaultY: number | null): HammerOn {
    this.attributes['default-y'] = defaultY;
    return this;
  }
  getFontFamily(): string | null {
    return this.attributes['font-family'];
  }
  setFontFamily(fontFamily: string | null): HammerOn {
    this.attributes['font-family'] = fontFamily;
    return this;
  }
  getFontSize(): 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null {
    return this.attributes['font-size'];
  }
  setFontSize(
    fontSize: 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null
  ): HammerOn {
    this.attributes['font-size'] = fontSize;
    return this;
  }
  getFontStyle(): 'normal' | 'italic' | null {
    return this.attributes['font-style'];
  }
  setFontStyle(fontStyle: 'normal' | 'italic' | null): HammerOn {
    this.attributes['font-style'] = fontStyle;
    return this;
  }
  getFontWeight(): 'normal' | 'bold' | null {
    return this.attributes['font-weight'];
  }
  setFontWeight(fontWeight: 'normal' | 'bold' | null): HammerOn {
    this.attributes['font-weight'] = fontWeight;
    return this;
  }
  getNumber(): number | null {
    return this.attributes['number'];
  }
  setNumber(number: number | null): HammerOn {
    this.attributes['number'] = number;
    return this;
  }
  getPlacement(): 'above' | 'below' | null {
    return this.attributes['placement'];
  }
  setPlacement(placement: 'above' | 'below' | null): HammerOn {
    this.attributes['placement'] = placement;
    return this;
  }
  getRelativeX(): number | null {
    return this.attributes['relative-x'];
  }
  setRelativeX(relativeX: number | null): HammerOn {
    this.attributes['relative-x'] = relativeX;
    return this;
  }
  getRelativeY(): number | null {
    return this.attributes['relative-y'];
  }
  setRelativeY(relativeY: number | null): HammerOn {
    this.attributes['relative-y'] = relativeY;
    return this;
  }
  getText(): string {
    return this.contents[0];
  }
  setText(text: string): HammerOn {
    this.contents[0] = text;
    return this;
  }
}

export type PullOffAttributes = {
  type: 'start' | 'stop';
  color: string | null;
  'default-x': number | null;
  'default-y': number | null;
  'font-family': string | null;
  'font-size': 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null;
  'font-style': 'normal' | 'italic' | null;
  'font-weight': 'normal' | 'bold' | null;
  number: number | null;
  placement: 'above' | 'below' | null;
  'relative-x': number | null;
  'relative-y': number | null;
};

export type PullOffContents = [string];

export class PullOff implements XMLElement<'pull-off', PullOffAttributes, PullOffContents> {
  static readonly schema = {
    name: 'pull-off',
    attributes: {
      type: { type: 'required', value: { type: 'choices', choices: ['start', 'stop'] } },
      color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
      'default-x': {
        type: 'label',
        label: 'default-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'default-y': {
        type: 'label',
        label: 'default-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
      'font-size': {
        type: 'optional',
        value: {
          type: 'choices',
          choices: [
            { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
            { type: 'float', min: -Infinity, max: Infinity },
          ],
        },
      },
      'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
      'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
      number: { type: 'optional', value: { type: 'int', min: 1, max: 16 } },
      placement: { type: 'optional', value: { type: 'choices', choices: ['above', 'below'] } },
      'relative-x': {
        type: 'label',
        label: 'relative-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'relative-y': {
        type: 'label',
        label: 'relative-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
    },
    contents: [{ type: 'string' }],
  } as const;

  readonly schema = PullOff.schema;

  attributes: PullOffAttributes;
  contents: PullOffContents;

  constructor(opts?: { attributes?: Partial<PullOffAttributes>; contents?: PullOffContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, PullOff.schema);
    this.contents = opts?.contents ?? operations.zero(PullOff.schema.contents);
  }
  getType(): 'start' | 'stop' {
    return this.attributes['type'];
  }
  setType(type: 'start' | 'stop'): PullOff {
    this.attributes['type'] = type;
    return this;
  }
  getColor(): string | null {
    return this.attributes['color'];
  }
  setColor(color: string | null): PullOff {
    this.attributes['color'] = color;
    return this;
  }
  getDefaultX(): number | null {
    return this.attributes['default-x'];
  }
  setDefaultX(defaultX: number | null): PullOff {
    this.attributes['default-x'] = defaultX;
    return this;
  }
  getDefaultY(): number | null {
    return this.attributes['default-y'];
  }
  setDefaultY(defaultY: number | null): PullOff {
    this.attributes['default-y'] = defaultY;
    return this;
  }
  getFontFamily(): string | null {
    return this.attributes['font-family'];
  }
  setFontFamily(fontFamily: string | null): PullOff {
    this.attributes['font-family'] = fontFamily;
    return this;
  }
  getFontSize(): 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null {
    return this.attributes['font-size'];
  }
  setFontSize(
    fontSize: 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null
  ): PullOff {
    this.attributes['font-size'] = fontSize;
    return this;
  }
  getFontStyle(): 'normal' | 'italic' | null {
    return this.attributes['font-style'];
  }
  setFontStyle(fontStyle: 'normal' | 'italic' | null): PullOff {
    this.attributes['font-style'] = fontStyle;
    return this;
  }
  getFontWeight(): 'normal' | 'bold' | null {
    return this.attributes['font-weight'];
  }
  setFontWeight(fontWeight: 'normal' | 'bold' | null): PullOff {
    this.attributes['font-weight'] = fontWeight;
    return this;
  }
  getNumber(): number | null {
    return this.attributes['number'];
  }
  setNumber(number: number | null): PullOff {
    this.attributes['number'] = number;
    return this;
  }
  getPlacement(): 'above' | 'below' | null {
    return this.attributes['placement'];
  }
  setPlacement(placement: 'above' | 'below' | null): PullOff {
    this.attributes['placement'] = placement;
    return this;
  }
  getRelativeX(): number | null {
    return this.attributes['relative-x'];
  }
  setRelativeX(relativeX: number | null): PullOff {
    this.attributes['relative-x'] = relativeX;
    return this;
  }
  getRelativeY(): number | null {
    return this.attributes['relative-y'];
  }
  setRelativeY(relativeY: number | null): PullOff {
    this.attributes['relative-y'] = relativeY;
    return this;
  }
  getText(): string {
    return this.contents[0];
  }
  setText(text: string): PullOff {
    this.contents[0] = text;
    return this;
  }
}

export type BendAlterAttributes = Record<string, unknown>;

export type BendAlterContents = [number];

export class BendAlter implements XMLElement<'bend-alter', BendAlterAttributes, BendAlterContents> {
  static readonly schema = {
    name: 'bend-alter',
    attributes: {},
    contents: [
      {
        type: 'required',
        value: { type: 'label', label: 'semitones', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
    ],
  } as const;

  readonly schema = BendAlter.schema;

  attributes: BendAlterAttributes;
  contents: BendAlterContents;

  constructor(opts?: { attributes?: Partial<BendAlterAttributes>; contents?: BendAlterContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, BendAlter.schema);
    this.contents = opts?.contents ?? operations.zero(BendAlter.schema.contents);
  }

  getSemitones(): number {
    return this.contents[0];
  }
  setSemitones(semitones: number): BendAlter {
    this.contents[0] = semitones;
    return this;
  }
}

export type PreBendAttributes = Record<string, unknown>;

export type PreBendContents = [];

export class PreBend implements XMLElement<'pre-bend', PreBendAttributes, PreBendContents> {
  static readonly schema = { name: 'pre-bend', attributes: {}, contents: [] } as const;

  readonly schema = PreBend.schema;

  attributes: PreBendAttributes;
  contents: PreBendContents;

  constructor(opts?: { attributes?: Partial<PreBendAttributes>; contents?: PreBendContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, PreBend.schema);
    this.contents = opts?.contents ?? operations.zero(PreBend.schema.contents);
  }
}

export type ReleaseAttributes = { offset: number | null };

export type ReleaseContents = [];

export class Release implements XMLElement<'release', ReleaseAttributes, ReleaseContents> {
  static readonly schema = {
    name: 'release',
    attributes: { offset: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } } },
    contents: [],
  } as const;

  readonly schema = Release.schema;

  attributes: ReleaseAttributes;
  contents: ReleaseContents;

  constructor(opts?: { attributes?: Partial<ReleaseAttributes>; contents?: ReleaseContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Release.schema);
    this.contents = opts?.contents ?? operations.zero(Release.schema.contents);
  }
  getOffset(): number | null {
    return this.attributes['offset'];
  }
  setOffset(offset: number | null): Release {
    this.attributes['offset'] = offset;
    return this;
  }
}

export type WithBarAttributes = {
  color: string | null;
  'default-x': number | null;
  'default-y': number | null;
  'first-beat': number | null;
  'font-family': string | null;
  'font-size': 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null;
  'font-style': 'normal' | 'italic' | null;
  'font-weight': 'normal' | 'bold' | null;
  placement: 'above' | 'below' | null;
  'relative-x': number | null;
  'relative-y': number | null;
};

export type WithBarContents = [string];

export class WithBar implements XMLElement<'with-bar', WithBarAttributes, WithBarContents> {
  static readonly schema = {
    name: 'with-bar',
    attributes: {
      color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
      'default-x': {
        type: 'label',
        label: 'default-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'default-y': {
        type: 'label',
        label: 'default-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'first-beat': { type: 'optional', value: { type: 'float', min: 0, max: 100 } },
      'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
      'font-size': {
        type: 'optional',
        value: {
          type: 'choices',
          choices: [
            { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
            { type: 'float', min: -Infinity, max: Infinity },
          ],
        },
      },
      'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
      'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
      placement: { type: 'optional', value: { type: 'choices', choices: ['above', 'below'] } },
      'relative-x': {
        type: 'label',
        label: 'relative-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'relative-y': {
        type: 'label',
        label: 'relative-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
    },
    contents: [{ type: 'required', value: { type: 'string' } }],
  } as const;

  readonly schema = WithBar.schema;

  attributes: WithBarAttributes;
  contents: WithBarContents;

  constructor(opts?: { attributes?: Partial<WithBarAttributes>; contents?: WithBarContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, WithBar.schema);
    this.contents = opts?.contents ?? operations.zero(WithBar.schema.contents);
  }
  getColor(): string | null {
    return this.attributes['color'];
  }
  setColor(color: string | null): WithBar {
    this.attributes['color'] = color;
    return this;
  }
  getDefaultX(): number | null {
    return this.attributes['default-x'];
  }
  setDefaultX(defaultX: number | null): WithBar {
    this.attributes['default-x'] = defaultX;
    return this;
  }
  getDefaultY(): number | null {
    return this.attributes['default-y'];
  }
  setDefaultY(defaultY: number | null): WithBar {
    this.attributes['default-y'] = defaultY;
    return this;
  }
  getFirstBeat(): number | null {
    return this.attributes['first-beat'];
  }
  setFirstBeat(firstBeat: number | null): WithBar {
    this.attributes['first-beat'] = firstBeat;
    return this;
  }
  getFontFamily(): string | null {
    return this.attributes['font-family'];
  }
  setFontFamily(fontFamily: string | null): WithBar {
    this.attributes['font-family'] = fontFamily;
    return this;
  }
  getFontSize(): 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null {
    return this.attributes['font-size'];
  }
  setFontSize(
    fontSize: 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null
  ): WithBar {
    this.attributes['font-size'] = fontSize;
    return this;
  }
  getFontStyle(): 'normal' | 'italic' | null {
    return this.attributes['font-style'];
  }
  setFontStyle(fontStyle: 'normal' | 'italic' | null): WithBar {
    this.attributes['font-style'] = fontStyle;
    return this;
  }
  getFontWeight(): 'normal' | 'bold' | null {
    return this.attributes['font-weight'];
  }
  setFontWeight(fontWeight: 'normal' | 'bold' | null): WithBar {
    this.attributes['font-weight'] = fontWeight;
    return this;
  }
  getPlacement(): 'above' | 'below' | null {
    return this.attributes['placement'];
  }
  setPlacement(placement: 'above' | 'below' | null): WithBar {
    this.attributes['placement'] = placement;
    return this;
  }
  getRelativeX(): number | null {
    return this.attributes['relative-x'];
  }
  setRelativeX(relativeX: number | null): WithBar {
    this.attributes['relative-x'] = relativeX;
    return this;
  }
  getRelativeY(): number | null {
    return this.attributes['relative-y'];
  }
  setRelativeY(relativeY: number | null): WithBar {
    this.attributes['relative-y'] = relativeY;
    return this;
  }
  getText(): string {
    return this.contents[0];
  }
  setText(text: string): WithBar {
    this.contents[0] = text;
    return this;
  }
}

export type BendAttributes = {
  accelerate: 'yes' | 'no' | null;
  beats: number | null;
  color: string | null;
  'default-x': number | null;
  'default-y': number | null;
  'first-beat': number | null;
  'font-family': string | null;
  'font-size': 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null;
  'font-style': 'normal' | 'italic' | null;
  'font-weight': 'normal' | 'bold' | null;
  'last-beat': number | null;
  'relative-x': number | null;
  'relative-y': number | null;
  shape: 'angled' | 'curved' | null;
};

export type BendContents = [BendAlter, Array<PreBend | Release>, WithBar | null];

export class Bend implements XMLElement<'bend', BendAttributes, BendContents> {
  static readonly schema = {
    name: 'bend',
    attributes: {
      accelerate: { type: 'optional', value: { type: 'choices', choices: ['yes', 'no'] } },
      beats: { type: 'optional', value: { type: 'float', min: 2, max: Infinity } },
      color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
      'default-x': {
        type: 'label',
        label: 'default-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'default-y': {
        type: 'label',
        label: 'default-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'first-beat': { type: 'optional', value: { type: 'float', min: 0, max: 100 } },
      'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
      'font-size': {
        type: 'optional',
        value: {
          type: 'choices',
          choices: [
            { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
            { type: 'float', min: -Infinity, max: Infinity },
          ],
        },
      },
      'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
      'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
      'last-beat': { type: 'optional', value: { type: 'float', min: 0, max: 100 } },
      'relative-x': {
        type: 'label',
        label: 'relative-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'relative-y': {
        type: 'label',
        label: 'relative-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      shape: { type: 'optional', value: { type: 'choices', choices: ['angled', 'curved'] } },
    },
    contents: [
      { type: 'required', value: BendAlter },
      {
        type: 'label',
        label: 'bends',
        value: { type: 'zeroOrMore', value: { type: 'choices', choices: [PreBend, Release] } },
      },
      { type: 'optional', value: WithBar },
    ],
  } as const;

  readonly schema = Bend.schema;

  attributes: BendAttributes;
  contents: BendContents;

  constructor(opts?: { attributes?: Partial<BendAttributes>; contents?: BendContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Bend.schema);
    this.contents = opts?.contents ?? operations.zero(Bend.schema.contents);
  }
  getAccelerate(): 'yes' | 'no' | null {
    return this.attributes['accelerate'];
  }
  setAccelerate(accelerate: 'yes' | 'no' | null): Bend {
    this.attributes['accelerate'] = accelerate;
    return this;
  }
  getBeats(): number | null {
    return this.attributes['beats'];
  }
  setBeats(beats: number | null): Bend {
    this.attributes['beats'] = beats;
    return this;
  }
  getColor(): string | null {
    return this.attributes['color'];
  }
  setColor(color: string | null): Bend {
    this.attributes['color'] = color;
    return this;
  }
  getDefaultX(): number | null {
    return this.attributes['default-x'];
  }
  setDefaultX(defaultX: number | null): Bend {
    this.attributes['default-x'] = defaultX;
    return this;
  }
  getDefaultY(): number | null {
    return this.attributes['default-y'];
  }
  setDefaultY(defaultY: number | null): Bend {
    this.attributes['default-y'] = defaultY;
    return this;
  }
  getFirstBeat(): number | null {
    return this.attributes['first-beat'];
  }
  setFirstBeat(firstBeat: number | null): Bend {
    this.attributes['first-beat'] = firstBeat;
    return this;
  }
  getFontFamily(): string | null {
    return this.attributes['font-family'];
  }
  setFontFamily(fontFamily: string | null): Bend {
    this.attributes['font-family'] = fontFamily;
    return this;
  }
  getFontSize(): 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null {
    return this.attributes['font-size'];
  }
  setFontSize(
    fontSize: 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null
  ): Bend {
    this.attributes['font-size'] = fontSize;
    return this;
  }
  getFontStyle(): 'normal' | 'italic' | null {
    return this.attributes['font-style'];
  }
  setFontStyle(fontStyle: 'normal' | 'italic' | null): Bend {
    this.attributes['font-style'] = fontStyle;
    return this;
  }
  getFontWeight(): 'normal' | 'bold' | null {
    return this.attributes['font-weight'];
  }
  setFontWeight(fontWeight: 'normal' | 'bold' | null): Bend {
    this.attributes['font-weight'] = fontWeight;
    return this;
  }
  getLastBeat(): number | null {
    return this.attributes['last-beat'];
  }
  setLastBeat(lastBeat: number | null): Bend {
    this.attributes['last-beat'] = lastBeat;
    return this;
  }
  getRelativeX(): number | null {
    return this.attributes['relative-x'];
  }
  setRelativeX(relativeX: number | null): Bend {
    this.attributes['relative-x'] = relativeX;
    return this;
  }
  getRelativeY(): number | null {
    return this.attributes['relative-y'];
  }
  setRelativeY(relativeY: number | null): Bend {
    this.attributes['relative-y'] = relativeY;
    return this;
  }
  getShape(): 'angled' | 'curved' | null {
    return this.attributes['shape'];
  }
  setShape(shape: 'angled' | 'curved' | null): Bend {
    this.attributes['shape'] = shape;
    return this;
  }
  getBendAlter(): BendAlter {
    return this.contents[0];
  }
  setBendAlter(bendAlter: BendAlter): Bend {
    this.contents[0] = bendAlter;
    return this;
  }
  getBends(): Array<PreBend | Release> {
    return this.contents[1];
  }
  setBends(bends: Array<PreBend | Release>): Bend {
    this.contents[1] = bends;
    return this;
  }
  getWithBar(): WithBar | null {
    return this.contents[2];
  }
  setWithBar(withBar: WithBar | null): Bend {
    this.contents[2] = withBar;
    return this;
  }
}

export type TapAttributes = {
  color: string | null;
  'default-x': number | null;
  'default-y': number | null;
  'font-family': string | null;
  'font-size': 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null;
  'font-style': 'normal' | 'italic' | null;
  'font-weight': 'normal' | 'bold' | null;
  hand: 'left' | 'right' | null;
  placement: 'above' | 'below' | null;
  'relative-x': number | null;
  'relative-y': number | null;
};

export type TapContents = [string | null];

export class Tap implements XMLElement<'tap', TapAttributes, TapContents> {
  static readonly schema = {
    name: 'tap',
    attributes: {
      color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
      'default-x': {
        type: 'label',
        label: 'default-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'default-y': {
        type: 'label',
        label: 'default-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
      'font-size': {
        type: 'optional',
        value: {
          type: 'choices',
          choices: [
            { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
            { type: 'float', min: -Infinity, max: Infinity },
          ],
        },
      },
      'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
      'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
      hand: { type: 'optional', value: { type: 'choices', choices: ['left', 'right'] } },
      placement: { type: 'optional', value: { type: 'choices', choices: ['above', 'below'] } },
      'relative-x': {
        type: 'label',
        label: 'relative-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'relative-y': {
        type: 'label',
        label: 'relative-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
    },
    contents: [{ type: 'optional', value: { type: 'string' } }],
  } as const;

  readonly schema = Tap.schema;

  attributes: TapAttributes;
  contents: TapContents;

  constructor(opts?: { attributes?: Partial<TapAttributes>; contents?: TapContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Tap.schema);
    this.contents = opts?.contents ?? operations.zero(Tap.schema.contents);
  }
  getColor(): string | null {
    return this.attributes['color'];
  }
  setColor(color: string | null): Tap {
    this.attributes['color'] = color;
    return this;
  }
  getDefaultX(): number | null {
    return this.attributes['default-x'];
  }
  setDefaultX(defaultX: number | null): Tap {
    this.attributes['default-x'] = defaultX;
    return this;
  }
  getDefaultY(): number | null {
    return this.attributes['default-y'];
  }
  setDefaultY(defaultY: number | null): Tap {
    this.attributes['default-y'] = defaultY;
    return this;
  }
  getFontFamily(): string | null {
    return this.attributes['font-family'];
  }
  setFontFamily(fontFamily: string | null): Tap {
    this.attributes['font-family'] = fontFamily;
    return this;
  }
  getFontSize(): 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null {
    return this.attributes['font-size'];
  }
  setFontSize(
    fontSize: 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null
  ): Tap {
    this.attributes['font-size'] = fontSize;
    return this;
  }
  getFontStyle(): 'normal' | 'italic' | null {
    return this.attributes['font-style'];
  }
  setFontStyle(fontStyle: 'normal' | 'italic' | null): Tap {
    this.attributes['font-style'] = fontStyle;
    return this;
  }
  getFontWeight(): 'normal' | 'bold' | null {
    return this.attributes['font-weight'];
  }
  setFontWeight(fontWeight: 'normal' | 'bold' | null): Tap {
    this.attributes['font-weight'] = fontWeight;
    return this;
  }
  getHand(): 'left' | 'right' | null {
    return this.attributes['hand'];
  }
  setHand(hand: 'left' | 'right' | null): Tap {
    this.attributes['hand'] = hand;
    return this;
  }
  getPlacement(): 'above' | 'below' | null {
    return this.attributes['placement'];
  }
  setPlacement(placement: 'above' | 'below' | null): Tap {
    this.attributes['placement'] = placement;
    return this;
  }
  getRelativeX(): number | null {
    return this.attributes['relative-x'];
  }
  setRelativeX(relativeX: number | null): Tap {
    this.attributes['relative-x'] = relativeX;
    return this;
  }
  getRelativeY(): number | null {
    return this.attributes['relative-y'];
  }
  setRelativeY(relativeY: number | null): Tap {
    this.attributes['relative-y'] = relativeY;
    return this;
  }
  getText(): string | null {
    return this.contents[0];
  }
  setText(text: string | null): Tap {
    this.contents[0] = text;
    return this;
  }
}

export type HeelAttributes = {
  color: string | null;
  'default-x': number | null;
  'default-y': number | null;
  'font-family': string | null;
  'font-size': 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null;
  'font-style': 'normal' | 'italic' | null;
  'font-weight': 'normal' | 'bold' | null;
  placement: 'above' | 'below' | null;
  'relative-x': number | null;
  'relative-y': number | null;
  substitution: 'yes' | 'no' | null;
};

export type HeelContents = [];

export class Heel implements XMLElement<'heel', HeelAttributes, HeelContents> {
  static readonly schema = {
    name: 'heel',
    attributes: {
      color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
      'default-x': {
        type: 'label',
        label: 'default-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'default-y': {
        type: 'label',
        label: 'default-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
      'font-size': {
        type: 'optional',
        value: {
          type: 'choices',
          choices: [
            { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
            { type: 'float', min: -Infinity, max: Infinity },
          ],
        },
      },
      'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
      'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
      placement: { type: 'optional', value: { type: 'choices', choices: ['above', 'below'] } },
      'relative-x': {
        type: 'label',
        label: 'relative-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'relative-y': {
        type: 'label',
        label: 'relative-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      substitution: { type: 'optional', value: { type: 'choices', choices: ['yes', 'no'] } },
    },
    contents: [],
  } as const;

  readonly schema = Heel.schema;

  attributes: HeelAttributes;
  contents: HeelContents;

  constructor(opts?: { attributes?: Partial<HeelAttributes>; contents?: HeelContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Heel.schema);
    this.contents = opts?.contents ?? operations.zero(Heel.schema.contents);
  }
  getColor(): string | null {
    return this.attributes['color'];
  }
  setColor(color: string | null): Heel {
    this.attributes['color'] = color;
    return this;
  }
  getDefaultX(): number | null {
    return this.attributes['default-x'];
  }
  setDefaultX(defaultX: number | null): Heel {
    this.attributes['default-x'] = defaultX;
    return this;
  }
  getDefaultY(): number | null {
    return this.attributes['default-y'];
  }
  setDefaultY(defaultY: number | null): Heel {
    this.attributes['default-y'] = defaultY;
    return this;
  }
  getFontFamily(): string | null {
    return this.attributes['font-family'];
  }
  setFontFamily(fontFamily: string | null): Heel {
    this.attributes['font-family'] = fontFamily;
    return this;
  }
  getFontSize(): 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null {
    return this.attributes['font-size'];
  }
  setFontSize(
    fontSize: 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null
  ): Heel {
    this.attributes['font-size'] = fontSize;
    return this;
  }
  getFontStyle(): 'normal' | 'italic' | null {
    return this.attributes['font-style'];
  }
  setFontStyle(fontStyle: 'normal' | 'italic' | null): Heel {
    this.attributes['font-style'] = fontStyle;
    return this;
  }
  getFontWeight(): 'normal' | 'bold' | null {
    return this.attributes['font-weight'];
  }
  setFontWeight(fontWeight: 'normal' | 'bold' | null): Heel {
    this.attributes['font-weight'] = fontWeight;
    return this;
  }
  getPlacement(): 'above' | 'below' | null {
    return this.attributes['placement'];
  }
  setPlacement(placement: 'above' | 'below' | null): Heel {
    this.attributes['placement'] = placement;
    return this;
  }
  getRelativeX(): number | null {
    return this.attributes['relative-x'];
  }
  setRelativeX(relativeX: number | null): Heel {
    this.attributes['relative-x'] = relativeX;
    return this;
  }
  getRelativeY(): number | null {
    return this.attributes['relative-y'];
  }
  setRelativeY(relativeY: number | null): Heel {
    this.attributes['relative-y'] = relativeY;
    return this;
  }
  getSubstitution(): 'yes' | 'no' | null {
    return this.attributes['substitution'];
  }
  setSubstitution(substitution: 'yes' | 'no' | null): Heel {
    this.attributes['substitution'] = substitution;
    return this;
  }
}

export type ToeAttributes = {
  color: string | null;
  'default-x': number | null;
  'default-y': number | null;
  'font-family': string | null;
  'font-size': 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null;
  'font-style': 'normal' | 'italic' | null;
  'font-weight': 'normal' | 'bold' | null;
  placement: 'above' | 'below' | null;
  'relative-x': number | null;
  'relative-y': number | null;
  substitution: 'yes' | 'no' | null;
};

export type ToeContents = [];

export class Toe implements XMLElement<'toe', ToeAttributes, ToeContents> {
  static readonly schema = {
    name: 'toe',
    attributes: {
      color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
      'default-x': {
        type: 'label',
        label: 'default-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'default-y': {
        type: 'label',
        label: 'default-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
      'font-size': {
        type: 'optional',
        value: {
          type: 'choices',
          choices: [
            { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
            { type: 'float', min: -Infinity, max: Infinity },
          ],
        },
      },
      'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
      'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
      placement: { type: 'optional', value: { type: 'choices', choices: ['above', 'below'] } },
      'relative-x': {
        type: 'label',
        label: 'relative-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'relative-y': {
        type: 'label',
        label: 'relative-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      substitution: { type: 'optional', value: { type: 'choices', choices: ['yes', 'no'] } },
    },
    contents: [],
  } as const;

  readonly schema = Toe.schema;

  attributes: ToeAttributes;
  contents: ToeContents;

  constructor(opts?: { attributes?: Partial<ToeAttributes>; contents?: ToeContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Toe.schema);
    this.contents = opts?.contents ?? operations.zero(Toe.schema.contents);
  }
  getColor(): string | null {
    return this.attributes['color'];
  }
  setColor(color: string | null): Toe {
    this.attributes['color'] = color;
    return this;
  }
  getDefaultX(): number | null {
    return this.attributes['default-x'];
  }
  setDefaultX(defaultX: number | null): Toe {
    this.attributes['default-x'] = defaultX;
    return this;
  }
  getDefaultY(): number | null {
    return this.attributes['default-y'];
  }
  setDefaultY(defaultY: number | null): Toe {
    this.attributes['default-y'] = defaultY;
    return this;
  }
  getFontFamily(): string | null {
    return this.attributes['font-family'];
  }
  setFontFamily(fontFamily: string | null): Toe {
    this.attributes['font-family'] = fontFamily;
    return this;
  }
  getFontSize(): 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null {
    return this.attributes['font-size'];
  }
  setFontSize(
    fontSize: 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null
  ): Toe {
    this.attributes['font-size'] = fontSize;
    return this;
  }
  getFontStyle(): 'normal' | 'italic' | null {
    return this.attributes['font-style'];
  }
  setFontStyle(fontStyle: 'normal' | 'italic' | null): Toe {
    this.attributes['font-style'] = fontStyle;
    return this;
  }
  getFontWeight(): 'normal' | 'bold' | null {
    return this.attributes['font-weight'];
  }
  setFontWeight(fontWeight: 'normal' | 'bold' | null): Toe {
    this.attributes['font-weight'] = fontWeight;
    return this;
  }
  getPlacement(): 'above' | 'below' | null {
    return this.attributes['placement'];
  }
  setPlacement(placement: 'above' | 'below' | null): Toe {
    this.attributes['placement'] = placement;
    return this;
  }
  getRelativeX(): number | null {
    return this.attributes['relative-x'];
  }
  setRelativeX(relativeX: number | null): Toe {
    this.attributes['relative-x'] = relativeX;
    return this;
  }
  getRelativeY(): number | null {
    return this.attributes['relative-y'];
  }
  setRelativeY(relativeY: number | null): Toe {
    this.attributes['relative-y'] = relativeY;
    return this;
  }
  getSubstitution(): 'yes' | 'no' | null {
    return this.attributes['substitution'];
  }
  setSubstitution(substitution: 'yes' | 'no' | null): Toe {
    this.attributes['substitution'] = substitution;
    return this;
  }
}

export type FingernailsAttributes = {
  color: string | null;
  'default-x': number | null;
  'default-y': number | null;
  'font-family': string | null;
  'font-size': 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null;
  'font-style': 'normal' | 'italic' | null;
  'font-weight': 'normal' | 'bold' | null;
  placement: 'above' | 'below' | null;
  'relative-x': number | null;
  'relative-y': number | null;
};

export type FingernailsContents = [];

export class Fingernails implements XMLElement<'fingernails', FingernailsAttributes, FingernailsContents> {
  static readonly schema = {
    name: 'fingernails',
    attributes: {
      color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
      'default-x': {
        type: 'label',
        label: 'default-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'default-y': {
        type: 'label',
        label: 'default-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
      'font-size': {
        type: 'optional',
        value: {
          type: 'choices',
          choices: [
            { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
            { type: 'float', min: -Infinity, max: Infinity },
          ],
        },
      },
      'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
      'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
      placement: { type: 'optional', value: { type: 'choices', choices: ['above', 'below'] } },
      'relative-x': {
        type: 'label',
        label: 'relative-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'relative-y': {
        type: 'label',
        label: 'relative-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
    },
    contents: [],
  } as const;

  readonly schema = Fingernails.schema;

  attributes: FingernailsAttributes;
  contents: FingernailsContents;

  constructor(opts?: { attributes?: Partial<FingernailsAttributes>; contents?: FingernailsContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Fingernails.schema);
    this.contents = opts?.contents ?? operations.zero(Fingernails.schema.contents);
  }
  getColor(): string | null {
    return this.attributes['color'];
  }
  setColor(color: string | null): Fingernails {
    this.attributes['color'] = color;
    return this;
  }
  getDefaultX(): number | null {
    return this.attributes['default-x'];
  }
  setDefaultX(defaultX: number | null): Fingernails {
    this.attributes['default-x'] = defaultX;
    return this;
  }
  getDefaultY(): number | null {
    return this.attributes['default-y'];
  }
  setDefaultY(defaultY: number | null): Fingernails {
    this.attributes['default-y'] = defaultY;
    return this;
  }
  getFontFamily(): string | null {
    return this.attributes['font-family'];
  }
  setFontFamily(fontFamily: string | null): Fingernails {
    this.attributes['font-family'] = fontFamily;
    return this;
  }
  getFontSize(): 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null {
    return this.attributes['font-size'];
  }
  setFontSize(
    fontSize: 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null
  ): Fingernails {
    this.attributes['font-size'] = fontSize;
    return this;
  }
  getFontStyle(): 'normal' | 'italic' | null {
    return this.attributes['font-style'];
  }
  setFontStyle(fontStyle: 'normal' | 'italic' | null): Fingernails {
    this.attributes['font-style'] = fontStyle;
    return this;
  }
  getFontWeight(): 'normal' | 'bold' | null {
    return this.attributes['font-weight'];
  }
  setFontWeight(fontWeight: 'normal' | 'bold' | null): Fingernails {
    this.attributes['font-weight'] = fontWeight;
    return this;
  }
  getPlacement(): 'above' | 'below' | null {
    return this.attributes['placement'];
  }
  setPlacement(placement: 'above' | 'below' | null): Fingernails {
    this.attributes['placement'] = placement;
    return this;
  }
  getRelativeX(): number | null {
    return this.attributes['relative-x'];
  }
  setRelativeX(relativeX: number | null): Fingernails {
    this.attributes['relative-x'] = relativeX;
    return this;
  }
  getRelativeY(): number | null {
    return this.attributes['relative-y'];
  }
  setRelativeY(relativeY: number | null): Fingernails {
    this.attributes['relative-y'] = relativeY;
    return this;
  }
}

export type HoleTypeAttributes = Record<string, unknown>;

export type HoleTypeContents = [string];

export class HoleType implements XMLElement<'hole-type', HoleTypeAttributes, HoleTypeContents> {
  static readonly schema = {
    name: 'hole-type',
    attributes: {},
    contents: [{ type: 'required', value: { type: 'string' } }],
  } as const;

  readonly schema = HoleType.schema;

  attributes: HoleTypeAttributes;
  contents: HoleTypeContents;

  constructor(opts?: { attributes?: Partial<HoleTypeAttributes>; contents?: HoleTypeContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, HoleType.schema);
    this.contents = opts?.contents ?? operations.zero(HoleType.schema.contents);
  }

  getText(): string {
    return this.contents[0];
  }
  setText(text: string): HoleType {
    this.contents[0] = text;
    return this;
  }
}

export type HoleClosedAttributes = { location: 'bottom' | 'left' | 'right' | 'top' | null };

export type HoleClosedContents = ['yes' | 'no' | 'half'];

export class HoleClosed implements XMLElement<'hole-closed', HoleClosedAttributes, HoleClosedContents> {
  static readonly schema = {
    name: 'hole-closed',
    attributes: {
      location: { type: 'optional', value: { type: 'choices', choices: ['bottom', 'left', 'right', 'top'] } },
    },
    contents: [
      {
        type: 'required',
        value: {
          type: 'label',
          label: 'hole-closed-value',
          value: { type: 'choices', choices: ['yes', 'no', 'half'] },
        },
      },
    ],
  } as const;

  readonly schema = HoleClosed.schema;

  attributes: HoleClosedAttributes;
  contents: HoleClosedContents;

  constructor(opts?: { attributes?: Partial<HoleClosedAttributes>; contents?: HoleClosedContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, HoleClosed.schema);
    this.contents = opts?.contents ?? operations.zero(HoleClosed.schema.contents);
  }
  getLocation(): 'bottom' | 'left' | 'right' | 'top' | null {
    return this.attributes['location'];
  }
  setLocation(location: 'bottom' | 'left' | 'right' | 'top' | null): HoleClosed {
    this.attributes['location'] = location;
    return this;
  }
  getHoleClosedValue(): 'yes' | 'no' | 'half' {
    return this.contents[0];
  }
  setHoleClosedValue(holeClosedValue: 'yes' | 'no' | 'half'): HoleClosed {
    this.contents[0] = holeClosedValue;
    return this;
  }
}

export type HoleShapeAttributes = Record<string, unknown>;

export type HoleShapeContents = [string];

export class HoleShape implements XMLElement<'hole-shape', HoleShapeAttributes, HoleShapeContents> {
  static readonly schema = {
    name: 'hole-shape',
    attributes: {},
    contents: [{ type: 'required', value: { type: 'string' } }],
  } as const;

  readonly schema = HoleShape.schema;

  attributes: HoleShapeAttributes;
  contents: HoleShapeContents;

  constructor(opts?: { attributes?: Partial<HoleShapeAttributes>; contents?: HoleShapeContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, HoleShape.schema);
    this.contents = opts?.contents ?? operations.zero(HoleShape.schema.contents);
  }

  getText(): string {
    return this.contents[0];
  }
  setText(text: string): HoleShape {
    this.contents[0] = text;
    return this;
  }
}

export type HoleAttributes = {
  color: string | null;
  'default-x': number | null;
  'default-y': number | null;
  'font-family': string | null;
  'font-size': 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null;
  'font-style': 'normal' | 'italic' | null;
  'font-weight': 'normal' | 'bold' | null;
  placement: 'above' | 'below' | null;
  'relative-x': number | null;
  'relative-y': number | null;
};

export type HoleContents = [HoleType | null, HoleClosed, HoleShape | null];

export class Hole implements XMLElement<'hole', HoleAttributes, HoleContents> {
  static readonly schema = {
    name: 'hole',
    attributes: {
      color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
      'default-x': {
        type: 'label',
        label: 'default-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'default-y': {
        type: 'label',
        label: 'default-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
      'font-size': {
        type: 'optional',
        value: {
          type: 'choices',
          choices: [
            { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
            { type: 'float', min: -Infinity, max: Infinity },
          ],
        },
      },
      'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
      'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
      placement: { type: 'optional', value: { type: 'choices', choices: ['above', 'below'] } },
      'relative-x': {
        type: 'label',
        label: 'relative-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'relative-y': {
        type: 'label',
        label: 'relative-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
    },
    contents: [
      { type: 'optional', value: HoleType },
      { type: 'required', value: HoleClosed },
      { type: 'optional', value: HoleShape },
    ],
  } as const;

  readonly schema = Hole.schema;

  attributes: HoleAttributes;
  contents: HoleContents;

  constructor(opts?: { attributes?: Partial<HoleAttributes>; contents?: HoleContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Hole.schema);
    this.contents = opts?.contents ?? operations.zero(Hole.schema.contents);
  }
  getColor(): string | null {
    return this.attributes['color'];
  }
  setColor(color: string | null): Hole {
    this.attributes['color'] = color;
    return this;
  }
  getDefaultX(): number | null {
    return this.attributes['default-x'];
  }
  setDefaultX(defaultX: number | null): Hole {
    this.attributes['default-x'] = defaultX;
    return this;
  }
  getDefaultY(): number | null {
    return this.attributes['default-y'];
  }
  setDefaultY(defaultY: number | null): Hole {
    this.attributes['default-y'] = defaultY;
    return this;
  }
  getFontFamily(): string | null {
    return this.attributes['font-family'];
  }
  setFontFamily(fontFamily: string | null): Hole {
    this.attributes['font-family'] = fontFamily;
    return this;
  }
  getFontSize(): 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null {
    return this.attributes['font-size'];
  }
  setFontSize(
    fontSize: 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null
  ): Hole {
    this.attributes['font-size'] = fontSize;
    return this;
  }
  getFontStyle(): 'normal' | 'italic' | null {
    return this.attributes['font-style'];
  }
  setFontStyle(fontStyle: 'normal' | 'italic' | null): Hole {
    this.attributes['font-style'] = fontStyle;
    return this;
  }
  getFontWeight(): 'normal' | 'bold' | null {
    return this.attributes['font-weight'];
  }
  setFontWeight(fontWeight: 'normal' | 'bold' | null): Hole {
    this.attributes['font-weight'] = fontWeight;
    return this;
  }
  getPlacement(): 'above' | 'below' | null {
    return this.attributes['placement'];
  }
  setPlacement(placement: 'above' | 'below' | null): Hole {
    this.attributes['placement'] = placement;
    return this;
  }
  getRelativeX(): number | null {
    return this.attributes['relative-x'];
  }
  setRelativeX(relativeX: number | null): Hole {
    this.attributes['relative-x'] = relativeX;
    return this;
  }
  getRelativeY(): number | null {
    return this.attributes['relative-y'];
  }
  setRelativeY(relativeY: number | null): Hole {
    this.attributes['relative-y'] = relativeY;
    return this;
  }
  getHoleType(): HoleType | null {
    return this.contents[0];
  }
  setHoleType(holeType: HoleType | null): Hole {
    this.contents[0] = holeType;
    return this;
  }
  getHoleClosed(): HoleClosed {
    return this.contents[1];
  }
  setHoleClosed(holeClosed: HoleClosed): Hole {
    this.contents[1] = holeClosed;
    return this;
  }
  getHoleShape(): HoleShape | null {
    return this.contents[2];
  }
  setHoleShape(holeShape: HoleShape | null): Hole {
    this.contents[2] = holeShape;
    return this;
  }
}

export type ArrowDirectionAttributes = Record<string, unknown>;

export type ArrowDirectionContents = [
  | 'down'
  | 'left'
  | 'left right'
  | 'northeast'
  | 'northeast southwest'
  | 'northwest'
  | 'northwest southeast'
  | 'other'
  | 'right'
  | 'southeast'
  | 'southwest'
  | 'up'
  | 'up down'
];

export class ArrowDirection implements XMLElement<'arrow-direction', ArrowDirectionAttributes, ArrowDirectionContents> {
  static readonly schema = {
    name: 'arrow-direction',
    attributes: {},
    contents: [
      {
        type: 'required',
        value: {
          type: 'label',
          label: 'arrow-direction',
          value: {
            type: 'choices',
            choices: [
              'down',
              'left',
              'left right',
              'northeast',
              'northeast southwest',
              'northwest',
              'northwest southeast',
              'other',
              'right',
              'southeast',
              'southwest',
              'up',
              'up down',
            ],
          },
        },
      },
    ],
  } as const;

  readonly schema = ArrowDirection.schema;

  attributes: ArrowDirectionAttributes;
  contents: ArrowDirectionContents;

  constructor(opts?: { attributes?: Partial<ArrowDirectionAttributes>; contents?: ArrowDirectionContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, ArrowDirection.schema);
    this.contents = opts?.contents ?? operations.zero(ArrowDirection.schema.contents);
  }

  getArrowDirection():
    | 'down'
    | 'left'
    | 'left right'
    | 'northeast'
    | 'northeast southwest'
    | 'northwest'
    | 'northwest southeast'
    | 'other'
    | 'right'
    | 'southeast'
    | 'southwest'
    | 'up'
    | 'up down' {
    return this.contents[0];
  }
  setArrowDirection(
    arrowDirection:
      | 'down'
      | 'left'
      | 'left right'
      | 'northeast'
      | 'northeast southwest'
      | 'northwest'
      | 'northwest southeast'
      | 'other'
      | 'right'
      | 'southeast'
      | 'southwest'
      | 'up'
      | 'up down'
  ): ArrowDirection {
    this.contents[0] = arrowDirection;
    return this;
  }
}

export type ArrowStyleAttributes = Record<string, unknown>;

export type ArrowStyleContents = ['combined' | 'double' | 'filled' | 'hollow' | 'other' | 'paired' | 'single'];

export class ArrowStyle implements XMLElement<'arrow-style', ArrowStyleAttributes, ArrowStyleContents> {
  static readonly schema = {
    name: 'arrow-style',
    attributes: {},
    contents: [
      {
        type: 'required',
        value: {
          type: 'label',
          label: 'arrow-style',
          value: { type: 'choices', choices: ['combined', 'double', 'filled', 'hollow', 'other', 'paired', 'single'] },
        },
      },
    ],
  } as const;

  readonly schema = ArrowStyle.schema;

  attributes: ArrowStyleAttributes;
  contents: ArrowStyleContents;

  constructor(opts?: { attributes?: Partial<ArrowStyleAttributes>; contents?: ArrowStyleContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, ArrowStyle.schema);
    this.contents = opts?.contents ?? operations.zero(ArrowStyle.schema.contents);
  }

  getArrowStyle(): 'combined' | 'double' | 'filled' | 'hollow' | 'other' | 'paired' | 'single' {
    return this.contents[0];
  }
  setArrowStyle(arrowStyle: 'combined' | 'double' | 'filled' | 'hollow' | 'other' | 'paired' | 'single'): ArrowStyle {
    this.contents[0] = arrowStyle;
    return this;
  }
}

export type ArrowheadAttributes = Record<string, unknown>;

export type ArrowheadContents = [];

export class Arrowhead implements XMLElement<'arrowhead', ArrowheadAttributes, ArrowheadContents> {
  static readonly schema = { name: 'arrowhead', attributes: {}, contents: [] } as const;

  readonly schema = Arrowhead.schema;

  attributes: ArrowheadAttributes;
  contents: ArrowheadContents;

  constructor(opts?: { attributes?: Partial<ArrowheadAttributes>; contents?: ArrowheadContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Arrowhead.schema);
    this.contents = opts?.contents ?? operations.zero(Arrowhead.schema.contents);
  }
}

export type CircularArrowAttributes = Record<string, unknown>;

export type CircularArrowContents = ['anticlockwise' | 'clockwise'];

export class CircularArrow implements XMLElement<'circular-arrow', CircularArrowAttributes, CircularArrowContents> {
  static readonly schema = {
    name: 'circular-arrow',
    attributes: {},
    contents: [
      {
        type: 'required',
        value: {
          type: 'label',
          label: 'circular-arrow',
          value: { type: 'choices', choices: ['anticlockwise', 'clockwise'] },
        },
      },
    ],
  } as const;

  readonly schema = CircularArrow.schema;

  attributes: CircularArrowAttributes;
  contents: CircularArrowContents;

  constructor(opts?: { attributes?: Partial<CircularArrowAttributes>; contents?: CircularArrowContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, CircularArrow.schema);
    this.contents = opts?.contents ?? operations.zero(CircularArrow.schema.contents);
  }

  getCircularArrow(): 'anticlockwise' | 'clockwise' {
    return this.contents[0];
  }
  setCircularArrow(circularArrow: 'anticlockwise' | 'clockwise'): CircularArrow {
    this.contents[0] = circularArrow;
    return this;
  }
}

export type ArrowAttributes = {
  color: string | null;
  'default-x': number | null;
  'default-y': number | null;
  'font-family': string | null;
  'font-size': 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null;
  'font-style': 'normal' | 'italic' | null;
  'font-weight': 'normal' | 'bold' | null;
  placement: 'above' | 'below' | null;
  'relative-x': number | null;
  'relative-y': number | null;
  smufl: string | null;
};

export type ArrowContents = [ArrowDirection, ArrowStyle | null, Arrowhead | null, CircularArrow | null];

export class Arrow implements XMLElement<'arrow', ArrowAttributes, ArrowContents> {
  static readonly schema = {
    name: 'arrow',
    attributes: {
      color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
      'default-x': {
        type: 'label',
        label: 'default-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'default-y': {
        type: 'label',
        label: 'default-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
      'font-size': {
        type: 'optional',
        value: {
          type: 'choices',
          choices: [
            { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
            { type: 'float', min: -Infinity, max: Infinity },
          ],
        },
      },
      'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
      'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
      placement: { type: 'optional', value: { type: 'choices', choices: ['above', 'below'] } },
      'relative-x': {
        type: 'label',
        label: 'relative-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'relative-y': {
        type: 'label',
        label: 'relative-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      smufl: { type: 'optional', value: { type: 'string' } },
    },
    contents: [
      { type: 'required', value: ArrowDirection },
      { type: 'optional', value: ArrowStyle },
      { type: 'optional', value: Arrowhead },
      { type: 'optional', value: CircularArrow },
    ],
  } as const;

  readonly schema = Arrow.schema;

  attributes: ArrowAttributes;
  contents: ArrowContents;

  constructor(opts?: { attributes?: Partial<ArrowAttributes>; contents?: ArrowContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Arrow.schema);
    this.contents = opts?.contents ?? operations.zero(Arrow.schema.contents);
  }
  getColor(): string | null {
    return this.attributes['color'];
  }
  setColor(color: string | null): Arrow {
    this.attributes['color'] = color;
    return this;
  }
  getDefaultX(): number | null {
    return this.attributes['default-x'];
  }
  setDefaultX(defaultX: number | null): Arrow {
    this.attributes['default-x'] = defaultX;
    return this;
  }
  getDefaultY(): number | null {
    return this.attributes['default-y'];
  }
  setDefaultY(defaultY: number | null): Arrow {
    this.attributes['default-y'] = defaultY;
    return this;
  }
  getFontFamily(): string | null {
    return this.attributes['font-family'];
  }
  setFontFamily(fontFamily: string | null): Arrow {
    this.attributes['font-family'] = fontFamily;
    return this;
  }
  getFontSize(): 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null {
    return this.attributes['font-size'];
  }
  setFontSize(
    fontSize: 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null
  ): Arrow {
    this.attributes['font-size'] = fontSize;
    return this;
  }
  getFontStyle(): 'normal' | 'italic' | null {
    return this.attributes['font-style'];
  }
  setFontStyle(fontStyle: 'normal' | 'italic' | null): Arrow {
    this.attributes['font-style'] = fontStyle;
    return this;
  }
  getFontWeight(): 'normal' | 'bold' | null {
    return this.attributes['font-weight'];
  }
  setFontWeight(fontWeight: 'normal' | 'bold' | null): Arrow {
    this.attributes['font-weight'] = fontWeight;
    return this;
  }
  getPlacement(): 'above' | 'below' | null {
    return this.attributes['placement'];
  }
  setPlacement(placement: 'above' | 'below' | null): Arrow {
    this.attributes['placement'] = placement;
    return this;
  }
  getRelativeX(): number | null {
    return this.attributes['relative-x'];
  }
  setRelativeX(relativeX: number | null): Arrow {
    this.attributes['relative-x'] = relativeX;
    return this;
  }
  getRelativeY(): number | null {
    return this.attributes['relative-y'];
  }
  setRelativeY(relativeY: number | null): Arrow {
    this.attributes['relative-y'] = relativeY;
    return this;
  }
  getSmufl(): string | null {
    return this.attributes['smufl'];
  }
  setSmufl(smufl: string | null): Arrow {
    this.attributes['smufl'] = smufl;
    return this;
  }
  getArrowDirection(): ArrowDirection {
    return this.contents[0];
  }
  setArrowDirection(arrowDirection: ArrowDirection): Arrow {
    this.contents[0] = arrowDirection;
    return this;
  }
  getArrowStyle(): ArrowStyle | null {
    return this.contents[1];
  }
  setArrowStyle(arrowStyle: ArrowStyle | null): Arrow {
    this.contents[1] = arrowStyle;
    return this;
  }
  getArrowhead(): Arrowhead | null {
    return this.contents[2];
  }
  setArrowhead(arrowhead: Arrowhead | null): Arrow {
    this.contents[2] = arrowhead;
    return this;
  }
  getCircularArrow(): CircularArrow | null {
    return this.contents[3];
  }
  setCircularArrow(circularArrow: CircularArrow | null): Arrow {
    this.contents[3] = circularArrow;
    return this;
  }
}

export type HandbellAttributes = {
  color: string | null;
  'default-x': number | null;
  'default-y': number | null;
  'font-family': string | null;
  'font-size': 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null;
  'font-style': 'normal' | 'italic' | null;
  'font-weight': 'normal' | 'bold' | null;
  placement: 'above' | 'below' | null;
  'relative-x': number | null;
  'relative-y': number | null;
};

export type HandbellContents = [
  | 'belltree'
  | 'damp'
  | 'echo'
  | 'gyro'
  | 'hand martellato'
  | 'mallet lift'
  | 'mallet table'
  | 'martellato'
  | 'martellato lift'
  | 'muted martellato'
  | 'pluck lift'
  | 'swing'
];

export class Handbell implements XMLElement<'handbell', HandbellAttributes, HandbellContents> {
  static readonly schema = {
    name: 'handbell',
    attributes: {
      color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
      'default-x': {
        type: 'label',
        label: 'default-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'default-y': {
        type: 'label',
        label: 'default-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
      'font-size': {
        type: 'optional',
        value: {
          type: 'choices',
          choices: [
            { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
            { type: 'float', min: -Infinity, max: Infinity },
          ],
        },
      },
      'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
      'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
      placement: { type: 'optional', value: { type: 'choices', choices: ['above', 'below'] } },
      'relative-x': {
        type: 'label',
        label: 'relative-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'relative-y': {
        type: 'label',
        label: 'relative-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
    },
    contents: [
      {
        type: 'required',
        value: {
          type: 'label',
          label: 'handbell-value',
          value: {
            type: 'choices',
            choices: [
              'belltree',
              'damp',
              'echo',
              'gyro',
              'hand martellato',
              'mallet lift',
              'mallet table',
              'martellato',
              'martellato lift',
              'muted martellato',
              'pluck lift',
              'swing',
            ],
          },
        },
      },
    ],
  } as const;

  readonly schema = Handbell.schema;

  attributes: HandbellAttributes;
  contents: HandbellContents;

  constructor(opts?: { attributes?: Partial<HandbellAttributes>; contents?: HandbellContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Handbell.schema);
    this.contents = opts?.contents ?? operations.zero(Handbell.schema.contents);
  }
  getColor(): string | null {
    return this.attributes['color'];
  }
  setColor(color: string | null): Handbell {
    this.attributes['color'] = color;
    return this;
  }
  getDefaultX(): number | null {
    return this.attributes['default-x'];
  }
  setDefaultX(defaultX: number | null): Handbell {
    this.attributes['default-x'] = defaultX;
    return this;
  }
  getDefaultY(): number | null {
    return this.attributes['default-y'];
  }
  setDefaultY(defaultY: number | null): Handbell {
    this.attributes['default-y'] = defaultY;
    return this;
  }
  getFontFamily(): string | null {
    return this.attributes['font-family'];
  }
  setFontFamily(fontFamily: string | null): Handbell {
    this.attributes['font-family'] = fontFamily;
    return this;
  }
  getFontSize(): 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null {
    return this.attributes['font-size'];
  }
  setFontSize(
    fontSize: 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null
  ): Handbell {
    this.attributes['font-size'] = fontSize;
    return this;
  }
  getFontStyle(): 'normal' | 'italic' | null {
    return this.attributes['font-style'];
  }
  setFontStyle(fontStyle: 'normal' | 'italic' | null): Handbell {
    this.attributes['font-style'] = fontStyle;
    return this;
  }
  getFontWeight(): 'normal' | 'bold' | null {
    return this.attributes['font-weight'];
  }
  setFontWeight(fontWeight: 'normal' | 'bold' | null): Handbell {
    this.attributes['font-weight'] = fontWeight;
    return this;
  }
  getPlacement(): 'above' | 'below' | null {
    return this.attributes['placement'];
  }
  setPlacement(placement: 'above' | 'below' | null): Handbell {
    this.attributes['placement'] = placement;
    return this;
  }
  getRelativeX(): number | null {
    return this.attributes['relative-x'];
  }
  setRelativeX(relativeX: number | null): Handbell {
    this.attributes['relative-x'] = relativeX;
    return this;
  }
  getRelativeY(): number | null {
    return this.attributes['relative-y'];
  }
  setRelativeY(relativeY: number | null): Handbell {
    this.attributes['relative-y'] = relativeY;
    return this;
  }
  getHandbellValue():
    | 'belltree'
    | 'damp'
    | 'echo'
    | 'gyro'
    | 'hand martellato'
    | 'mallet lift'
    | 'mallet table'
    | 'martellato'
    | 'martellato lift'
    | 'muted martellato'
    | 'pluck lift'
    | 'swing' {
    return this.contents[0];
  }
  setHandbellValue(
    handbellValue:
      | 'belltree'
      | 'damp'
      | 'echo'
      | 'gyro'
      | 'hand martellato'
      | 'mallet lift'
      | 'mallet table'
      | 'martellato'
      | 'martellato lift'
      | 'muted martellato'
      | 'pluck lift'
      | 'swing'
  ): Handbell {
    this.contents[0] = handbellValue;
    return this;
  }
}

export type BrassBendAttributes = {
  color: string | null;
  'default-x': number | null;
  'default-y': number | null;
  'font-family': string | null;
  'font-size': 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null;
  'font-style': 'normal' | 'italic' | null;
  'font-weight': 'normal' | 'bold' | null;
  placement: 'above' | 'below' | null;
  'relative-x': number | null;
  'relative-y': number | null;
};

export type BrassBendContents = [];

export class BrassBend implements XMLElement<'brass-bend', BrassBendAttributes, BrassBendContents> {
  static readonly schema = {
    name: 'brass-bend',
    attributes: {
      color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
      'default-x': {
        type: 'label',
        label: 'default-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'default-y': {
        type: 'label',
        label: 'default-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
      'font-size': {
        type: 'optional',
        value: {
          type: 'choices',
          choices: [
            { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
            { type: 'float', min: -Infinity, max: Infinity },
          ],
        },
      },
      'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
      'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
      placement: { type: 'optional', value: { type: 'choices', choices: ['above', 'below'] } },
      'relative-x': {
        type: 'label',
        label: 'relative-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'relative-y': {
        type: 'label',
        label: 'relative-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
    },
    contents: [],
  } as const;

  readonly schema = BrassBend.schema;

  attributes: BrassBendAttributes;
  contents: BrassBendContents;

  constructor(opts?: { attributes?: Partial<BrassBendAttributes>; contents?: BrassBendContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, BrassBend.schema);
    this.contents = opts?.contents ?? operations.zero(BrassBend.schema.contents);
  }
  getColor(): string | null {
    return this.attributes['color'];
  }
  setColor(color: string | null): BrassBend {
    this.attributes['color'] = color;
    return this;
  }
  getDefaultX(): number | null {
    return this.attributes['default-x'];
  }
  setDefaultX(defaultX: number | null): BrassBend {
    this.attributes['default-x'] = defaultX;
    return this;
  }
  getDefaultY(): number | null {
    return this.attributes['default-y'];
  }
  setDefaultY(defaultY: number | null): BrassBend {
    this.attributes['default-y'] = defaultY;
    return this;
  }
  getFontFamily(): string | null {
    return this.attributes['font-family'];
  }
  setFontFamily(fontFamily: string | null): BrassBend {
    this.attributes['font-family'] = fontFamily;
    return this;
  }
  getFontSize(): 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null {
    return this.attributes['font-size'];
  }
  setFontSize(
    fontSize: 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null
  ): BrassBend {
    this.attributes['font-size'] = fontSize;
    return this;
  }
  getFontStyle(): 'normal' | 'italic' | null {
    return this.attributes['font-style'];
  }
  setFontStyle(fontStyle: 'normal' | 'italic' | null): BrassBend {
    this.attributes['font-style'] = fontStyle;
    return this;
  }
  getFontWeight(): 'normal' | 'bold' | null {
    return this.attributes['font-weight'];
  }
  setFontWeight(fontWeight: 'normal' | 'bold' | null): BrassBend {
    this.attributes['font-weight'] = fontWeight;
    return this;
  }
  getPlacement(): 'above' | 'below' | null {
    return this.attributes['placement'];
  }
  setPlacement(placement: 'above' | 'below' | null): BrassBend {
    this.attributes['placement'] = placement;
    return this;
  }
  getRelativeX(): number | null {
    return this.attributes['relative-x'];
  }
  setRelativeX(relativeX: number | null): BrassBend {
    this.attributes['relative-x'] = relativeX;
    return this;
  }
  getRelativeY(): number | null {
    return this.attributes['relative-y'];
  }
  setRelativeY(relativeY: number | null): BrassBend {
    this.attributes['relative-y'] = relativeY;
    return this;
  }
}

export type FlipAttributes = {
  color: string | null;
  'default-x': number | null;
  'default-y': number | null;
  'font-family': string | null;
  'font-size': 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null;
  'font-style': 'normal' | 'italic' | null;
  'font-weight': 'normal' | 'bold' | null;
  placement: 'above' | 'below' | null;
  'relative-x': number | null;
  'relative-y': number | null;
};

export type FlipContents = [];

export class Flip implements XMLElement<'flip', FlipAttributes, FlipContents> {
  static readonly schema = {
    name: 'flip',
    attributes: {
      color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
      'default-x': {
        type: 'label',
        label: 'default-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'default-y': {
        type: 'label',
        label: 'default-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
      'font-size': {
        type: 'optional',
        value: {
          type: 'choices',
          choices: [
            { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
            { type: 'float', min: -Infinity, max: Infinity },
          ],
        },
      },
      'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
      'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
      placement: { type: 'optional', value: { type: 'choices', choices: ['above', 'below'] } },
      'relative-x': {
        type: 'label',
        label: 'relative-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'relative-y': {
        type: 'label',
        label: 'relative-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
    },
    contents: [],
  } as const;

  readonly schema = Flip.schema;

  attributes: FlipAttributes;
  contents: FlipContents;

  constructor(opts?: { attributes?: Partial<FlipAttributes>; contents?: FlipContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Flip.schema);
    this.contents = opts?.contents ?? operations.zero(Flip.schema.contents);
  }
  getColor(): string | null {
    return this.attributes['color'];
  }
  setColor(color: string | null): Flip {
    this.attributes['color'] = color;
    return this;
  }
  getDefaultX(): number | null {
    return this.attributes['default-x'];
  }
  setDefaultX(defaultX: number | null): Flip {
    this.attributes['default-x'] = defaultX;
    return this;
  }
  getDefaultY(): number | null {
    return this.attributes['default-y'];
  }
  setDefaultY(defaultY: number | null): Flip {
    this.attributes['default-y'] = defaultY;
    return this;
  }
  getFontFamily(): string | null {
    return this.attributes['font-family'];
  }
  setFontFamily(fontFamily: string | null): Flip {
    this.attributes['font-family'] = fontFamily;
    return this;
  }
  getFontSize(): 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null {
    return this.attributes['font-size'];
  }
  setFontSize(
    fontSize: 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null
  ): Flip {
    this.attributes['font-size'] = fontSize;
    return this;
  }
  getFontStyle(): 'normal' | 'italic' | null {
    return this.attributes['font-style'];
  }
  setFontStyle(fontStyle: 'normal' | 'italic' | null): Flip {
    this.attributes['font-style'] = fontStyle;
    return this;
  }
  getFontWeight(): 'normal' | 'bold' | null {
    return this.attributes['font-weight'];
  }
  setFontWeight(fontWeight: 'normal' | 'bold' | null): Flip {
    this.attributes['font-weight'] = fontWeight;
    return this;
  }
  getPlacement(): 'above' | 'below' | null {
    return this.attributes['placement'];
  }
  setPlacement(placement: 'above' | 'below' | null): Flip {
    this.attributes['placement'] = placement;
    return this;
  }
  getRelativeX(): number | null {
    return this.attributes['relative-x'];
  }
  setRelativeX(relativeX: number | null): Flip {
    this.attributes['relative-x'] = relativeX;
    return this;
  }
  getRelativeY(): number | null {
    return this.attributes['relative-y'];
  }
  setRelativeY(relativeY: number | null): Flip {
    this.attributes['relative-y'] = relativeY;
    return this;
  }
}

export type SmearAttributes = {
  color: string | null;
  'default-x': number | null;
  'default-y': number | null;
  'font-family': string | null;
  'font-size': 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null;
  'font-style': 'normal' | 'italic' | null;
  'font-weight': 'normal' | 'bold' | null;
  placement: 'above' | 'below' | null;
  'relative-x': number | null;
  'relative-y': number | null;
};

export type SmearContents = [];

export class Smear implements XMLElement<'smear', SmearAttributes, SmearContents> {
  static readonly schema = {
    name: 'smear',
    attributes: {
      color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
      'default-x': {
        type: 'label',
        label: 'default-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'default-y': {
        type: 'label',
        label: 'default-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
      'font-size': {
        type: 'optional',
        value: {
          type: 'choices',
          choices: [
            { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
            { type: 'float', min: -Infinity, max: Infinity },
          ],
        },
      },
      'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
      'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
      placement: { type: 'optional', value: { type: 'choices', choices: ['above', 'below'] } },
      'relative-x': {
        type: 'label',
        label: 'relative-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'relative-y': {
        type: 'label',
        label: 'relative-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
    },
    contents: [],
  } as const;

  readonly schema = Smear.schema;

  attributes: SmearAttributes;
  contents: SmearContents;

  constructor(opts?: { attributes?: Partial<SmearAttributes>; contents?: SmearContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Smear.schema);
    this.contents = opts?.contents ?? operations.zero(Smear.schema.contents);
  }
  getColor(): string | null {
    return this.attributes['color'];
  }
  setColor(color: string | null): Smear {
    this.attributes['color'] = color;
    return this;
  }
  getDefaultX(): number | null {
    return this.attributes['default-x'];
  }
  setDefaultX(defaultX: number | null): Smear {
    this.attributes['default-x'] = defaultX;
    return this;
  }
  getDefaultY(): number | null {
    return this.attributes['default-y'];
  }
  setDefaultY(defaultY: number | null): Smear {
    this.attributes['default-y'] = defaultY;
    return this;
  }
  getFontFamily(): string | null {
    return this.attributes['font-family'];
  }
  setFontFamily(fontFamily: string | null): Smear {
    this.attributes['font-family'] = fontFamily;
    return this;
  }
  getFontSize(): 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null {
    return this.attributes['font-size'];
  }
  setFontSize(
    fontSize: 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null
  ): Smear {
    this.attributes['font-size'] = fontSize;
    return this;
  }
  getFontStyle(): 'normal' | 'italic' | null {
    return this.attributes['font-style'];
  }
  setFontStyle(fontStyle: 'normal' | 'italic' | null): Smear {
    this.attributes['font-style'] = fontStyle;
    return this;
  }
  getFontWeight(): 'normal' | 'bold' | null {
    return this.attributes['font-weight'];
  }
  setFontWeight(fontWeight: 'normal' | 'bold' | null): Smear {
    this.attributes['font-weight'] = fontWeight;
    return this;
  }
  getPlacement(): 'above' | 'below' | null {
    return this.attributes['placement'];
  }
  setPlacement(placement: 'above' | 'below' | null): Smear {
    this.attributes['placement'] = placement;
    return this;
  }
  getRelativeX(): number | null {
    return this.attributes['relative-x'];
  }
  setRelativeX(relativeX: number | null): Smear {
    this.attributes['relative-x'] = relativeX;
    return this;
  }
  getRelativeY(): number | null {
    return this.attributes['relative-y'];
  }
  setRelativeY(relativeY: number | null): Smear {
    this.attributes['relative-y'] = relativeY;
    return this;
  }
}

export type OpenAttributes = {
  color: string | null;
  'default-x': number | null;
  'default-y': number | null;
  'font-family': string | null;
  'font-size': 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null;
  'font-style': 'normal' | 'italic' | null;
  'font-weight': 'normal' | 'bold' | null;
  placement: 'above' | 'below' | null;
  'relative-x': number | null;
  'relative-y': number | null;
  smufl: string | null;
};

export type OpenContents = [];

export class Open implements XMLElement<'open', OpenAttributes, OpenContents> {
  static readonly schema = {
    name: 'open',
    attributes: {
      color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
      'default-x': {
        type: 'label',
        label: 'default-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'default-y': {
        type: 'label',
        label: 'default-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
      'font-size': {
        type: 'optional',
        value: {
          type: 'choices',
          choices: [
            { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
            { type: 'float', min: -Infinity, max: Infinity },
          ],
        },
      },
      'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
      'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
      placement: { type: 'optional', value: { type: 'choices', choices: ['above', 'below'] } },
      'relative-x': {
        type: 'label',
        label: 'relative-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'relative-y': {
        type: 'label',
        label: 'relative-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      smufl: { type: 'optional', value: { type: 'string' } },
    },
    contents: [],
  } as const;

  readonly schema = Open.schema;

  attributes: OpenAttributes;
  contents: OpenContents;

  constructor(opts?: { attributes?: Partial<OpenAttributes>; contents?: OpenContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Open.schema);
    this.contents = opts?.contents ?? operations.zero(Open.schema.contents);
  }
  getColor(): string | null {
    return this.attributes['color'];
  }
  setColor(color: string | null): Open {
    this.attributes['color'] = color;
    return this;
  }
  getDefaultX(): number | null {
    return this.attributes['default-x'];
  }
  setDefaultX(defaultX: number | null): Open {
    this.attributes['default-x'] = defaultX;
    return this;
  }
  getDefaultY(): number | null {
    return this.attributes['default-y'];
  }
  setDefaultY(defaultY: number | null): Open {
    this.attributes['default-y'] = defaultY;
    return this;
  }
  getFontFamily(): string | null {
    return this.attributes['font-family'];
  }
  setFontFamily(fontFamily: string | null): Open {
    this.attributes['font-family'] = fontFamily;
    return this;
  }
  getFontSize(): 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null {
    return this.attributes['font-size'];
  }
  setFontSize(
    fontSize: 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null
  ): Open {
    this.attributes['font-size'] = fontSize;
    return this;
  }
  getFontStyle(): 'normal' | 'italic' | null {
    return this.attributes['font-style'];
  }
  setFontStyle(fontStyle: 'normal' | 'italic' | null): Open {
    this.attributes['font-style'] = fontStyle;
    return this;
  }
  getFontWeight(): 'normal' | 'bold' | null {
    return this.attributes['font-weight'];
  }
  setFontWeight(fontWeight: 'normal' | 'bold' | null): Open {
    this.attributes['font-weight'] = fontWeight;
    return this;
  }
  getPlacement(): 'above' | 'below' | null {
    return this.attributes['placement'];
  }
  setPlacement(placement: 'above' | 'below' | null): Open {
    this.attributes['placement'] = placement;
    return this;
  }
  getRelativeX(): number | null {
    return this.attributes['relative-x'];
  }
  setRelativeX(relativeX: number | null): Open {
    this.attributes['relative-x'] = relativeX;
    return this;
  }
  getRelativeY(): number | null {
    return this.attributes['relative-y'];
  }
  setRelativeY(relativeY: number | null): Open {
    this.attributes['relative-y'] = relativeY;
    return this;
  }
  getSmufl(): string | null {
    return this.attributes['smufl'];
  }
  setSmufl(smufl: string | null): Open {
    this.attributes['smufl'] = smufl;
    return this;
  }
}

export type HalfMutedAttributes = {
  color: string | null;
  'default-x': number | null;
  'default-y': number | null;
  'font-family': string | null;
  'font-size': 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null;
  'font-style': 'normal' | 'italic' | null;
  'font-weight': 'normal' | 'bold' | null;
  placement: 'above' | 'below' | null;
  'relative-x': number | null;
  'relative-y': number | null;
  smufl: string | null;
};

export type HalfMutedContents = [];

export class HalfMuted implements XMLElement<'half-muted', HalfMutedAttributes, HalfMutedContents> {
  static readonly schema = {
    name: 'half-muted',
    attributes: {
      color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
      'default-x': {
        type: 'label',
        label: 'default-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'default-y': {
        type: 'label',
        label: 'default-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
      'font-size': {
        type: 'optional',
        value: {
          type: 'choices',
          choices: [
            { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
            { type: 'float', min: -Infinity, max: Infinity },
          ],
        },
      },
      'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
      'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
      placement: { type: 'optional', value: { type: 'choices', choices: ['above', 'below'] } },
      'relative-x': {
        type: 'label',
        label: 'relative-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'relative-y': {
        type: 'label',
        label: 'relative-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      smufl: { type: 'optional', value: { type: 'string' } },
    },
    contents: [],
  } as const;

  readonly schema = HalfMuted.schema;

  attributes: HalfMutedAttributes;
  contents: HalfMutedContents;

  constructor(opts?: { attributes?: Partial<HalfMutedAttributes>; contents?: HalfMutedContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, HalfMuted.schema);
    this.contents = opts?.contents ?? operations.zero(HalfMuted.schema.contents);
  }
  getColor(): string | null {
    return this.attributes['color'];
  }
  setColor(color: string | null): HalfMuted {
    this.attributes['color'] = color;
    return this;
  }
  getDefaultX(): number | null {
    return this.attributes['default-x'];
  }
  setDefaultX(defaultX: number | null): HalfMuted {
    this.attributes['default-x'] = defaultX;
    return this;
  }
  getDefaultY(): number | null {
    return this.attributes['default-y'];
  }
  setDefaultY(defaultY: number | null): HalfMuted {
    this.attributes['default-y'] = defaultY;
    return this;
  }
  getFontFamily(): string | null {
    return this.attributes['font-family'];
  }
  setFontFamily(fontFamily: string | null): HalfMuted {
    this.attributes['font-family'] = fontFamily;
    return this;
  }
  getFontSize(): 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null {
    return this.attributes['font-size'];
  }
  setFontSize(
    fontSize: 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null
  ): HalfMuted {
    this.attributes['font-size'] = fontSize;
    return this;
  }
  getFontStyle(): 'normal' | 'italic' | null {
    return this.attributes['font-style'];
  }
  setFontStyle(fontStyle: 'normal' | 'italic' | null): HalfMuted {
    this.attributes['font-style'] = fontStyle;
    return this;
  }
  getFontWeight(): 'normal' | 'bold' | null {
    return this.attributes['font-weight'];
  }
  setFontWeight(fontWeight: 'normal' | 'bold' | null): HalfMuted {
    this.attributes['font-weight'] = fontWeight;
    return this;
  }
  getPlacement(): 'above' | 'below' | null {
    return this.attributes['placement'];
  }
  setPlacement(placement: 'above' | 'below' | null): HalfMuted {
    this.attributes['placement'] = placement;
    return this;
  }
  getRelativeX(): number | null {
    return this.attributes['relative-x'];
  }
  setRelativeX(relativeX: number | null): HalfMuted {
    this.attributes['relative-x'] = relativeX;
    return this;
  }
  getRelativeY(): number | null {
    return this.attributes['relative-y'];
  }
  setRelativeY(relativeY: number | null): HalfMuted {
    this.attributes['relative-y'] = relativeY;
    return this;
  }
  getSmufl(): string | null {
    return this.attributes['smufl'];
  }
  setSmufl(smufl: string | null): HalfMuted {
    this.attributes['smufl'] = smufl;
    return this;
  }
}

export type HarmonClosedAttributes = { location: 'bottom' | 'left' | 'right' | 'top' | null };

export type HarmonClosedContents = ['yes' | 'no' | 'half'];

export class HarmonClosed implements XMLElement<'harmon-closed', HarmonClosedAttributes, HarmonClosedContents> {
  static readonly schema = {
    name: 'harmon-closed',
    attributes: {
      location: { type: 'optional', value: { type: 'choices', choices: ['bottom', 'left', 'right', 'top'] } },
    },
    contents: [
      {
        type: 'required',
        value: {
          type: 'label',
          label: 'harmon-closed-value',
          value: { type: 'choices', choices: ['yes', 'no', 'half'] },
        },
      },
    ],
  } as const;

  readonly schema = HarmonClosed.schema;

  attributes: HarmonClosedAttributes;
  contents: HarmonClosedContents;

  constructor(opts?: { attributes?: Partial<HarmonClosedAttributes>; contents?: HarmonClosedContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, HarmonClosed.schema);
    this.contents = opts?.contents ?? operations.zero(HarmonClosed.schema.contents);
  }
  getLocation(): 'bottom' | 'left' | 'right' | 'top' | null {
    return this.attributes['location'];
  }
  setLocation(location: 'bottom' | 'left' | 'right' | 'top' | null): HarmonClosed {
    this.attributes['location'] = location;
    return this;
  }
  getHarmonClosedValue(): 'yes' | 'no' | 'half' {
    return this.contents[0];
  }
  setHarmonClosedValue(harmonClosedValue: 'yes' | 'no' | 'half'): HarmonClosed {
    this.contents[0] = harmonClosedValue;
    return this;
  }
}

export type HarmonMuteAttributes = {
  color: string | null;
  'default-x': number | null;
  'default-y': number | null;
  'font-family': string | null;
  'font-size': 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null;
  'font-style': 'normal' | 'italic' | null;
  'font-weight': 'normal' | 'bold' | null;
  placement: 'above' | 'below' | null;
  'relative-x': number | null;
  'relative-y': number | null;
  smufl: string | null;
};

export type HarmonMuteContents = [HarmonClosed];

export class HarmonMute implements XMLElement<'harmon-mute', HarmonMuteAttributes, HarmonMuteContents> {
  static readonly schema = {
    name: 'harmon-mute',
    attributes: {
      color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
      'default-x': {
        type: 'label',
        label: 'default-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'default-y': {
        type: 'label',
        label: 'default-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
      'font-size': {
        type: 'optional',
        value: {
          type: 'choices',
          choices: [
            { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
            { type: 'float', min: -Infinity, max: Infinity },
          ],
        },
      },
      'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
      'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
      placement: { type: 'optional', value: { type: 'choices', choices: ['above', 'below'] } },
      'relative-x': {
        type: 'label',
        label: 'relative-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'relative-y': {
        type: 'label',
        label: 'relative-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      smufl: { type: 'optional', value: { type: 'string' } },
    },
    contents: [{ type: 'required', value: HarmonClosed }],
  } as const;

  readonly schema = HarmonMute.schema;

  attributes: HarmonMuteAttributes;
  contents: HarmonMuteContents;

  constructor(opts?: { attributes?: Partial<HarmonMuteAttributes>; contents?: HarmonMuteContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, HarmonMute.schema);
    this.contents = opts?.contents ?? operations.zero(HarmonMute.schema.contents);
  }
  getColor(): string | null {
    return this.attributes['color'];
  }
  setColor(color: string | null): HarmonMute {
    this.attributes['color'] = color;
    return this;
  }
  getDefaultX(): number | null {
    return this.attributes['default-x'];
  }
  setDefaultX(defaultX: number | null): HarmonMute {
    this.attributes['default-x'] = defaultX;
    return this;
  }
  getDefaultY(): number | null {
    return this.attributes['default-y'];
  }
  setDefaultY(defaultY: number | null): HarmonMute {
    this.attributes['default-y'] = defaultY;
    return this;
  }
  getFontFamily(): string | null {
    return this.attributes['font-family'];
  }
  setFontFamily(fontFamily: string | null): HarmonMute {
    this.attributes['font-family'] = fontFamily;
    return this;
  }
  getFontSize(): 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null {
    return this.attributes['font-size'];
  }
  setFontSize(
    fontSize: 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null
  ): HarmonMute {
    this.attributes['font-size'] = fontSize;
    return this;
  }
  getFontStyle(): 'normal' | 'italic' | null {
    return this.attributes['font-style'];
  }
  setFontStyle(fontStyle: 'normal' | 'italic' | null): HarmonMute {
    this.attributes['font-style'] = fontStyle;
    return this;
  }
  getFontWeight(): 'normal' | 'bold' | null {
    return this.attributes['font-weight'];
  }
  setFontWeight(fontWeight: 'normal' | 'bold' | null): HarmonMute {
    this.attributes['font-weight'] = fontWeight;
    return this;
  }
  getPlacement(): 'above' | 'below' | null {
    return this.attributes['placement'];
  }
  setPlacement(placement: 'above' | 'below' | null): HarmonMute {
    this.attributes['placement'] = placement;
    return this;
  }
  getRelativeX(): number | null {
    return this.attributes['relative-x'];
  }
  setRelativeX(relativeX: number | null): HarmonMute {
    this.attributes['relative-x'] = relativeX;
    return this;
  }
  getRelativeY(): number | null {
    return this.attributes['relative-y'];
  }
  setRelativeY(relativeY: number | null): HarmonMute {
    this.attributes['relative-y'] = relativeY;
    return this;
  }
  getSmufl(): string | null {
    return this.attributes['smufl'];
  }
  setSmufl(smufl: string | null): HarmonMute {
    this.attributes['smufl'] = smufl;
    return this;
  }
  getHarmonClosed(): HarmonClosed {
    return this.contents[0];
  }
  setHarmonClosed(harmonClosed: HarmonClosed): HarmonMute {
    this.contents[0] = harmonClosed;
    return this;
  }
}

export type GolpeAttributes = {
  color: string | null;
  'default-x': number | null;
  'default-y': number | null;
  'font-family': string | null;
  'font-size': 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null;
  'font-style': 'normal' | 'italic' | null;
  'font-weight': 'normal' | 'bold' | null;
  placement: 'above' | 'below' | null;
  'relative-x': number | null;
  'relative-y': number | null;
};

export type GolpeContents = [];

export class Golpe implements XMLElement<'golpe', GolpeAttributes, GolpeContents> {
  static readonly schema = {
    name: 'golpe',
    attributes: {
      color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
      'default-x': {
        type: 'label',
        label: 'default-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'default-y': {
        type: 'label',
        label: 'default-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
      'font-size': {
        type: 'optional',
        value: {
          type: 'choices',
          choices: [
            { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
            { type: 'float', min: -Infinity, max: Infinity },
          ],
        },
      },
      'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
      'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
      placement: { type: 'optional', value: { type: 'choices', choices: ['above', 'below'] } },
      'relative-x': {
        type: 'label',
        label: 'relative-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'relative-y': {
        type: 'label',
        label: 'relative-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
    },
    contents: [],
  } as const;

  readonly schema = Golpe.schema;

  attributes: GolpeAttributes;
  contents: GolpeContents;

  constructor(opts?: { attributes?: Partial<GolpeAttributes>; contents?: GolpeContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Golpe.schema);
    this.contents = opts?.contents ?? operations.zero(Golpe.schema.contents);
  }
  getColor(): string | null {
    return this.attributes['color'];
  }
  setColor(color: string | null): Golpe {
    this.attributes['color'] = color;
    return this;
  }
  getDefaultX(): number | null {
    return this.attributes['default-x'];
  }
  setDefaultX(defaultX: number | null): Golpe {
    this.attributes['default-x'] = defaultX;
    return this;
  }
  getDefaultY(): number | null {
    return this.attributes['default-y'];
  }
  setDefaultY(defaultY: number | null): Golpe {
    this.attributes['default-y'] = defaultY;
    return this;
  }
  getFontFamily(): string | null {
    return this.attributes['font-family'];
  }
  setFontFamily(fontFamily: string | null): Golpe {
    this.attributes['font-family'] = fontFamily;
    return this;
  }
  getFontSize(): 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null {
    return this.attributes['font-size'];
  }
  setFontSize(
    fontSize: 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null
  ): Golpe {
    this.attributes['font-size'] = fontSize;
    return this;
  }
  getFontStyle(): 'normal' | 'italic' | null {
    return this.attributes['font-style'];
  }
  setFontStyle(fontStyle: 'normal' | 'italic' | null): Golpe {
    this.attributes['font-style'] = fontStyle;
    return this;
  }
  getFontWeight(): 'normal' | 'bold' | null {
    return this.attributes['font-weight'];
  }
  setFontWeight(fontWeight: 'normal' | 'bold' | null): Golpe {
    this.attributes['font-weight'] = fontWeight;
    return this;
  }
  getPlacement(): 'above' | 'below' | null {
    return this.attributes['placement'];
  }
  setPlacement(placement: 'above' | 'below' | null): Golpe {
    this.attributes['placement'] = placement;
    return this;
  }
  getRelativeX(): number | null {
    return this.attributes['relative-x'];
  }
  setRelativeX(relativeX: number | null): Golpe {
    this.attributes['relative-x'] = relativeX;
    return this;
  }
  getRelativeY(): number | null {
    return this.attributes['relative-y'];
  }
  setRelativeY(relativeY: number | null): Golpe {
    this.attributes['relative-y'] = relativeY;
    return this;
  }
}

export type OtherTechnicalAttributes = {
  color: string | null;
  'default-x': number | null;
  'default-y': number | null;
  'font-family': string | null;
  'font-size': 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null;
  'font-style': 'normal' | 'italic' | null;
  'font-weight': 'normal' | 'bold' | null;
  placement: 'above' | 'below' | null;
  'relative-x': number | null;
  'relative-y': number | null;
  smufl: string | null;
};

export type OtherTechnicalContents = [string | null];

export class OtherTechnical implements XMLElement<'other-technical', OtherTechnicalAttributes, OtherTechnicalContents> {
  static readonly schema = {
    name: 'other-technical',
    attributes: {
      color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
      'default-x': {
        type: 'label',
        label: 'default-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'default-y': {
        type: 'label',
        label: 'default-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
      'font-size': {
        type: 'optional',
        value: {
          type: 'choices',
          choices: [
            { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
            { type: 'float', min: -Infinity, max: Infinity },
          ],
        },
      },
      'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
      'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
      placement: { type: 'optional', value: { type: 'choices', choices: ['above', 'below'] } },
      'relative-x': {
        type: 'label',
        label: 'relative-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'relative-y': {
        type: 'label',
        label: 'relative-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      smufl: { type: 'optional', value: { type: 'string' } },
    },
    contents: [{ type: 'optional', value: { type: 'string' } }],
  } as const;

  readonly schema = OtherTechnical.schema;

  attributes: OtherTechnicalAttributes;
  contents: OtherTechnicalContents;

  constructor(opts?: { attributes?: Partial<OtherTechnicalAttributes>; contents?: OtherTechnicalContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, OtherTechnical.schema);
    this.contents = opts?.contents ?? operations.zero(OtherTechnical.schema.contents);
  }
  getColor(): string | null {
    return this.attributes['color'];
  }
  setColor(color: string | null): OtherTechnical {
    this.attributes['color'] = color;
    return this;
  }
  getDefaultX(): number | null {
    return this.attributes['default-x'];
  }
  setDefaultX(defaultX: number | null): OtherTechnical {
    this.attributes['default-x'] = defaultX;
    return this;
  }
  getDefaultY(): number | null {
    return this.attributes['default-y'];
  }
  setDefaultY(defaultY: number | null): OtherTechnical {
    this.attributes['default-y'] = defaultY;
    return this;
  }
  getFontFamily(): string | null {
    return this.attributes['font-family'];
  }
  setFontFamily(fontFamily: string | null): OtherTechnical {
    this.attributes['font-family'] = fontFamily;
    return this;
  }
  getFontSize(): 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null {
    return this.attributes['font-size'];
  }
  setFontSize(
    fontSize: 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null
  ): OtherTechnical {
    this.attributes['font-size'] = fontSize;
    return this;
  }
  getFontStyle(): 'normal' | 'italic' | null {
    return this.attributes['font-style'];
  }
  setFontStyle(fontStyle: 'normal' | 'italic' | null): OtherTechnical {
    this.attributes['font-style'] = fontStyle;
    return this;
  }
  getFontWeight(): 'normal' | 'bold' | null {
    return this.attributes['font-weight'];
  }
  setFontWeight(fontWeight: 'normal' | 'bold' | null): OtherTechnical {
    this.attributes['font-weight'] = fontWeight;
    return this;
  }
  getPlacement(): 'above' | 'below' | null {
    return this.attributes['placement'];
  }
  setPlacement(placement: 'above' | 'below' | null): OtherTechnical {
    this.attributes['placement'] = placement;
    return this;
  }
  getRelativeX(): number | null {
    return this.attributes['relative-x'];
  }
  setRelativeX(relativeX: number | null): OtherTechnical {
    this.attributes['relative-x'] = relativeX;
    return this;
  }
  getRelativeY(): number | null {
    return this.attributes['relative-y'];
  }
  setRelativeY(relativeY: number | null): OtherTechnical {
    this.attributes['relative-y'] = relativeY;
    return this;
  }
  getSmufl(): string | null {
    return this.attributes['smufl'];
  }
  setSmufl(smufl: string | null): OtherTechnical {
    this.attributes['smufl'] = smufl;
    return this;
  }
  getText(): string | null {
    return this.contents[0];
  }
  setText(text: string | null): OtherTechnical {
    this.contents[0] = text;
    return this;
  }
}

export type TechnicalAttributes = { id: string | null };

export type TechnicalContents = [
  Array<
    | UpBow
    | DownBow
    | Harmonic
    | OpenString
    | ThumbPosition
    | Fingering
    | Pluck
    | DoubleTongue
    | TripleTongue
    | Stopped
    | SnapPizzicato
    | Fret
    | String
    | HammerOn
    | PullOff
    | Bend
    | Tap
    | Heel
    | Toe
    | Fingernails
    | Hole
    | Arrow
    | Handbell
    | BrassBend
    | Flip
    | Smear
    | Open
    | HalfMuted
    | HarmonMute
    | Golpe
    | OtherTechnical
  >
];

export class Technical implements XMLElement<'technical', TechnicalAttributes, TechnicalContents> {
  static readonly schema = {
    name: 'technical',
    attributes: { id: { type: 'optional', value: { type: 'regex', pattern: /[A-Za-z_][A-Za-z0-9.-_]*/, zero: '_' } } },
    contents: [
      {
        type: 'label',
        label: 'technical-values',
        value: {
          type: 'zeroOrMore',
          value: {
            type: 'choices',
            choices: [
              UpBow,
              DownBow,
              Harmonic,
              OpenString,
              ThumbPosition,
              Fingering,
              Pluck,
              DoubleTongue,
              TripleTongue,
              Stopped,
              SnapPizzicato,
              Fret,
              String,
              HammerOn,
              PullOff,
              Bend,
              Tap,
              Heel,
              Toe,
              Fingernails,
              Hole,
              Arrow,
              Handbell,
              BrassBend,
              Flip,
              Smear,
              Open,
              HalfMuted,
              HarmonMute,
              Golpe,
              OtherTechnical,
            ],
          },
        },
      },
    ],
  } as const;

  readonly schema = Technical.schema;

  attributes: TechnicalAttributes;
  contents: TechnicalContents;

  constructor(opts?: { attributes?: Partial<TechnicalAttributes>; contents?: TechnicalContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Technical.schema);
    this.contents = opts?.contents ?? operations.zero(Technical.schema.contents);
  }
  getId(): string | null {
    return this.attributes['id'];
  }
  setId(id: string | null): Technical {
    this.attributes['id'] = id;
    return this;
  }
  getTechnicalValues(): Array<
    | UpBow
    | DownBow
    | Harmonic
    | OpenString
    | ThumbPosition
    | Fingering
    | Pluck
    | DoubleTongue
    | TripleTongue
    | Stopped
    | SnapPizzicato
    | Fret
    | String
    | HammerOn
    | PullOff
    | Bend
    | Tap
    | Heel
    | Toe
    | Fingernails
    | Hole
    | Arrow
    | Handbell
    | BrassBend
    | Flip
    | Smear
    | Open
    | HalfMuted
    | HarmonMute
    | Golpe
    | OtherTechnical
  > {
    return this.contents[0];
  }
  setTechnicalValues(
    technicalValues: Array<
      | UpBow
      | DownBow
      | Harmonic
      | OpenString
      | ThumbPosition
      | Fingering
      | Pluck
      | DoubleTongue
      | TripleTongue
      | Stopped
      | SnapPizzicato
      | Fret
      | String
      | HammerOn
      | PullOff
      | Bend
      | Tap
      | Heel
      | Toe
      | Fingernails
      | Hole
      | Arrow
      | Handbell
      | BrassBend
      | Flip
      | Smear
      | Open
      | HalfMuted
      | HarmonMute
      | Golpe
      | OtherTechnical
    >
  ): Technical {
    this.contents[0] = technicalValues;
    return this;
  }
}

export type AccentAttributes = {
  color: string | null;
  'default-x': number | null;
  'default-y': number | null;
  'font-family': string | null;
  'font-size': 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null;
  'font-style': 'normal' | 'italic' | null;
  'font-weight': 'normal' | 'bold' | null;
  placement: 'above' | 'below' | null;
  'relative-x': number | null;
  'relative-y': number | null;
};

export type AccentContents = [];

export class Accent implements XMLElement<'accent', AccentAttributes, AccentContents> {
  static readonly schema = {
    name: 'accent',
    attributes: {
      color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
      'default-x': {
        type: 'label',
        label: 'default-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'default-y': {
        type: 'label',
        label: 'default-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
      'font-size': {
        type: 'optional',
        value: {
          type: 'choices',
          choices: [
            { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
            { type: 'float', min: -Infinity, max: Infinity },
          ],
        },
      },
      'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
      'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
      placement: { type: 'optional', value: { type: 'choices', choices: ['above', 'below'] } },
      'relative-x': {
        type: 'label',
        label: 'relative-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'relative-y': {
        type: 'label',
        label: 'relative-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
    },
    contents: [],
  } as const;

  readonly schema = Accent.schema;

  attributes: AccentAttributes;
  contents: AccentContents;

  constructor(opts?: { attributes?: Partial<AccentAttributes>; contents?: AccentContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Accent.schema);
    this.contents = opts?.contents ?? operations.zero(Accent.schema.contents);
  }
  getColor(): string | null {
    return this.attributes['color'];
  }
  setColor(color: string | null): Accent {
    this.attributes['color'] = color;
    return this;
  }
  getDefaultX(): number | null {
    return this.attributes['default-x'];
  }
  setDefaultX(defaultX: number | null): Accent {
    this.attributes['default-x'] = defaultX;
    return this;
  }
  getDefaultY(): number | null {
    return this.attributes['default-y'];
  }
  setDefaultY(defaultY: number | null): Accent {
    this.attributes['default-y'] = defaultY;
    return this;
  }
  getFontFamily(): string | null {
    return this.attributes['font-family'];
  }
  setFontFamily(fontFamily: string | null): Accent {
    this.attributes['font-family'] = fontFamily;
    return this;
  }
  getFontSize(): 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null {
    return this.attributes['font-size'];
  }
  setFontSize(
    fontSize: 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null
  ): Accent {
    this.attributes['font-size'] = fontSize;
    return this;
  }
  getFontStyle(): 'normal' | 'italic' | null {
    return this.attributes['font-style'];
  }
  setFontStyle(fontStyle: 'normal' | 'italic' | null): Accent {
    this.attributes['font-style'] = fontStyle;
    return this;
  }
  getFontWeight(): 'normal' | 'bold' | null {
    return this.attributes['font-weight'];
  }
  setFontWeight(fontWeight: 'normal' | 'bold' | null): Accent {
    this.attributes['font-weight'] = fontWeight;
    return this;
  }
  getPlacement(): 'above' | 'below' | null {
    return this.attributes['placement'];
  }
  setPlacement(placement: 'above' | 'below' | null): Accent {
    this.attributes['placement'] = placement;
    return this;
  }
  getRelativeX(): number | null {
    return this.attributes['relative-x'];
  }
  setRelativeX(relativeX: number | null): Accent {
    this.attributes['relative-x'] = relativeX;
    return this;
  }
  getRelativeY(): number | null {
    return this.attributes['relative-y'];
  }
  setRelativeY(relativeY: number | null): Accent {
    this.attributes['relative-y'] = relativeY;
    return this;
  }
}

export type StrongAccentAttributes = {
  color: string | null;
  'default-x': number | null;
  'default-y': number | null;
  'font-family': string | null;
  'font-size': 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null;
  'font-style': 'normal' | 'italic' | null;
  'font-weight': 'normal' | 'bold' | null;
  placement: 'above' | 'below' | null;
  'relative-x': number | null;
  'relative-y': number | null;
  type: 'up' | 'down' | null;
};

export type StrongAccentContents = [];

export class StrongAccent implements XMLElement<'strong-accent', StrongAccentAttributes, StrongAccentContents> {
  static readonly schema = {
    name: 'strong-accent',
    attributes: {
      color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
      'default-x': {
        type: 'label',
        label: 'default-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'default-y': {
        type: 'label',
        label: 'default-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
      'font-size': {
        type: 'optional',
        value: {
          type: 'choices',
          choices: [
            { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
            { type: 'float', min: -Infinity, max: Infinity },
          ],
        },
      },
      'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
      'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
      placement: { type: 'optional', value: { type: 'choices', choices: ['above', 'below'] } },
      'relative-x': {
        type: 'label',
        label: 'relative-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'relative-y': {
        type: 'label',
        label: 'relative-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      type: { type: 'optional', value: { type: 'choices', choices: ['up', 'down'] } },
    },
    contents: [],
  } as const;

  readonly schema = StrongAccent.schema;

  attributes: StrongAccentAttributes;
  contents: StrongAccentContents;

  constructor(opts?: { attributes?: Partial<StrongAccentAttributes>; contents?: StrongAccentContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, StrongAccent.schema);
    this.contents = opts?.contents ?? operations.zero(StrongAccent.schema.contents);
  }
  getColor(): string | null {
    return this.attributes['color'];
  }
  setColor(color: string | null): StrongAccent {
    this.attributes['color'] = color;
    return this;
  }
  getDefaultX(): number | null {
    return this.attributes['default-x'];
  }
  setDefaultX(defaultX: number | null): StrongAccent {
    this.attributes['default-x'] = defaultX;
    return this;
  }
  getDefaultY(): number | null {
    return this.attributes['default-y'];
  }
  setDefaultY(defaultY: number | null): StrongAccent {
    this.attributes['default-y'] = defaultY;
    return this;
  }
  getFontFamily(): string | null {
    return this.attributes['font-family'];
  }
  setFontFamily(fontFamily: string | null): StrongAccent {
    this.attributes['font-family'] = fontFamily;
    return this;
  }
  getFontSize(): 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null {
    return this.attributes['font-size'];
  }
  setFontSize(
    fontSize: 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null
  ): StrongAccent {
    this.attributes['font-size'] = fontSize;
    return this;
  }
  getFontStyle(): 'normal' | 'italic' | null {
    return this.attributes['font-style'];
  }
  setFontStyle(fontStyle: 'normal' | 'italic' | null): StrongAccent {
    this.attributes['font-style'] = fontStyle;
    return this;
  }
  getFontWeight(): 'normal' | 'bold' | null {
    return this.attributes['font-weight'];
  }
  setFontWeight(fontWeight: 'normal' | 'bold' | null): StrongAccent {
    this.attributes['font-weight'] = fontWeight;
    return this;
  }
  getPlacement(): 'above' | 'below' | null {
    return this.attributes['placement'];
  }
  setPlacement(placement: 'above' | 'below' | null): StrongAccent {
    this.attributes['placement'] = placement;
    return this;
  }
  getRelativeX(): number | null {
    return this.attributes['relative-x'];
  }
  setRelativeX(relativeX: number | null): StrongAccent {
    this.attributes['relative-x'] = relativeX;
    return this;
  }
  getRelativeY(): number | null {
    return this.attributes['relative-y'];
  }
  setRelativeY(relativeY: number | null): StrongAccent {
    this.attributes['relative-y'] = relativeY;
    return this;
  }
  getType(): 'up' | 'down' | null {
    return this.attributes['type'];
  }
  setType(type: 'up' | 'down' | null): StrongAccent {
    this.attributes['type'] = type;
    return this;
  }
}

export type StaccatoAttributes = {
  color: string | null;
  'default-x': number | null;
  'default-y': number | null;
  'font-family': string | null;
  'font-size': 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null;
  'font-style': 'normal' | 'italic' | null;
  'font-weight': 'normal' | 'bold' | null;
  placement: 'above' | 'below' | null;
  'relative-x': number | null;
  'relative-y': number | null;
};

export type StaccatoContents = [];

export class Staccato implements XMLElement<'staccato', StaccatoAttributes, StaccatoContents> {
  static readonly schema = {
    name: 'staccato',
    attributes: {
      color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
      'default-x': {
        type: 'label',
        label: 'default-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'default-y': {
        type: 'label',
        label: 'default-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
      'font-size': {
        type: 'optional',
        value: {
          type: 'choices',
          choices: [
            { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
            { type: 'float', min: -Infinity, max: Infinity },
          ],
        },
      },
      'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
      'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
      placement: { type: 'optional', value: { type: 'choices', choices: ['above', 'below'] } },
      'relative-x': {
        type: 'label',
        label: 'relative-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'relative-y': {
        type: 'label',
        label: 'relative-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
    },
    contents: [],
  } as const;

  readonly schema = Staccato.schema;

  attributes: StaccatoAttributes;
  contents: StaccatoContents;

  constructor(opts?: { attributes?: Partial<StaccatoAttributes>; contents?: StaccatoContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Staccato.schema);
    this.contents = opts?.contents ?? operations.zero(Staccato.schema.contents);
  }
  getColor(): string | null {
    return this.attributes['color'];
  }
  setColor(color: string | null): Staccato {
    this.attributes['color'] = color;
    return this;
  }
  getDefaultX(): number | null {
    return this.attributes['default-x'];
  }
  setDefaultX(defaultX: number | null): Staccato {
    this.attributes['default-x'] = defaultX;
    return this;
  }
  getDefaultY(): number | null {
    return this.attributes['default-y'];
  }
  setDefaultY(defaultY: number | null): Staccato {
    this.attributes['default-y'] = defaultY;
    return this;
  }
  getFontFamily(): string | null {
    return this.attributes['font-family'];
  }
  setFontFamily(fontFamily: string | null): Staccato {
    this.attributes['font-family'] = fontFamily;
    return this;
  }
  getFontSize(): 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null {
    return this.attributes['font-size'];
  }
  setFontSize(
    fontSize: 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null
  ): Staccato {
    this.attributes['font-size'] = fontSize;
    return this;
  }
  getFontStyle(): 'normal' | 'italic' | null {
    return this.attributes['font-style'];
  }
  setFontStyle(fontStyle: 'normal' | 'italic' | null): Staccato {
    this.attributes['font-style'] = fontStyle;
    return this;
  }
  getFontWeight(): 'normal' | 'bold' | null {
    return this.attributes['font-weight'];
  }
  setFontWeight(fontWeight: 'normal' | 'bold' | null): Staccato {
    this.attributes['font-weight'] = fontWeight;
    return this;
  }
  getPlacement(): 'above' | 'below' | null {
    return this.attributes['placement'];
  }
  setPlacement(placement: 'above' | 'below' | null): Staccato {
    this.attributes['placement'] = placement;
    return this;
  }
  getRelativeX(): number | null {
    return this.attributes['relative-x'];
  }
  setRelativeX(relativeX: number | null): Staccato {
    this.attributes['relative-x'] = relativeX;
    return this;
  }
  getRelativeY(): number | null {
    return this.attributes['relative-y'];
  }
  setRelativeY(relativeY: number | null): Staccato {
    this.attributes['relative-y'] = relativeY;
    return this;
  }
}

export type TenutoAttributes = {
  color: string | null;
  'default-x': number | null;
  'default-y': number | null;
  'font-family': string | null;
  'font-size': 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null;
  'font-style': 'normal' | 'italic' | null;
  'font-weight': 'normal' | 'bold' | null;
  placement: 'above' | 'below' | null;
  'relative-x': number | null;
  'relative-y': number | null;
};

export type TenutoContents = [];

export class Tenuto implements XMLElement<'tenuto', TenutoAttributes, TenutoContents> {
  static readonly schema = {
    name: 'tenuto',
    attributes: {
      color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
      'default-x': {
        type: 'label',
        label: 'default-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'default-y': {
        type: 'label',
        label: 'default-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
      'font-size': {
        type: 'optional',
        value: {
          type: 'choices',
          choices: [
            { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
            { type: 'float', min: -Infinity, max: Infinity },
          ],
        },
      },
      'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
      'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
      placement: { type: 'optional', value: { type: 'choices', choices: ['above', 'below'] } },
      'relative-x': {
        type: 'label',
        label: 'relative-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'relative-y': {
        type: 'label',
        label: 'relative-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
    },
    contents: [],
  } as const;

  readonly schema = Tenuto.schema;

  attributes: TenutoAttributes;
  contents: TenutoContents;

  constructor(opts?: { attributes?: Partial<TenutoAttributes>; contents?: TenutoContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Tenuto.schema);
    this.contents = opts?.contents ?? operations.zero(Tenuto.schema.contents);
  }
  getColor(): string | null {
    return this.attributes['color'];
  }
  setColor(color: string | null): Tenuto {
    this.attributes['color'] = color;
    return this;
  }
  getDefaultX(): number | null {
    return this.attributes['default-x'];
  }
  setDefaultX(defaultX: number | null): Tenuto {
    this.attributes['default-x'] = defaultX;
    return this;
  }
  getDefaultY(): number | null {
    return this.attributes['default-y'];
  }
  setDefaultY(defaultY: number | null): Tenuto {
    this.attributes['default-y'] = defaultY;
    return this;
  }
  getFontFamily(): string | null {
    return this.attributes['font-family'];
  }
  setFontFamily(fontFamily: string | null): Tenuto {
    this.attributes['font-family'] = fontFamily;
    return this;
  }
  getFontSize(): 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null {
    return this.attributes['font-size'];
  }
  setFontSize(
    fontSize: 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null
  ): Tenuto {
    this.attributes['font-size'] = fontSize;
    return this;
  }
  getFontStyle(): 'normal' | 'italic' | null {
    return this.attributes['font-style'];
  }
  setFontStyle(fontStyle: 'normal' | 'italic' | null): Tenuto {
    this.attributes['font-style'] = fontStyle;
    return this;
  }
  getFontWeight(): 'normal' | 'bold' | null {
    return this.attributes['font-weight'];
  }
  setFontWeight(fontWeight: 'normal' | 'bold' | null): Tenuto {
    this.attributes['font-weight'] = fontWeight;
    return this;
  }
  getPlacement(): 'above' | 'below' | null {
    return this.attributes['placement'];
  }
  setPlacement(placement: 'above' | 'below' | null): Tenuto {
    this.attributes['placement'] = placement;
    return this;
  }
  getRelativeX(): number | null {
    return this.attributes['relative-x'];
  }
  setRelativeX(relativeX: number | null): Tenuto {
    this.attributes['relative-x'] = relativeX;
    return this;
  }
  getRelativeY(): number | null {
    return this.attributes['relative-y'];
  }
  setRelativeY(relativeY: number | null): Tenuto {
    this.attributes['relative-y'] = relativeY;
    return this;
  }
}

export type DetachedLegatoAttributes = {
  color: string | null;
  'default-x': number | null;
  'default-y': number | null;
  'font-family': string | null;
  'font-size': 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null;
  'font-style': 'normal' | 'italic' | null;
  'font-weight': 'normal' | 'bold' | null;
  placement: 'above' | 'below' | null;
  'relative-x': number | null;
  'relative-y': number | null;
};

export type DetachedLegatoContents = [];

export class DetachedLegato implements XMLElement<'detached-legato', DetachedLegatoAttributes, DetachedLegatoContents> {
  static readonly schema = {
    name: 'detached-legato',
    attributes: {
      color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
      'default-x': {
        type: 'label',
        label: 'default-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'default-y': {
        type: 'label',
        label: 'default-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
      'font-size': {
        type: 'optional',
        value: {
          type: 'choices',
          choices: [
            { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
            { type: 'float', min: -Infinity, max: Infinity },
          ],
        },
      },
      'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
      'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
      placement: { type: 'optional', value: { type: 'choices', choices: ['above', 'below'] } },
      'relative-x': {
        type: 'label',
        label: 'relative-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'relative-y': {
        type: 'label',
        label: 'relative-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
    },
    contents: [],
  } as const;

  readonly schema = DetachedLegato.schema;

  attributes: DetachedLegatoAttributes;
  contents: DetachedLegatoContents;

  constructor(opts?: { attributes?: Partial<DetachedLegatoAttributes>; contents?: DetachedLegatoContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, DetachedLegato.schema);
    this.contents = opts?.contents ?? operations.zero(DetachedLegato.schema.contents);
  }
  getColor(): string | null {
    return this.attributes['color'];
  }
  setColor(color: string | null): DetachedLegato {
    this.attributes['color'] = color;
    return this;
  }
  getDefaultX(): number | null {
    return this.attributes['default-x'];
  }
  setDefaultX(defaultX: number | null): DetachedLegato {
    this.attributes['default-x'] = defaultX;
    return this;
  }
  getDefaultY(): number | null {
    return this.attributes['default-y'];
  }
  setDefaultY(defaultY: number | null): DetachedLegato {
    this.attributes['default-y'] = defaultY;
    return this;
  }
  getFontFamily(): string | null {
    return this.attributes['font-family'];
  }
  setFontFamily(fontFamily: string | null): DetachedLegato {
    this.attributes['font-family'] = fontFamily;
    return this;
  }
  getFontSize(): 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null {
    return this.attributes['font-size'];
  }
  setFontSize(
    fontSize: 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null
  ): DetachedLegato {
    this.attributes['font-size'] = fontSize;
    return this;
  }
  getFontStyle(): 'normal' | 'italic' | null {
    return this.attributes['font-style'];
  }
  setFontStyle(fontStyle: 'normal' | 'italic' | null): DetachedLegato {
    this.attributes['font-style'] = fontStyle;
    return this;
  }
  getFontWeight(): 'normal' | 'bold' | null {
    return this.attributes['font-weight'];
  }
  setFontWeight(fontWeight: 'normal' | 'bold' | null): DetachedLegato {
    this.attributes['font-weight'] = fontWeight;
    return this;
  }
  getPlacement(): 'above' | 'below' | null {
    return this.attributes['placement'];
  }
  setPlacement(placement: 'above' | 'below' | null): DetachedLegato {
    this.attributes['placement'] = placement;
    return this;
  }
  getRelativeX(): number | null {
    return this.attributes['relative-x'];
  }
  setRelativeX(relativeX: number | null): DetachedLegato {
    this.attributes['relative-x'] = relativeX;
    return this;
  }
  getRelativeY(): number | null {
    return this.attributes['relative-y'];
  }
  setRelativeY(relativeY: number | null): DetachedLegato {
    this.attributes['relative-y'] = relativeY;
    return this;
  }
}

export type StaccatissimoAttributes = {
  color: string | null;
  'default-x': number | null;
  'default-y': number | null;
  'font-family': string | null;
  'font-size': 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null;
  'font-style': 'normal' | 'italic' | null;
  'font-weight': 'normal' | 'bold' | null;
  placement: 'above' | 'below' | null;
  'relative-x': number | null;
  'relative-y': number | null;
};

export type StaccatissimoContents = [];

export class Staccatissimo implements XMLElement<'staccatissimo', StaccatissimoAttributes, StaccatissimoContents> {
  static readonly schema = {
    name: 'staccatissimo',
    attributes: {
      color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
      'default-x': {
        type: 'label',
        label: 'default-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'default-y': {
        type: 'label',
        label: 'default-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
      'font-size': {
        type: 'optional',
        value: {
          type: 'choices',
          choices: [
            { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
            { type: 'float', min: -Infinity, max: Infinity },
          ],
        },
      },
      'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
      'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
      placement: { type: 'optional', value: { type: 'choices', choices: ['above', 'below'] } },
      'relative-x': {
        type: 'label',
        label: 'relative-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'relative-y': {
        type: 'label',
        label: 'relative-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
    },
    contents: [],
  } as const;

  readonly schema = Staccatissimo.schema;

  attributes: StaccatissimoAttributes;
  contents: StaccatissimoContents;

  constructor(opts?: { attributes?: Partial<StaccatissimoAttributes>; contents?: StaccatissimoContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Staccatissimo.schema);
    this.contents = opts?.contents ?? operations.zero(Staccatissimo.schema.contents);
  }
  getColor(): string | null {
    return this.attributes['color'];
  }
  setColor(color: string | null): Staccatissimo {
    this.attributes['color'] = color;
    return this;
  }
  getDefaultX(): number | null {
    return this.attributes['default-x'];
  }
  setDefaultX(defaultX: number | null): Staccatissimo {
    this.attributes['default-x'] = defaultX;
    return this;
  }
  getDefaultY(): number | null {
    return this.attributes['default-y'];
  }
  setDefaultY(defaultY: number | null): Staccatissimo {
    this.attributes['default-y'] = defaultY;
    return this;
  }
  getFontFamily(): string | null {
    return this.attributes['font-family'];
  }
  setFontFamily(fontFamily: string | null): Staccatissimo {
    this.attributes['font-family'] = fontFamily;
    return this;
  }
  getFontSize(): 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null {
    return this.attributes['font-size'];
  }
  setFontSize(
    fontSize: 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null
  ): Staccatissimo {
    this.attributes['font-size'] = fontSize;
    return this;
  }
  getFontStyle(): 'normal' | 'italic' | null {
    return this.attributes['font-style'];
  }
  setFontStyle(fontStyle: 'normal' | 'italic' | null): Staccatissimo {
    this.attributes['font-style'] = fontStyle;
    return this;
  }
  getFontWeight(): 'normal' | 'bold' | null {
    return this.attributes['font-weight'];
  }
  setFontWeight(fontWeight: 'normal' | 'bold' | null): Staccatissimo {
    this.attributes['font-weight'] = fontWeight;
    return this;
  }
  getPlacement(): 'above' | 'below' | null {
    return this.attributes['placement'];
  }
  setPlacement(placement: 'above' | 'below' | null): Staccatissimo {
    this.attributes['placement'] = placement;
    return this;
  }
  getRelativeX(): number | null {
    return this.attributes['relative-x'];
  }
  setRelativeX(relativeX: number | null): Staccatissimo {
    this.attributes['relative-x'] = relativeX;
    return this;
  }
  getRelativeY(): number | null {
    return this.attributes['relative-y'];
  }
  setRelativeY(relativeY: number | null): Staccatissimo {
    this.attributes['relative-y'] = relativeY;
    return this;
  }
}

export type SpiccatoAttributes = {
  color: string | null;
  'default-x': number | null;
  'default-y': number | null;
  'font-family': string | null;
  'font-size': 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null;
  'font-style': 'normal' | 'italic' | null;
  'font-weight': 'normal' | 'bold' | null;
  placement: 'above' | 'below' | null;
  'relative-x': number | null;
  'relative-y': number | null;
};

export type SpiccatoContents = [];

export class Spiccato implements XMLElement<'spiccato', SpiccatoAttributes, SpiccatoContents> {
  static readonly schema = {
    name: 'spiccato',
    attributes: {
      color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
      'default-x': {
        type: 'label',
        label: 'default-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'default-y': {
        type: 'label',
        label: 'default-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
      'font-size': {
        type: 'optional',
        value: {
          type: 'choices',
          choices: [
            { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
            { type: 'float', min: -Infinity, max: Infinity },
          ],
        },
      },
      'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
      'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
      placement: { type: 'optional', value: { type: 'choices', choices: ['above', 'below'] } },
      'relative-x': {
        type: 'label',
        label: 'relative-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'relative-y': {
        type: 'label',
        label: 'relative-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
    },
    contents: [],
  } as const;

  readonly schema = Spiccato.schema;

  attributes: SpiccatoAttributes;
  contents: SpiccatoContents;

  constructor(opts?: { attributes?: Partial<SpiccatoAttributes>; contents?: SpiccatoContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Spiccato.schema);
    this.contents = opts?.contents ?? operations.zero(Spiccato.schema.contents);
  }
  getColor(): string | null {
    return this.attributes['color'];
  }
  setColor(color: string | null): Spiccato {
    this.attributes['color'] = color;
    return this;
  }
  getDefaultX(): number | null {
    return this.attributes['default-x'];
  }
  setDefaultX(defaultX: number | null): Spiccato {
    this.attributes['default-x'] = defaultX;
    return this;
  }
  getDefaultY(): number | null {
    return this.attributes['default-y'];
  }
  setDefaultY(defaultY: number | null): Spiccato {
    this.attributes['default-y'] = defaultY;
    return this;
  }
  getFontFamily(): string | null {
    return this.attributes['font-family'];
  }
  setFontFamily(fontFamily: string | null): Spiccato {
    this.attributes['font-family'] = fontFamily;
    return this;
  }
  getFontSize(): 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null {
    return this.attributes['font-size'];
  }
  setFontSize(
    fontSize: 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null
  ): Spiccato {
    this.attributes['font-size'] = fontSize;
    return this;
  }
  getFontStyle(): 'normal' | 'italic' | null {
    return this.attributes['font-style'];
  }
  setFontStyle(fontStyle: 'normal' | 'italic' | null): Spiccato {
    this.attributes['font-style'] = fontStyle;
    return this;
  }
  getFontWeight(): 'normal' | 'bold' | null {
    return this.attributes['font-weight'];
  }
  setFontWeight(fontWeight: 'normal' | 'bold' | null): Spiccato {
    this.attributes['font-weight'] = fontWeight;
    return this;
  }
  getPlacement(): 'above' | 'below' | null {
    return this.attributes['placement'];
  }
  setPlacement(placement: 'above' | 'below' | null): Spiccato {
    this.attributes['placement'] = placement;
    return this;
  }
  getRelativeX(): number | null {
    return this.attributes['relative-x'];
  }
  setRelativeX(relativeX: number | null): Spiccato {
    this.attributes['relative-x'] = relativeX;
    return this;
  }
  getRelativeY(): number | null {
    return this.attributes['relative-y'];
  }
  setRelativeY(relativeY: number | null): Spiccato {
    this.attributes['relative-y'] = relativeY;
    return this;
  }
}

export type ScoopAttributes = {
  color: string | null;
  'default-x': number | null;
  'default-y': number | null;
  'font-family': string | null;
  'font-size': 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null;
  'font-style': 'normal' | 'italic' | null;
  'font-weight': 'normal' | 'bold' | null;
  placement: 'above' | 'below' | null;
  'relative-x': number | null;
  'relative-y': number | null;
};

export type ScoopContents = [];

export class Scoop implements XMLElement<'scoop', ScoopAttributes, ScoopContents> {
  static readonly schema = {
    name: 'scoop',
    attributes: {
      color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
      'default-x': {
        type: 'label',
        label: 'default-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'default-y': {
        type: 'label',
        label: 'default-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
      'font-size': {
        type: 'optional',
        value: {
          type: 'choices',
          choices: [
            { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
            { type: 'float', min: -Infinity, max: Infinity },
          ],
        },
      },
      'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
      'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
      placement: { type: 'optional', value: { type: 'choices', choices: ['above', 'below'] } },
      'relative-x': {
        type: 'label',
        label: 'relative-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'relative-y': {
        type: 'label',
        label: 'relative-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
    },
    contents: [],
  } as const;

  readonly schema = Scoop.schema;

  attributes: ScoopAttributes;
  contents: ScoopContents;

  constructor(opts?: { attributes?: Partial<ScoopAttributes>; contents?: ScoopContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Scoop.schema);
    this.contents = opts?.contents ?? operations.zero(Scoop.schema.contents);
  }
  getColor(): string | null {
    return this.attributes['color'];
  }
  setColor(color: string | null): Scoop {
    this.attributes['color'] = color;
    return this;
  }
  getDefaultX(): number | null {
    return this.attributes['default-x'];
  }
  setDefaultX(defaultX: number | null): Scoop {
    this.attributes['default-x'] = defaultX;
    return this;
  }
  getDefaultY(): number | null {
    return this.attributes['default-y'];
  }
  setDefaultY(defaultY: number | null): Scoop {
    this.attributes['default-y'] = defaultY;
    return this;
  }
  getFontFamily(): string | null {
    return this.attributes['font-family'];
  }
  setFontFamily(fontFamily: string | null): Scoop {
    this.attributes['font-family'] = fontFamily;
    return this;
  }
  getFontSize(): 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null {
    return this.attributes['font-size'];
  }
  setFontSize(
    fontSize: 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null
  ): Scoop {
    this.attributes['font-size'] = fontSize;
    return this;
  }
  getFontStyle(): 'normal' | 'italic' | null {
    return this.attributes['font-style'];
  }
  setFontStyle(fontStyle: 'normal' | 'italic' | null): Scoop {
    this.attributes['font-style'] = fontStyle;
    return this;
  }
  getFontWeight(): 'normal' | 'bold' | null {
    return this.attributes['font-weight'];
  }
  setFontWeight(fontWeight: 'normal' | 'bold' | null): Scoop {
    this.attributes['font-weight'] = fontWeight;
    return this;
  }
  getPlacement(): 'above' | 'below' | null {
    return this.attributes['placement'];
  }
  setPlacement(placement: 'above' | 'below' | null): Scoop {
    this.attributes['placement'] = placement;
    return this;
  }
  getRelativeX(): number | null {
    return this.attributes['relative-x'];
  }
  setRelativeX(relativeX: number | null): Scoop {
    this.attributes['relative-x'] = relativeX;
    return this;
  }
  getRelativeY(): number | null {
    return this.attributes['relative-y'];
  }
  setRelativeY(relativeY: number | null): Scoop {
    this.attributes['relative-y'] = relativeY;
    return this;
  }
}

export type PlopAttributes = {
  color: string | null;
  'dash-length': number | null;
  'default-x': number | null;
  'default-y': number | null;
  'font-family': string | null;
  'font-size': 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null;
  'font-style': 'normal' | 'italic' | null;
  'font-weight': 'normal' | 'bold' | null;
  'line-length': 'short' | 'medium' | 'long' | null;
  'line-shape': 'straight' | 'curved' | null;
  'line-type': 'dashed' | 'dotted' | 'solid' | 'wavy' | null;
  placement: 'above' | 'below' | null;
  'relative-x': number | null;
  'relative-y': number | null;
  'space-length': number | null;
};

export type PlopContents = [];

export class Plop implements XMLElement<'plop', PlopAttributes, PlopContents> {
  static readonly schema = {
    name: 'plop',
    attributes: {
      color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
      'dash-length': { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      'default-x': {
        type: 'label',
        label: 'default-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'default-y': {
        type: 'label',
        label: 'default-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
      'font-size': {
        type: 'optional',
        value: {
          type: 'choices',
          choices: [
            { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
            { type: 'float', min: -Infinity, max: Infinity },
          ],
        },
      },
      'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
      'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
      'line-length': { type: 'optional', value: { type: 'choices', choices: ['short', 'medium', 'long'] } },
      'line-shape': { type: 'optional', value: { type: 'choices', choices: ['straight', 'curved'] } },
      'line-type': { type: 'optional', value: { type: 'choices', choices: ['dashed', 'dotted', 'solid', 'wavy'] } },
      placement: { type: 'optional', value: { type: 'choices', choices: ['above', 'below'] } },
      'relative-x': {
        type: 'label',
        label: 'relative-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'relative-y': {
        type: 'label',
        label: 'relative-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'space-length': { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
    },
    contents: [],
  } as const;

  readonly schema = Plop.schema;

  attributes: PlopAttributes;
  contents: PlopContents;

  constructor(opts?: { attributes?: Partial<PlopAttributes>; contents?: PlopContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Plop.schema);
    this.contents = opts?.contents ?? operations.zero(Plop.schema.contents);
  }
  getColor(): string | null {
    return this.attributes['color'];
  }
  setColor(color: string | null): Plop {
    this.attributes['color'] = color;
    return this;
  }
  getDashLength(): number | null {
    return this.attributes['dash-length'];
  }
  setDashLength(dashLength: number | null): Plop {
    this.attributes['dash-length'] = dashLength;
    return this;
  }
  getDefaultX(): number | null {
    return this.attributes['default-x'];
  }
  setDefaultX(defaultX: number | null): Plop {
    this.attributes['default-x'] = defaultX;
    return this;
  }
  getDefaultY(): number | null {
    return this.attributes['default-y'];
  }
  setDefaultY(defaultY: number | null): Plop {
    this.attributes['default-y'] = defaultY;
    return this;
  }
  getFontFamily(): string | null {
    return this.attributes['font-family'];
  }
  setFontFamily(fontFamily: string | null): Plop {
    this.attributes['font-family'] = fontFamily;
    return this;
  }
  getFontSize(): 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null {
    return this.attributes['font-size'];
  }
  setFontSize(
    fontSize: 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null
  ): Plop {
    this.attributes['font-size'] = fontSize;
    return this;
  }
  getFontStyle(): 'normal' | 'italic' | null {
    return this.attributes['font-style'];
  }
  setFontStyle(fontStyle: 'normal' | 'italic' | null): Plop {
    this.attributes['font-style'] = fontStyle;
    return this;
  }
  getFontWeight(): 'normal' | 'bold' | null {
    return this.attributes['font-weight'];
  }
  setFontWeight(fontWeight: 'normal' | 'bold' | null): Plop {
    this.attributes['font-weight'] = fontWeight;
    return this;
  }
  getLineLength(): 'short' | 'medium' | 'long' | null {
    return this.attributes['line-length'];
  }
  setLineLength(lineLength: 'short' | 'medium' | 'long' | null): Plop {
    this.attributes['line-length'] = lineLength;
    return this;
  }
  getLineShape(): 'straight' | 'curved' | null {
    return this.attributes['line-shape'];
  }
  setLineShape(lineShape: 'straight' | 'curved' | null): Plop {
    this.attributes['line-shape'] = lineShape;
    return this;
  }
  getLineType(): 'dashed' | 'dotted' | 'solid' | 'wavy' | null {
    return this.attributes['line-type'];
  }
  setLineType(lineType: 'dashed' | 'dotted' | 'solid' | 'wavy' | null): Plop {
    this.attributes['line-type'] = lineType;
    return this;
  }
  getPlacement(): 'above' | 'below' | null {
    return this.attributes['placement'];
  }
  setPlacement(placement: 'above' | 'below' | null): Plop {
    this.attributes['placement'] = placement;
    return this;
  }
  getRelativeX(): number | null {
    return this.attributes['relative-x'];
  }
  setRelativeX(relativeX: number | null): Plop {
    this.attributes['relative-x'] = relativeX;
    return this;
  }
  getRelativeY(): number | null {
    return this.attributes['relative-y'];
  }
  setRelativeY(relativeY: number | null): Plop {
    this.attributes['relative-y'] = relativeY;
    return this;
  }
  getSpaceLength(): number | null {
    return this.attributes['space-length'];
  }
  setSpaceLength(spaceLength: number | null): Plop {
    this.attributes['space-length'] = spaceLength;
    return this;
  }
}

export type DoitAttributes = {
  color: string | null;
  'dash-length': number | null;
  'default-x': number | null;
  'default-y': number | null;
  'font-family': string | null;
  'font-size': 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null;
  'font-style': 'normal' | 'italic' | null;
  'font-weight': 'normal' | 'bold' | null;
  'line-length': 'short' | 'medium' | 'long' | null;
  'line-shape': 'straight' | 'curved' | null;
  'line-type': 'dashed' | 'dotted' | 'solid' | 'wavy' | null;
  placement: 'above' | 'below' | null;
  'relative-x': number | null;
  'relative-y': number | null;
  'space-length': number | null;
};

export type DoitContents = [];

export class Doit implements XMLElement<'doit', DoitAttributes, DoitContents> {
  static readonly schema = {
    name: 'doit',
    attributes: {
      color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
      'dash-length': { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      'default-x': {
        type: 'label',
        label: 'default-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'default-y': {
        type: 'label',
        label: 'default-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
      'font-size': {
        type: 'optional',
        value: {
          type: 'choices',
          choices: [
            { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
            { type: 'float', min: -Infinity, max: Infinity },
          ],
        },
      },
      'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
      'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
      'line-length': { type: 'optional', value: { type: 'choices', choices: ['short', 'medium', 'long'] } },
      'line-shape': { type: 'optional', value: { type: 'choices', choices: ['straight', 'curved'] } },
      'line-type': { type: 'optional', value: { type: 'choices', choices: ['dashed', 'dotted', 'solid', 'wavy'] } },
      placement: { type: 'optional', value: { type: 'choices', choices: ['above', 'below'] } },
      'relative-x': {
        type: 'label',
        label: 'relative-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'relative-y': {
        type: 'label',
        label: 'relative-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'space-length': { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
    },
    contents: [],
  } as const;

  readonly schema = Doit.schema;

  attributes: DoitAttributes;
  contents: DoitContents;

  constructor(opts?: { attributes?: Partial<DoitAttributes>; contents?: DoitContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Doit.schema);
    this.contents = opts?.contents ?? operations.zero(Doit.schema.contents);
  }
  getColor(): string | null {
    return this.attributes['color'];
  }
  setColor(color: string | null): Doit {
    this.attributes['color'] = color;
    return this;
  }
  getDashLength(): number | null {
    return this.attributes['dash-length'];
  }
  setDashLength(dashLength: number | null): Doit {
    this.attributes['dash-length'] = dashLength;
    return this;
  }
  getDefaultX(): number | null {
    return this.attributes['default-x'];
  }
  setDefaultX(defaultX: number | null): Doit {
    this.attributes['default-x'] = defaultX;
    return this;
  }
  getDefaultY(): number | null {
    return this.attributes['default-y'];
  }
  setDefaultY(defaultY: number | null): Doit {
    this.attributes['default-y'] = defaultY;
    return this;
  }
  getFontFamily(): string | null {
    return this.attributes['font-family'];
  }
  setFontFamily(fontFamily: string | null): Doit {
    this.attributes['font-family'] = fontFamily;
    return this;
  }
  getFontSize(): 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null {
    return this.attributes['font-size'];
  }
  setFontSize(
    fontSize: 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null
  ): Doit {
    this.attributes['font-size'] = fontSize;
    return this;
  }
  getFontStyle(): 'normal' | 'italic' | null {
    return this.attributes['font-style'];
  }
  setFontStyle(fontStyle: 'normal' | 'italic' | null): Doit {
    this.attributes['font-style'] = fontStyle;
    return this;
  }
  getFontWeight(): 'normal' | 'bold' | null {
    return this.attributes['font-weight'];
  }
  setFontWeight(fontWeight: 'normal' | 'bold' | null): Doit {
    this.attributes['font-weight'] = fontWeight;
    return this;
  }
  getLineLength(): 'short' | 'medium' | 'long' | null {
    return this.attributes['line-length'];
  }
  setLineLength(lineLength: 'short' | 'medium' | 'long' | null): Doit {
    this.attributes['line-length'] = lineLength;
    return this;
  }
  getLineShape(): 'straight' | 'curved' | null {
    return this.attributes['line-shape'];
  }
  setLineShape(lineShape: 'straight' | 'curved' | null): Doit {
    this.attributes['line-shape'] = lineShape;
    return this;
  }
  getLineType(): 'dashed' | 'dotted' | 'solid' | 'wavy' | null {
    return this.attributes['line-type'];
  }
  setLineType(lineType: 'dashed' | 'dotted' | 'solid' | 'wavy' | null): Doit {
    this.attributes['line-type'] = lineType;
    return this;
  }
  getPlacement(): 'above' | 'below' | null {
    return this.attributes['placement'];
  }
  setPlacement(placement: 'above' | 'below' | null): Doit {
    this.attributes['placement'] = placement;
    return this;
  }
  getRelativeX(): number | null {
    return this.attributes['relative-x'];
  }
  setRelativeX(relativeX: number | null): Doit {
    this.attributes['relative-x'] = relativeX;
    return this;
  }
  getRelativeY(): number | null {
    return this.attributes['relative-y'];
  }
  setRelativeY(relativeY: number | null): Doit {
    this.attributes['relative-y'] = relativeY;
    return this;
  }
  getSpaceLength(): number | null {
    return this.attributes['space-length'];
  }
  setSpaceLength(spaceLength: number | null): Doit {
    this.attributes['space-length'] = spaceLength;
    return this;
  }
}

export type FalloffAttributes = {
  color: string | null;
  'dash-length': number | null;
  'default-x': number | null;
  'default-y': number | null;
  'font-family': string | null;
  'font-size': 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null;
  'font-style': 'normal' | 'italic' | null;
  'font-weight': 'normal' | 'bold' | null;
  'line-length': 'short' | 'medium' | 'long' | null;
  'line-shape': 'straight' | 'curved' | null;
  'line-type': 'dashed' | 'dotted' | 'solid' | 'wavy' | null;
  placement: 'above' | 'below' | null;
  'relative-x': number | null;
  'relative-y': number | null;
  'space-length': number | null;
};

export type FalloffContents = [];

export class Falloff implements XMLElement<'falloff', FalloffAttributes, FalloffContents> {
  static readonly schema = {
    name: 'falloff',
    attributes: {
      color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
      'dash-length': { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      'default-x': {
        type: 'label',
        label: 'default-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'default-y': {
        type: 'label',
        label: 'default-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
      'font-size': {
        type: 'optional',
        value: {
          type: 'choices',
          choices: [
            { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
            { type: 'float', min: -Infinity, max: Infinity },
          ],
        },
      },
      'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
      'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
      'line-length': { type: 'optional', value: { type: 'choices', choices: ['short', 'medium', 'long'] } },
      'line-shape': { type: 'optional', value: { type: 'choices', choices: ['straight', 'curved'] } },
      'line-type': { type: 'optional', value: { type: 'choices', choices: ['dashed', 'dotted', 'solid', 'wavy'] } },
      placement: { type: 'optional', value: { type: 'choices', choices: ['above', 'below'] } },
      'relative-x': {
        type: 'label',
        label: 'relative-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'relative-y': {
        type: 'label',
        label: 'relative-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'space-length': { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
    },
    contents: [],
  } as const;

  readonly schema = Falloff.schema;

  attributes: FalloffAttributes;
  contents: FalloffContents;

  constructor(opts?: { attributes?: Partial<FalloffAttributes>; contents?: FalloffContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Falloff.schema);
    this.contents = opts?.contents ?? operations.zero(Falloff.schema.contents);
  }
  getColor(): string | null {
    return this.attributes['color'];
  }
  setColor(color: string | null): Falloff {
    this.attributes['color'] = color;
    return this;
  }
  getDashLength(): number | null {
    return this.attributes['dash-length'];
  }
  setDashLength(dashLength: number | null): Falloff {
    this.attributes['dash-length'] = dashLength;
    return this;
  }
  getDefaultX(): number | null {
    return this.attributes['default-x'];
  }
  setDefaultX(defaultX: number | null): Falloff {
    this.attributes['default-x'] = defaultX;
    return this;
  }
  getDefaultY(): number | null {
    return this.attributes['default-y'];
  }
  setDefaultY(defaultY: number | null): Falloff {
    this.attributes['default-y'] = defaultY;
    return this;
  }
  getFontFamily(): string | null {
    return this.attributes['font-family'];
  }
  setFontFamily(fontFamily: string | null): Falloff {
    this.attributes['font-family'] = fontFamily;
    return this;
  }
  getFontSize(): 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null {
    return this.attributes['font-size'];
  }
  setFontSize(
    fontSize: 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null
  ): Falloff {
    this.attributes['font-size'] = fontSize;
    return this;
  }
  getFontStyle(): 'normal' | 'italic' | null {
    return this.attributes['font-style'];
  }
  setFontStyle(fontStyle: 'normal' | 'italic' | null): Falloff {
    this.attributes['font-style'] = fontStyle;
    return this;
  }
  getFontWeight(): 'normal' | 'bold' | null {
    return this.attributes['font-weight'];
  }
  setFontWeight(fontWeight: 'normal' | 'bold' | null): Falloff {
    this.attributes['font-weight'] = fontWeight;
    return this;
  }
  getLineLength(): 'short' | 'medium' | 'long' | null {
    return this.attributes['line-length'];
  }
  setLineLength(lineLength: 'short' | 'medium' | 'long' | null): Falloff {
    this.attributes['line-length'] = lineLength;
    return this;
  }
  getLineShape(): 'straight' | 'curved' | null {
    return this.attributes['line-shape'];
  }
  setLineShape(lineShape: 'straight' | 'curved' | null): Falloff {
    this.attributes['line-shape'] = lineShape;
    return this;
  }
  getLineType(): 'dashed' | 'dotted' | 'solid' | 'wavy' | null {
    return this.attributes['line-type'];
  }
  setLineType(lineType: 'dashed' | 'dotted' | 'solid' | 'wavy' | null): Falloff {
    this.attributes['line-type'] = lineType;
    return this;
  }
  getPlacement(): 'above' | 'below' | null {
    return this.attributes['placement'];
  }
  setPlacement(placement: 'above' | 'below' | null): Falloff {
    this.attributes['placement'] = placement;
    return this;
  }
  getRelativeX(): number | null {
    return this.attributes['relative-x'];
  }
  setRelativeX(relativeX: number | null): Falloff {
    this.attributes['relative-x'] = relativeX;
    return this;
  }
  getRelativeY(): number | null {
    return this.attributes['relative-y'];
  }
  setRelativeY(relativeY: number | null): Falloff {
    this.attributes['relative-y'] = relativeY;
    return this;
  }
  getSpaceLength(): number | null {
    return this.attributes['space-length'];
  }
  setSpaceLength(spaceLength: number | null): Falloff {
    this.attributes['space-length'] = spaceLength;
    return this;
  }
}

export type BreathMarkAttributes = {
  color: string | null;
  'default-x': number | null;
  'default-y': number | null;
  'font-family': string | null;
  'font-size': 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null;
  'font-style': 'normal' | 'italic' | null;
  'font-weight': 'normal' | 'bold' | null;
  placement: 'above' | 'below' | null;
  'relative-x': number | null;
  'relative-y': number | null;
};

export type BreathMarkContents = ['comma' | 'tick' | 'upbow' | 'salzedo' | '' | null];

export class BreathMark implements XMLElement<'breath-mark', BreathMarkAttributes, BreathMarkContents> {
  static readonly schema = {
    name: 'breath-mark',
    attributes: {
      color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
      'default-x': {
        type: 'label',
        label: 'default-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'default-y': {
        type: 'label',
        label: 'default-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
      'font-size': {
        type: 'optional',
        value: {
          type: 'choices',
          choices: [
            { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
            { type: 'float', min: -Infinity, max: Infinity },
          ],
        },
      },
      'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
      'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
      placement: { type: 'optional', value: { type: 'choices', choices: ['above', 'below'] } },
      'relative-x': {
        type: 'label',
        label: 'relative-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'relative-y': {
        type: 'label',
        label: 'relative-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
    },
    contents: [
      {
        type: 'optional',
        value: {
          type: 'label',
          label: 'breath-mark-value',
          value: { type: 'choices', choices: ['comma', 'tick', 'upbow', 'salzedo', ''] },
        },
      },
    ],
  } as const;

  readonly schema = BreathMark.schema;

  attributes: BreathMarkAttributes;
  contents: BreathMarkContents;

  constructor(opts?: { attributes?: Partial<BreathMarkAttributes>; contents?: BreathMarkContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, BreathMark.schema);
    this.contents = opts?.contents ?? operations.zero(BreathMark.schema.contents);
  }
  getColor(): string | null {
    return this.attributes['color'];
  }
  setColor(color: string | null): BreathMark {
    this.attributes['color'] = color;
    return this;
  }
  getDefaultX(): number | null {
    return this.attributes['default-x'];
  }
  setDefaultX(defaultX: number | null): BreathMark {
    this.attributes['default-x'] = defaultX;
    return this;
  }
  getDefaultY(): number | null {
    return this.attributes['default-y'];
  }
  setDefaultY(defaultY: number | null): BreathMark {
    this.attributes['default-y'] = defaultY;
    return this;
  }
  getFontFamily(): string | null {
    return this.attributes['font-family'];
  }
  setFontFamily(fontFamily: string | null): BreathMark {
    this.attributes['font-family'] = fontFamily;
    return this;
  }
  getFontSize(): 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null {
    return this.attributes['font-size'];
  }
  setFontSize(
    fontSize: 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null
  ): BreathMark {
    this.attributes['font-size'] = fontSize;
    return this;
  }
  getFontStyle(): 'normal' | 'italic' | null {
    return this.attributes['font-style'];
  }
  setFontStyle(fontStyle: 'normal' | 'italic' | null): BreathMark {
    this.attributes['font-style'] = fontStyle;
    return this;
  }
  getFontWeight(): 'normal' | 'bold' | null {
    return this.attributes['font-weight'];
  }
  setFontWeight(fontWeight: 'normal' | 'bold' | null): BreathMark {
    this.attributes['font-weight'] = fontWeight;
    return this;
  }
  getPlacement(): 'above' | 'below' | null {
    return this.attributes['placement'];
  }
  setPlacement(placement: 'above' | 'below' | null): BreathMark {
    this.attributes['placement'] = placement;
    return this;
  }
  getRelativeX(): number | null {
    return this.attributes['relative-x'];
  }
  setRelativeX(relativeX: number | null): BreathMark {
    this.attributes['relative-x'] = relativeX;
    return this;
  }
  getRelativeY(): number | null {
    return this.attributes['relative-y'];
  }
  setRelativeY(relativeY: number | null): BreathMark {
    this.attributes['relative-y'] = relativeY;
    return this;
  }
  getBreathMarkValue(): 'comma' | 'tick' | 'upbow' | 'salzedo' | '' | null {
    return this.contents[0];
  }
  setBreathMarkValue(breathMarkValue: 'comma' | 'tick' | 'upbow' | 'salzedo' | '' | null): BreathMark {
    this.contents[0] = breathMarkValue;
    return this;
  }
}

export type CaesuraAttributes = {
  color: string | null;
  'default-x': number | null;
  'default-y': number | null;
  'font-family': string | null;
  'font-size': 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null;
  'font-style': 'normal' | 'italic' | null;
  'font-weight': 'normal' | 'bold' | null;
  placement: 'above' | 'below' | null;
  'relative-x': number | null;
  'relative-y': number | null;
};

export type CaesuraContents = ['normal' | 'thick' | 'short' | 'curved' | 'single' | '' | null];

export class Caesura implements XMLElement<'caesura', CaesuraAttributes, CaesuraContents> {
  static readonly schema = {
    name: 'caesura',
    attributes: {
      color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
      'default-x': {
        type: 'label',
        label: 'default-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'default-y': {
        type: 'label',
        label: 'default-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
      'font-size': {
        type: 'optional',
        value: {
          type: 'choices',
          choices: [
            { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
            { type: 'float', min: -Infinity, max: Infinity },
          ],
        },
      },
      'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
      'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
      placement: { type: 'optional', value: { type: 'choices', choices: ['above', 'below'] } },
      'relative-x': {
        type: 'label',
        label: 'relative-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'relative-y': {
        type: 'label',
        label: 'relative-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
    },
    contents: [
      {
        type: 'optional',
        value: {
          type: 'label',
          label: 'caesura-value',
          value: { type: 'choices', choices: ['normal', 'thick', 'short', 'curved', 'single', ''] },
        },
      },
    ],
  } as const;

  readonly schema = Caesura.schema;

  attributes: CaesuraAttributes;
  contents: CaesuraContents;

  constructor(opts?: { attributes?: Partial<CaesuraAttributes>; contents?: CaesuraContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Caesura.schema);
    this.contents = opts?.contents ?? operations.zero(Caesura.schema.contents);
  }
  getColor(): string | null {
    return this.attributes['color'];
  }
  setColor(color: string | null): Caesura {
    this.attributes['color'] = color;
    return this;
  }
  getDefaultX(): number | null {
    return this.attributes['default-x'];
  }
  setDefaultX(defaultX: number | null): Caesura {
    this.attributes['default-x'] = defaultX;
    return this;
  }
  getDefaultY(): number | null {
    return this.attributes['default-y'];
  }
  setDefaultY(defaultY: number | null): Caesura {
    this.attributes['default-y'] = defaultY;
    return this;
  }
  getFontFamily(): string | null {
    return this.attributes['font-family'];
  }
  setFontFamily(fontFamily: string | null): Caesura {
    this.attributes['font-family'] = fontFamily;
    return this;
  }
  getFontSize(): 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null {
    return this.attributes['font-size'];
  }
  setFontSize(
    fontSize: 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null
  ): Caesura {
    this.attributes['font-size'] = fontSize;
    return this;
  }
  getFontStyle(): 'normal' | 'italic' | null {
    return this.attributes['font-style'];
  }
  setFontStyle(fontStyle: 'normal' | 'italic' | null): Caesura {
    this.attributes['font-style'] = fontStyle;
    return this;
  }
  getFontWeight(): 'normal' | 'bold' | null {
    return this.attributes['font-weight'];
  }
  setFontWeight(fontWeight: 'normal' | 'bold' | null): Caesura {
    this.attributes['font-weight'] = fontWeight;
    return this;
  }
  getPlacement(): 'above' | 'below' | null {
    return this.attributes['placement'];
  }
  setPlacement(placement: 'above' | 'below' | null): Caesura {
    this.attributes['placement'] = placement;
    return this;
  }
  getRelativeX(): number | null {
    return this.attributes['relative-x'];
  }
  setRelativeX(relativeX: number | null): Caesura {
    this.attributes['relative-x'] = relativeX;
    return this;
  }
  getRelativeY(): number | null {
    return this.attributes['relative-y'];
  }
  setRelativeY(relativeY: number | null): Caesura {
    this.attributes['relative-y'] = relativeY;
    return this;
  }
  getCaesuraValue(): 'normal' | 'thick' | 'short' | 'curved' | 'single' | '' | null {
    return this.contents[0];
  }
  setCaesuraValue(caesuraValue: 'normal' | 'thick' | 'short' | 'curved' | 'single' | '' | null): Caesura {
    this.contents[0] = caesuraValue;
    return this;
  }
}

export type StressAttributes = {
  color: string | null;
  'default-x': number | null;
  'default-y': number | null;
  'font-family': string | null;
  'font-size': 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null;
  'font-style': 'normal' | 'italic' | null;
  'font-weight': 'normal' | 'bold' | null;
  placement: 'above' | 'below' | null;
  'relative-x': number | null;
  'relative-y': number | null;
};

export type StressContents = [];

export class Stress implements XMLElement<'stress', StressAttributes, StressContents> {
  static readonly schema = {
    name: 'stress',
    attributes: {
      color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
      'default-x': {
        type: 'label',
        label: 'default-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'default-y': {
        type: 'label',
        label: 'default-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
      'font-size': {
        type: 'optional',
        value: {
          type: 'choices',
          choices: [
            { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
            { type: 'float', min: -Infinity, max: Infinity },
          ],
        },
      },
      'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
      'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
      placement: { type: 'optional', value: { type: 'choices', choices: ['above', 'below'] } },
      'relative-x': {
        type: 'label',
        label: 'relative-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'relative-y': {
        type: 'label',
        label: 'relative-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
    },
    contents: [],
  } as const;

  readonly schema = Stress.schema;

  attributes: StressAttributes;
  contents: StressContents;

  constructor(opts?: { attributes?: Partial<StressAttributes>; contents?: StressContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Stress.schema);
    this.contents = opts?.contents ?? operations.zero(Stress.schema.contents);
  }
  getColor(): string | null {
    return this.attributes['color'];
  }
  setColor(color: string | null): Stress {
    this.attributes['color'] = color;
    return this;
  }
  getDefaultX(): number | null {
    return this.attributes['default-x'];
  }
  setDefaultX(defaultX: number | null): Stress {
    this.attributes['default-x'] = defaultX;
    return this;
  }
  getDefaultY(): number | null {
    return this.attributes['default-y'];
  }
  setDefaultY(defaultY: number | null): Stress {
    this.attributes['default-y'] = defaultY;
    return this;
  }
  getFontFamily(): string | null {
    return this.attributes['font-family'];
  }
  setFontFamily(fontFamily: string | null): Stress {
    this.attributes['font-family'] = fontFamily;
    return this;
  }
  getFontSize(): 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null {
    return this.attributes['font-size'];
  }
  setFontSize(
    fontSize: 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null
  ): Stress {
    this.attributes['font-size'] = fontSize;
    return this;
  }
  getFontStyle(): 'normal' | 'italic' | null {
    return this.attributes['font-style'];
  }
  setFontStyle(fontStyle: 'normal' | 'italic' | null): Stress {
    this.attributes['font-style'] = fontStyle;
    return this;
  }
  getFontWeight(): 'normal' | 'bold' | null {
    return this.attributes['font-weight'];
  }
  setFontWeight(fontWeight: 'normal' | 'bold' | null): Stress {
    this.attributes['font-weight'] = fontWeight;
    return this;
  }
  getPlacement(): 'above' | 'below' | null {
    return this.attributes['placement'];
  }
  setPlacement(placement: 'above' | 'below' | null): Stress {
    this.attributes['placement'] = placement;
    return this;
  }
  getRelativeX(): number | null {
    return this.attributes['relative-x'];
  }
  setRelativeX(relativeX: number | null): Stress {
    this.attributes['relative-x'] = relativeX;
    return this;
  }
  getRelativeY(): number | null {
    return this.attributes['relative-y'];
  }
  setRelativeY(relativeY: number | null): Stress {
    this.attributes['relative-y'] = relativeY;
    return this;
  }
}

export type UnstressAttributes = {
  color: string | null;
  'default-x': number | null;
  'default-y': number | null;
  'font-family': string | null;
  'font-size': 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null;
  'font-style': 'normal' | 'italic' | null;
  'font-weight': 'normal' | 'bold' | null;
  placement: 'above' | 'below' | null;
  'relative-x': number | null;
  'relative-y': number | null;
};

export type UnstressContents = [];

export class Unstress implements XMLElement<'unstress', UnstressAttributes, UnstressContents> {
  static readonly schema = {
    name: 'unstress',
    attributes: {
      color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
      'default-x': {
        type: 'label',
        label: 'default-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'default-y': {
        type: 'label',
        label: 'default-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
      'font-size': {
        type: 'optional',
        value: {
          type: 'choices',
          choices: [
            { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
            { type: 'float', min: -Infinity, max: Infinity },
          ],
        },
      },
      'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
      'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
      placement: { type: 'optional', value: { type: 'choices', choices: ['above', 'below'] } },
      'relative-x': {
        type: 'label',
        label: 'relative-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'relative-y': {
        type: 'label',
        label: 'relative-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
    },
    contents: [],
  } as const;

  readonly schema = Unstress.schema;

  attributes: UnstressAttributes;
  contents: UnstressContents;

  constructor(opts?: { attributes?: Partial<UnstressAttributes>; contents?: UnstressContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Unstress.schema);
    this.contents = opts?.contents ?? operations.zero(Unstress.schema.contents);
  }
  getColor(): string | null {
    return this.attributes['color'];
  }
  setColor(color: string | null): Unstress {
    this.attributes['color'] = color;
    return this;
  }
  getDefaultX(): number | null {
    return this.attributes['default-x'];
  }
  setDefaultX(defaultX: number | null): Unstress {
    this.attributes['default-x'] = defaultX;
    return this;
  }
  getDefaultY(): number | null {
    return this.attributes['default-y'];
  }
  setDefaultY(defaultY: number | null): Unstress {
    this.attributes['default-y'] = defaultY;
    return this;
  }
  getFontFamily(): string | null {
    return this.attributes['font-family'];
  }
  setFontFamily(fontFamily: string | null): Unstress {
    this.attributes['font-family'] = fontFamily;
    return this;
  }
  getFontSize(): 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null {
    return this.attributes['font-size'];
  }
  setFontSize(
    fontSize: 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null
  ): Unstress {
    this.attributes['font-size'] = fontSize;
    return this;
  }
  getFontStyle(): 'normal' | 'italic' | null {
    return this.attributes['font-style'];
  }
  setFontStyle(fontStyle: 'normal' | 'italic' | null): Unstress {
    this.attributes['font-style'] = fontStyle;
    return this;
  }
  getFontWeight(): 'normal' | 'bold' | null {
    return this.attributes['font-weight'];
  }
  setFontWeight(fontWeight: 'normal' | 'bold' | null): Unstress {
    this.attributes['font-weight'] = fontWeight;
    return this;
  }
  getPlacement(): 'above' | 'below' | null {
    return this.attributes['placement'];
  }
  setPlacement(placement: 'above' | 'below' | null): Unstress {
    this.attributes['placement'] = placement;
    return this;
  }
  getRelativeX(): number | null {
    return this.attributes['relative-x'];
  }
  setRelativeX(relativeX: number | null): Unstress {
    this.attributes['relative-x'] = relativeX;
    return this;
  }
  getRelativeY(): number | null {
    return this.attributes['relative-y'];
  }
  setRelativeY(relativeY: number | null): Unstress {
    this.attributes['relative-y'] = relativeY;
    return this;
  }
}

export type SoftAccessAttributes = {
  color: string | null;
  'default-x': number | null;
  'default-y': number | null;
  'font-family': string | null;
  'font-size': 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null;
  'font-style': 'normal' | 'italic' | null;
  'font-weight': 'normal' | 'bold' | null;
  placement: 'above' | 'below' | null;
  'relative-x': number | null;
  'relative-y': number | null;
};

export type SoftAccessContents = [];

export class SoftAccess implements XMLElement<'soft-access', SoftAccessAttributes, SoftAccessContents> {
  static readonly schema = {
    name: 'soft-access',
    attributes: {
      color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
      'default-x': {
        type: 'label',
        label: 'default-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'default-y': {
        type: 'label',
        label: 'default-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
      'font-size': {
        type: 'optional',
        value: {
          type: 'choices',
          choices: [
            { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
            { type: 'float', min: -Infinity, max: Infinity },
          ],
        },
      },
      'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
      'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
      placement: { type: 'optional', value: { type: 'choices', choices: ['above', 'below'] } },
      'relative-x': {
        type: 'label',
        label: 'relative-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'relative-y': {
        type: 'label',
        label: 'relative-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
    },
    contents: [],
  } as const;

  readonly schema = SoftAccess.schema;

  attributes: SoftAccessAttributes;
  contents: SoftAccessContents;

  constructor(opts?: { attributes?: Partial<SoftAccessAttributes>; contents?: SoftAccessContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, SoftAccess.schema);
    this.contents = opts?.contents ?? operations.zero(SoftAccess.schema.contents);
  }
  getColor(): string | null {
    return this.attributes['color'];
  }
  setColor(color: string | null): SoftAccess {
    this.attributes['color'] = color;
    return this;
  }
  getDefaultX(): number | null {
    return this.attributes['default-x'];
  }
  setDefaultX(defaultX: number | null): SoftAccess {
    this.attributes['default-x'] = defaultX;
    return this;
  }
  getDefaultY(): number | null {
    return this.attributes['default-y'];
  }
  setDefaultY(defaultY: number | null): SoftAccess {
    this.attributes['default-y'] = defaultY;
    return this;
  }
  getFontFamily(): string | null {
    return this.attributes['font-family'];
  }
  setFontFamily(fontFamily: string | null): SoftAccess {
    this.attributes['font-family'] = fontFamily;
    return this;
  }
  getFontSize(): 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null {
    return this.attributes['font-size'];
  }
  setFontSize(
    fontSize: 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null
  ): SoftAccess {
    this.attributes['font-size'] = fontSize;
    return this;
  }
  getFontStyle(): 'normal' | 'italic' | null {
    return this.attributes['font-style'];
  }
  setFontStyle(fontStyle: 'normal' | 'italic' | null): SoftAccess {
    this.attributes['font-style'] = fontStyle;
    return this;
  }
  getFontWeight(): 'normal' | 'bold' | null {
    return this.attributes['font-weight'];
  }
  setFontWeight(fontWeight: 'normal' | 'bold' | null): SoftAccess {
    this.attributes['font-weight'] = fontWeight;
    return this;
  }
  getPlacement(): 'above' | 'below' | null {
    return this.attributes['placement'];
  }
  setPlacement(placement: 'above' | 'below' | null): SoftAccess {
    this.attributes['placement'] = placement;
    return this;
  }
  getRelativeX(): number | null {
    return this.attributes['relative-x'];
  }
  setRelativeX(relativeX: number | null): SoftAccess {
    this.attributes['relative-x'] = relativeX;
    return this;
  }
  getRelativeY(): number | null {
    return this.attributes['relative-y'];
  }
  setRelativeY(relativeY: number | null): SoftAccess {
    this.attributes['relative-y'] = relativeY;
    return this;
  }
}

export type OtherArticulationAttributes = {
  color: string | null;
  'default-x': number | null;
  'default-y': number | null;
  'font-family': string | null;
  'font-size': 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null;
  'font-style': 'normal' | 'italic' | null;
  'font-weight': 'normal' | 'bold' | null;
  placement: 'above' | 'below' | null;
  'relative-x': number | null;
  'relative-y': number | null;
  smufl: string | null;
};

export type OtherArticulationContents = [];

export class OtherArticulation
  implements XMLElement<'other-articulation', OtherArticulationAttributes, OtherArticulationContents>
{
  static readonly schema = {
    name: 'other-articulation',
    attributes: {
      color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
      'default-x': {
        type: 'label',
        label: 'default-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'default-y': {
        type: 'label',
        label: 'default-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
      'font-size': {
        type: 'optional',
        value: {
          type: 'choices',
          choices: [
            { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
            { type: 'float', min: -Infinity, max: Infinity },
          ],
        },
      },
      'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
      'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
      placement: { type: 'optional', value: { type: 'choices', choices: ['above', 'below'] } },
      'relative-x': {
        type: 'label',
        label: 'relative-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'relative-y': {
        type: 'label',
        label: 'relative-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      smufl: { type: 'optional', value: { type: 'string' } },
    },
    contents: [],
  } as const;

  readonly schema = OtherArticulation.schema;

  attributes: OtherArticulationAttributes;
  contents: OtherArticulationContents;

  constructor(opts?: { attributes?: Partial<OtherArticulationAttributes>; contents?: OtherArticulationContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, OtherArticulation.schema);
    this.contents = opts?.contents ?? operations.zero(OtherArticulation.schema.contents);
  }
  getColor(): string | null {
    return this.attributes['color'];
  }
  setColor(color: string | null): OtherArticulation {
    this.attributes['color'] = color;
    return this;
  }
  getDefaultX(): number | null {
    return this.attributes['default-x'];
  }
  setDefaultX(defaultX: number | null): OtherArticulation {
    this.attributes['default-x'] = defaultX;
    return this;
  }
  getDefaultY(): number | null {
    return this.attributes['default-y'];
  }
  setDefaultY(defaultY: number | null): OtherArticulation {
    this.attributes['default-y'] = defaultY;
    return this;
  }
  getFontFamily(): string | null {
    return this.attributes['font-family'];
  }
  setFontFamily(fontFamily: string | null): OtherArticulation {
    this.attributes['font-family'] = fontFamily;
    return this;
  }
  getFontSize(): 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null {
    return this.attributes['font-size'];
  }
  setFontSize(
    fontSize: 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null
  ): OtherArticulation {
    this.attributes['font-size'] = fontSize;
    return this;
  }
  getFontStyle(): 'normal' | 'italic' | null {
    return this.attributes['font-style'];
  }
  setFontStyle(fontStyle: 'normal' | 'italic' | null): OtherArticulation {
    this.attributes['font-style'] = fontStyle;
    return this;
  }
  getFontWeight(): 'normal' | 'bold' | null {
    return this.attributes['font-weight'];
  }
  setFontWeight(fontWeight: 'normal' | 'bold' | null): OtherArticulation {
    this.attributes['font-weight'] = fontWeight;
    return this;
  }
  getPlacement(): 'above' | 'below' | null {
    return this.attributes['placement'];
  }
  setPlacement(placement: 'above' | 'below' | null): OtherArticulation {
    this.attributes['placement'] = placement;
    return this;
  }
  getRelativeX(): number | null {
    return this.attributes['relative-x'];
  }
  setRelativeX(relativeX: number | null): OtherArticulation {
    this.attributes['relative-x'] = relativeX;
    return this;
  }
  getRelativeY(): number | null {
    return this.attributes['relative-y'];
  }
  setRelativeY(relativeY: number | null): OtherArticulation {
    this.attributes['relative-y'] = relativeY;
    return this;
  }
  getSmufl(): string | null {
    return this.attributes['smufl'];
  }
  setSmufl(smufl: string | null): OtherArticulation {
    this.attributes['smufl'] = smufl;
    return this;
  }
}

export type ArticulationsAttributes = { id: string | null };

export type ArticulationsContents = [
  Array<
    | Accent
    | StrongAccent
    | Staccato
    | Tenuto
    | DetachedLegato
    | Staccatissimo
    | Spiccato
    | Scoop
    | Plop
    | Doit
    | Falloff
    | BreathMark
    | Caesura
    | Stress
    | Unstress
    | SoftAccess
    | OtherArticulation
  >
];

export class Articulations implements XMLElement<'articulations', ArticulationsAttributes, ArticulationsContents> {
  static readonly schema = {
    name: 'articulations',
    attributes: { id: { type: 'optional', value: { type: 'regex', pattern: /[A-Za-z_][A-Za-z0-9.-_]*/, zero: '_' } } },
    contents: [
      {
        type: 'label',
        label: 'articulations',
        value: {
          type: 'zeroOrMore',
          value: {
            type: 'choices',
            choices: [
              Accent,
              StrongAccent,
              Staccato,
              Tenuto,
              DetachedLegato,
              Staccatissimo,
              Spiccato,
              Scoop,
              Plop,
              Doit,
              Falloff,
              BreathMark,
              Caesura,
              Stress,
              Unstress,
              SoftAccess,
              OtherArticulation,
            ],
          },
        },
      },
    ],
  } as const;

  readonly schema = Articulations.schema;

  attributes: ArticulationsAttributes;
  contents: ArticulationsContents;

  constructor(opts?: { attributes?: Partial<ArticulationsAttributes>; contents?: ArticulationsContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Articulations.schema);
    this.contents = opts?.contents ?? operations.zero(Articulations.schema.contents);
  }
  getId(): string | null {
    return this.attributes['id'];
  }
  setId(id: string | null): Articulations {
    this.attributes['id'] = id;
    return this;
  }
  getArticulations(): Array<
    | Accent
    | StrongAccent
    | Staccato
    | Tenuto
    | DetachedLegato
    | Staccatissimo
    | Spiccato
    | Scoop
    | Plop
    | Doit
    | Falloff
    | BreathMark
    | Caesura
    | Stress
    | Unstress
    | SoftAccess
    | OtherArticulation
  > {
    return this.contents[0];
  }
  setArticulations(
    articulations: Array<
      | Accent
      | StrongAccent
      | Staccato
      | Tenuto
      | DetachedLegato
      | Staccatissimo
      | Spiccato
      | Scoop
      | Plop
      | Doit
      | Falloff
      | BreathMark
      | Caesura
      | Stress
      | Unstress
      | SoftAccess
      | OtherArticulation
    >
  ): Articulations {
    this.contents[0] = articulations;
    return this;
  }
}

export type PAttributes = Record<string, unknown>;

export type PContents = [];

export class P implements XMLElement<'p', PAttributes, PContents> {
  static readonly schema = { name: 'p', attributes: {}, contents: [] } as const;

  readonly schema = P.schema;

  attributes: PAttributes;
  contents: PContents;

  constructor(opts?: { attributes?: Partial<PAttributes>; contents?: PContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, P.schema);
    this.contents = opts?.contents ?? operations.zero(P.schema.contents);
  }
}

export type PpAttributes = Record<string, unknown>;

export type PpContents = [];

export class Pp implements XMLElement<'pp', PpAttributes, PpContents> {
  static readonly schema = { name: 'pp', attributes: {}, contents: [] } as const;

  readonly schema = Pp.schema;

  attributes: PpAttributes;
  contents: PpContents;

  constructor(opts?: { attributes?: Partial<PpAttributes>; contents?: PpContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Pp.schema);
    this.contents = opts?.contents ?? operations.zero(Pp.schema.contents);
  }
}

export type PppAttributes = Record<string, unknown>;

export type PppContents = [];

export class Ppp implements XMLElement<'ppp', PppAttributes, PppContents> {
  static readonly schema = { name: 'ppp', attributes: {}, contents: [] } as const;

  readonly schema = Ppp.schema;

  attributes: PppAttributes;
  contents: PppContents;

  constructor(opts?: { attributes?: Partial<PppAttributes>; contents?: PppContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Ppp.schema);
    this.contents = opts?.contents ?? operations.zero(Ppp.schema.contents);
  }
}

export type PpppAttributes = Record<string, unknown>;

export type PpppContents = [];

export class Pppp implements XMLElement<'pppp', PpppAttributes, PpppContents> {
  static readonly schema = { name: 'pppp', attributes: {}, contents: [] } as const;

  readonly schema = Pppp.schema;

  attributes: PpppAttributes;
  contents: PpppContents;

  constructor(opts?: { attributes?: Partial<PpppAttributes>; contents?: PpppContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Pppp.schema);
    this.contents = opts?.contents ?? operations.zero(Pppp.schema.contents);
  }
}

export type PppppAttributes = Record<string, unknown>;

export type PppppContents = [];

export class Ppppp implements XMLElement<'ppppp', PppppAttributes, PppppContents> {
  static readonly schema = { name: 'ppppp', attributes: {}, contents: [] } as const;

  readonly schema = Ppppp.schema;

  attributes: PppppAttributes;
  contents: PppppContents;

  constructor(opts?: { attributes?: Partial<PppppAttributes>; contents?: PppppContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Ppppp.schema);
    this.contents = opts?.contents ?? operations.zero(Ppppp.schema.contents);
  }
}

export type PpppppAttributes = Record<string, unknown>;

export type PpppppContents = [];

export class Pppppp implements XMLElement<'pppppp', PpppppAttributes, PpppppContents> {
  static readonly schema = { name: 'pppppp', attributes: {}, contents: [] } as const;

  readonly schema = Pppppp.schema;

  attributes: PpppppAttributes;
  contents: PpppppContents;

  constructor(opts?: { attributes?: Partial<PpppppAttributes>; contents?: PpppppContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Pppppp.schema);
    this.contents = opts?.contents ?? operations.zero(Pppppp.schema.contents);
  }
}

export type FAttributes = Record<string, unknown>;

export type FContents = [];

export class F implements XMLElement<'f', FAttributes, FContents> {
  static readonly schema = { name: 'f', attributes: {}, contents: [] } as const;

  readonly schema = F.schema;

  attributes: FAttributes;
  contents: FContents;

  constructor(opts?: { attributes?: Partial<FAttributes>; contents?: FContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, F.schema);
    this.contents = opts?.contents ?? operations.zero(F.schema.contents);
  }
}

export type FfAttributes = Record<string, unknown>;

export type FfContents = [];

export class Ff implements XMLElement<'ff', FfAttributes, FfContents> {
  static readonly schema = { name: 'ff', attributes: {}, contents: [] } as const;

  readonly schema = Ff.schema;

  attributes: FfAttributes;
  contents: FfContents;

  constructor(opts?: { attributes?: Partial<FfAttributes>; contents?: FfContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Ff.schema);
    this.contents = opts?.contents ?? operations.zero(Ff.schema.contents);
  }
}

export type FffAttributes = Record<string, unknown>;

export type FffContents = [];

export class Fff implements XMLElement<'fff', FffAttributes, FffContents> {
  static readonly schema = { name: 'fff', attributes: {}, contents: [] } as const;

  readonly schema = Fff.schema;

  attributes: FffAttributes;
  contents: FffContents;

  constructor(opts?: { attributes?: Partial<FffAttributes>; contents?: FffContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Fff.schema);
    this.contents = opts?.contents ?? operations.zero(Fff.schema.contents);
  }
}

export type FfffAttributes = Record<string, unknown>;

export type FfffContents = [];

export class Ffff implements XMLElement<'ffff', FfffAttributes, FfffContents> {
  static readonly schema = { name: 'ffff', attributes: {}, contents: [] } as const;

  readonly schema = Ffff.schema;

  attributes: FfffAttributes;
  contents: FfffContents;

  constructor(opts?: { attributes?: Partial<FfffAttributes>; contents?: FfffContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Ffff.schema);
    this.contents = opts?.contents ?? operations.zero(Ffff.schema.contents);
  }
}

export type FffffAttributes = Record<string, unknown>;

export type FffffContents = [];

export class Fffff implements XMLElement<'fffff', FffffAttributes, FffffContents> {
  static readonly schema = { name: 'fffff', attributes: {}, contents: [] } as const;

  readonly schema = Fffff.schema;

  attributes: FffffAttributes;
  contents: FffffContents;

  constructor(opts?: { attributes?: Partial<FffffAttributes>; contents?: FffffContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Fffff.schema);
    this.contents = opts?.contents ?? operations.zero(Fffff.schema.contents);
  }
}

export type FfffffAttributes = Record<string, unknown>;

export type FfffffContents = [];

export class Ffffff implements XMLElement<'ffffff', FfffffAttributes, FfffffContents> {
  static readonly schema = { name: 'ffffff', attributes: {}, contents: [] } as const;

  readonly schema = Ffffff.schema;

  attributes: FfffffAttributes;
  contents: FfffffContents;

  constructor(opts?: { attributes?: Partial<FfffffAttributes>; contents?: FfffffContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Ffffff.schema);
    this.contents = opts?.contents ?? operations.zero(Ffffff.schema.contents);
  }
}

export type MpAttributes = Record<string, unknown>;

export type MpContents = [];

export class Mp implements XMLElement<'mp', MpAttributes, MpContents> {
  static readonly schema = { name: 'mp', attributes: {}, contents: [] } as const;

  readonly schema = Mp.schema;

  attributes: MpAttributes;
  contents: MpContents;

  constructor(opts?: { attributes?: Partial<MpAttributes>; contents?: MpContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Mp.schema);
    this.contents = opts?.contents ?? operations.zero(Mp.schema.contents);
  }
}

export type MfAttributes = Record<string, unknown>;

export type MfContents = [];

export class Mf implements XMLElement<'mf', MfAttributes, MfContents> {
  static readonly schema = { name: 'mf', attributes: {}, contents: [] } as const;

  readonly schema = Mf.schema;

  attributes: MfAttributes;
  contents: MfContents;

  constructor(opts?: { attributes?: Partial<MfAttributes>; contents?: MfContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Mf.schema);
    this.contents = opts?.contents ?? operations.zero(Mf.schema.contents);
  }
}

export type SfAttributes = Record<string, unknown>;

export type SfContents = [];

export class Sf implements XMLElement<'sf', SfAttributes, SfContents> {
  static readonly schema = { name: 'sf', attributes: {}, contents: [] } as const;

  readonly schema = Sf.schema;

  attributes: SfAttributes;
  contents: SfContents;

  constructor(opts?: { attributes?: Partial<SfAttributes>; contents?: SfContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Sf.schema);
    this.contents = opts?.contents ?? operations.zero(Sf.schema.contents);
  }
}

export type SfpAttributes = Record<string, unknown>;

export type SfpContents = [];

export class Sfp implements XMLElement<'sfp', SfpAttributes, SfpContents> {
  static readonly schema = { name: 'sfp', attributes: {}, contents: [] } as const;

  readonly schema = Sfp.schema;

  attributes: SfpAttributes;
  contents: SfpContents;

  constructor(opts?: { attributes?: Partial<SfpAttributes>; contents?: SfpContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Sfp.schema);
    this.contents = opts?.contents ?? operations.zero(Sfp.schema.contents);
  }
}

export type SfppAttributes = Record<string, unknown>;

export type SfppContents = [];

export class Sfpp implements XMLElement<'sfpp', SfppAttributes, SfppContents> {
  static readonly schema = { name: 'sfpp', attributes: {}, contents: [] } as const;

  readonly schema = Sfpp.schema;

  attributes: SfppAttributes;
  contents: SfppContents;

  constructor(opts?: { attributes?: Partial<SfppAttributes>; contents?: SfppContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Sfpp.schema);
    this.contents = opts?.contents ?? operations.zero(Sfpp.schema.contents);
  }
}

export type FpAttributes = Record<string, unknown>;

export type FpContents = [];

export class Fp implements XMLElement<'fp', FpAttributes, FpContents> {
  static readonly schema = { name: 'fp', attributes: {}, contents: [] } as const;

  readonly schema = Fp.schema;

  attributes: FpAttributes;
  contents: FpContents;

  constructor(opts?: { attributes?: Partial<FpAttributes>; contents?: FpContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Fp.schema);
    this.contents = opts?.contents ?? operations.zero(Fp.schema.contents);
  }
}

export type RfAttributes = Record<string, unknown>;

export type RfContents = [];

export class Rf implements XMLElement<'rf', RfAttributes, RfContents> {
  static readonly schema = { name: 'rf', attributes: {}, contents: [] } as const;

  readonly schema = Rf.schema;

  attributes: RfAttributes;
  contents: RfContents;

  constructor(opts?: { attributes?: Partial<RfAttributes>; contents?: RfContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Rf.schema);
    this.contents = opts?.contents ?? operations.zero(Rf.schema.contents);
  }
}

export type RfzAttributes = Record<string, unknown>;

export type RfzContents = [];

export class Rfz implements XMLElement<'rfz', RfzAttributes, RfzContents> {
  static readonly schema = { name: 'rfz', attributes: {}, contents: [] } as const;

  readonly schema = Rfz.schema;

  attributes: RfzAttributes;
  contents: RfzContents;

  constructor(opts?: { attributes?: Partial<RfzAttributes>; contents?: RfzContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Rfz.schema);
    this.contents = opts?.contents ?? operations.zero(Rfz.schema.contents);
  }
}

export type SfzAttributes = Record<string, unknown>;

export type SfzContents = [];

export class Sfz implements XMLElement<'sfz', SfzAttributes, SfzContents> {
  static readonly schema = { name: 'sfz', attributes: {}, contents: [] } as const;

  readonly schema = Sfz.schema;

  attributes: SfzAttributes;
  contents: SfzContents;

  constructor(opts?: { attributes?: Partial<SfzAttributes>; contents?: SfzContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Sfz.schema);
    this.contents = opts?.contents ?? operations.zero(Sfz.schema.contents);
  }
}

export type SffzAttributes = Record<string, unknown>;

export type SffzContents = [];

export class Sffz implements XMLElement<'sffz', SffzAttributes, SffzContents> {
  static readonly schema = { name: 'sffz', attributes: {}, contents: [] } as const;

  readonly schema = Sffz.schema;

  attributes: SffzAttributes;
  contents: SffzContents;

  constructor(opts?: { attributes?: Partial<SffzAttributes>; contents?: SffzContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Sffz.schema);
    this.contents = opts?.contents ?? operations.zero(Sffz.schema.contents);
  }
}

export type FzAttributes = Record<string, unknown>;

export type FzContents = [];

export class Fz implements XMLElement<'fz', FzAttributes, FzContents> {
  static readonly schema = { name: 'fz', attributes: {}, contents: [] } as const;

  readonly schema = Fz.schema;

  attributes: FzAttributes;
  contents: FzContents;

  constructor(opts?: { attributes?: Partial<FzAttributes>; contents?: FzContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Fz.schema);
    this.contents = opts?.contents ?? operations.zero(Fz.schema.contents);
  }
}

export type NAttributes = Record<string, unknown>;

export type NContents = [];

export class N implements XMLElement<'n', NAttributes, NContents> {
  static readonly schema = { name: 'n', attributes: {}, contents: [] } as const;

  readonly schema = N.schema;

  attributes: NAttributes;
  contents: NContents;

  constructor(opts?: { attributes?: Partial<NAttributes>; contents?: NContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, N.schema);
    this.contents = opts?.contents ?? operations.zero(N.schema.contents);
  }
}

export type PfAttributes = Record<string, unknown>;

export type PfContents = [];

export class Pf implements XMLElement<'pf', PfAttributes, PfContents> {
  static readonly schema = { name: 'pf', attributes: {}, contents: [] } as const;

  readonly schema = Pf.schema;

  attributes: PfAttributes;
  contents: PfContents;

  constructor(opts?: { attributes?: Partial<PfAttributes>; contents?: PfContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Pf.schema);
    this.contents = opts?.contents ?? operations.zero(Pf.schema.contents);
  }
}

export type SfzpAttributes = Record<string, unknown>;

export type SfzpContents = [];

export class Sfzp implements XMLElement<'sfzp', SfzpAttributes, SfzpContents> {
  static readonly schema = { name: 'sfzp', attributes: {}, contents: [] } as const;

  readonly schema = Sfzp.schema;

  attributes: SfzpAttributes;
  contents: SfzpContents;

  constructor(opts?: { attributes?: Partial<SfzpAttributes>; contents?: SfzpContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Sfzp.schema);
    this.contents = opts?.contents ?? operations.zero(Sfzp.schema.contents);
  }
}

export type OtherDynamicsAttributes = { smufl: string | null };

export type OtherDynamicsContents = [string];

export class OtherDynamics implements XMLElement<'other-dynamics', OtherDynamicsAttributes, OtherDynamicsContents> {
  static readonly schema = {
    name: 'other-dynamics',
    attributes: { smufl: { type: 'optional', value: { type: 'string' } } },
    contents: [{ type: 'required', value: { type: 'string' } }],
  } as const;

  readonly schema = OtherDynamics.schema;

  attributes: OtherDynamicsAttributes;
  contents: OtherDynamicsContents;

  constructor(opts?: { attributes?: Partial<OtherDynamicsAttributes>; contents?: OtherDynamicsContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, OtherDynamics.schema);
    this.contents = opts?.contents ?? operations.zero(OtherDynamics.schema.contents);
  }
  getSmufl(): string | null {
    return this.attributes['smufl'];
  }
  setSmufl(smufl: string | null): OtherDynamics {
    this.attributes['smufl'] = smufl;
    return this;
  }
  getText(): string {
    return this.contents[0];
  }
  setText(text: string): OtherDynamics {
    this.contents[0] = text;
    return this;
  }
}

export type DynamicsAttributes = {
  color: string | null;
  'default-x': number | null;
  'default-y': number | null;
  enclosure:
    | 'none'
    | 'rectangle'
    | 'square'
    | 'oval'
    | 'circle'
    | 'bracket'
    | 'inverted-bracket'
    | 'triangle'
    | 'diamond'
    | 'pentagon'
    | 'hexagon'
    | 'heptagon'
    | 'octagon'
    | 'nonagon'
    | 'decagon'
    | null;
  'font-family': string | null;
  'font-size': 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null;
  'font-style': 'normal' | 'italic' | null;
  'font-weight': 'normal' | 'bold' | null;
  halign: 'left' | 'center' | 'right' | null;
  id: string | null;
  overline: number | null;
  placement: 'above' | 'below' | null;
  'line-through': number | null;
  'relative-x': number | null;
  'relative-y': number | null;
  underline: number | null;
  valign: 'top' | 'middle' | 'bottom' | 'baseline' | null;
};

export type DynamicsContents = [
  Array<
    | P
    | Pp
    | Ppp
    | Pppp
    | Ppppp
    | Pppppp
    | F
    | Ff
    | Fff
    | Ffff
    | Fffff
    | Fffff
    | Ffffff
    | Mp
    | Mf
    | Sf
    | Sfp
    | Sfpp
    | Fp
    | Rf
    | Rfz
    | Sfz
    | Sffz
    | Fz
    | N
    | Pf
    | Sfzp
    | OtherDynamics
  >
];

export class Dynamics implements XMLElement<'dynamics', DynamicsAttributes, DynamicsContents> {
  static readonly schema = {
    name: 'dynamics',
    attributes: {
      color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
      'default-x': {
        type: 'label',
        label: 'default-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'default-y': {
        type: 'label',
        label: 'default-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      enclosure: {
        type: 'optional',
        value: {
          type: 'choices',
          choices: [
            'none',
            'rectangle',
            'square',
            'oval',
            'circle',
            'bracket',
            'inverted-bracket',
            'triangle',
            'diamond',
            'pentagon',
            'hexagon',
            'heptagon',
            'octagon',
            'nonagon',
            'decagon',
          ],
        },
      },
      'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
      'font-size': {
        type: 'optional',
        value: {
          type: 'choices',
          choices: [
            { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
            { type: 'float', min: -Infinity, max: Infinity },
          ],
        },
      },
      'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
      'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
      halign: { type: 'optional', value: { type: 'choices', choices: ['left', 'center', 'right'] } },
      id: { type: 'optional', value: { type: 'regex', pattern: /[A-Za-z_][A-Za-z0-9.-_]*/, zero: '_' } },
      overline: { type: 'optional', value: { type: 'int', min: 0, max: 3 } },
      placement: { type: 'optional', value: { type: 'choices', choices: ['above', 'below'] } },
      'line-through': { type: 'optional', value: { type: 'int', min: 0, max: 3 } },
      'relative-x': {
        type: 'label',
        label: 'relative-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'relative-y': {
        type: 'label',
        label: 'relative-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      underline: { type: 'optional', value: { type: 'int', min: 0, max: 3 } },
      valign: { type: 'optional', value: { type: 'choices', choices: ['top', 'middle', 'bottom', 'baseline'] } },
    },
    contents: [
      {
        type: 'label',
        label: 'dynamics-value',
        value: {
          type: 'zeroOrMore',
          value: {
            type: 'choices',
            choices: [
              P,
              Pp,
              Ppp,
              Pppp,
              Ppppp,
              Pppppp,
              F,
              Ff,
              Fff,
              Ffff,
              Fffff,
              Fffff,
              Ffffff,
              Mp,
              Mf,
              Sf,
              Sfp,
              Sfpp,
              Fp,
              Rf,
              Rfz,
              Sfz,
              Sffz,
              Fz,
              N,
              Pf,
              Sfzp,
              OtherDynamics,
            ],
          },
        },
      },
    ],
  } as const;

  readonly schema = Dynamics.schema;

  attributes: DynamicsAttributes;
  contents: DynamicsContents;

  constructor(opts?: { attributes?: Partial<DynamicsAttributes>; contents?: DynamicsContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Dynamics.schema);
    this.contents = opts?.contents ?? operations.zero(Dynamics.schema.contents);
  }
  getColor(): string | null {
    return this.attributes['color'];
  }
  setColor(color: string | null): Dynamics {
    this.attributes['color'] = color;
    return this;
  }
  getDefaultX(): number | null {
    return this.attributes['default-x'];
  }
  setDefaultX(defaultX: number | null): Dynamics {
    this.attributes['default-x'] = defaultX;
    return this;
  }
  getDefaultY(): number | null {
    return this.attributes['default-y'];
  }
  setDefaultY(defaultY: number | null): Dynamics {
    this.attributes['default-y'] = defaultY;
    return this;
  }
  getEnclosure():
    | 'none'
    | 'rectangle'
    | 'square'
    | 'oval'
    | 'circle'
    | 'bracket'
    | 'inverted-bracket'
    | 'triangle'
    | 'diamond'
    | 'pentagon'
    | 'hexagon'
    | 'heptagon'
    | 'octagon'
    | 'nonagon'
    | 'decagon'
    | null {
    return this.attributes['enclosure'];
  }
  setEnclosure(
    enclosure:
      | 'none'
      | 'rectangle'
      | 'square'
      | 'oval'
      | 'circle'
      | 'bracket'
      | 'inverted-bracket'
      | 'triangle'
      | 'diamond'
      | 'pentagon'
      | 'hexagon'
      | 'heptagon'
      | 'octagon'
      | 'nonagon'
      | 'decagon'
      | null
  ): Dynamics {
    this.attributes['enclosure'] = enclosure;
    return this;
  }
  getFontFamily(): string | null {
    return this.attributes['font-family'];
  }
  setFontFamily(fontFamily: string | null): Dynamics {
    this.attributes['font-family'] = fontFamily;
    return this;
  }
  getFontSize(): 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null {
    return this.attributes['font-size'];
  }
  setFontSize(
    fontSize: 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null
  ): Dynamics {
    this.attributes['font-size'] = fontSize;
    return this;
  }
  getFontStyle(): 'normal' | 'italic' | null {
    return this.attributes['font-style'];
  }
  setFontStyle(fontStyle: 'normal' | 'italic' | null): Dynamics {
    this.attributes['font-style'] = fontStyle;
    return this;
  }
  getFontWeight(): 'normal' | 'bold' | null {
    return this.attributes['font-weight'];
  }
  setFontWeight(fontWeight: 'normal' | 'bold' | null): Dynamics {
    this.attributes['font-weight'] = fontWeight;
    return this;
  }
  getHalign(): 'left' | 'center' | 'right' | null {
    return this.attributes['halign'];
  }
  setHalign(halign: 'left' | 'center' | 'right' | null): Dynamics {
    this.attributes['halign'] = halign;
    return this;
  }
  getId(): string | null {
    return this.attributes['id'];
  }
  setId(id: string | null): Dynamics {
    this.attributes['id'] = id;
    return this;
  }
  getOverline(): number | null {
    return this.attributes['overline'];
  }
  setOverline(overline: number | null): Dynamics {
    this.attributes['overline'] = overline;
    return this;
  }
  getPlacement(): 'above' | 'below' | null {
    return this.attributes['placement'];
  }
  setPlacement(placement: 'above' | 'below' | null): Dynamics {
    this.attributes['placement'] = placement;
    return this;
  }
  getLineThrough(): number | null {
    return this.attributes['line-through'];
  }
  setLineThrough(lineThrough: number | null): Dynamics {
    this.attributes['line-through'] = lineThrough;
    return this;
  }
  getRelativeX(): number | null {
    return this.attributes['relative-x'];
  }
  setRelativeX(relativeX: number | null): Dynamics {
    this.attributes['relative-x'] = relativeX;
    return this;
  }
  getRelativeY(): number | null {
    return this.attributes['relative-y'];
  }
  setRelativeY(relativeY: number | null): Dynamics {
    this.attributes['relative-y'] = relativeY;
    return this;
  }
  getUnderline(): number | null {
    return this.attributes['underline'];
  }
  setUnderline(underline: number | null): Dynamics {
    this.attributes['underline'] = underline;
    return this;
  }
  getValign(): 'top' | 'middle' | 'bottom' | 'baseline' | null {
    return this.attributes['valign'];
  }
  setValign(valign: 'top' | 'middle' | 'bottom' | 'baseline' | null): Dynamics {
    this.attributes['valign'] = valign;
    return this;
  }
  getDynamicsValue(): Array<
    | P
    | Pp
    | Ppp
    | Pppp
    | Ppppp
    | Pppppp
    | F
    | Ff
    | Fff
    | Ffff
    | Fffff
    | Fffff
    | Ffffff
    | Mp
    | Mf
    | Sf
    | Sfp
    | Sfpp
    | Fp
    | Rf
    | Rfz
    | Sfz
    | Sffz
    | Fz
    | N
    | Pf
    | Sfzp
    | OtherDynamics
  > {
    return this.contents[0];
  }
  setDynamicsValue(
    dynamicsValue: Array<
      | P
      | Pp
      | Ppp
      | Pppp
      | Ppppp
      | Pppppp
      | F
      | Ff
      | Fff
      | Ffff
      | Fffff
      | Fffff
      | Ffffff
      | Mp
      | Mf
      | Sf
      | Sfp
      | Sfpp
      | Fp
      | Rf
      | Rfz
      | Sfz
      | Sffz
      | Fz
      | N
      | Pf
      | Sfzp
      | OtherDynamics
    >
  ): Dynamics {
    this.contents[0] = dynamicsValue;
    return this;
  }
}

export type FermataAttributes = {
  color: string | null;
  'default-x': number | null;
  'default-y': number | null;
  'font-family': string | null;
  'font-size': 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null;
  'font-style': 'normal' | 'italic' | null;
  'font-weight': 'normal' | 'bold' | null;
  id: string | null;
  'relative-x': number | null;
  'relative-y': number | null;
  type: 'upright' | 'inverted' | null;
};

export type FermataContents = [
  '' | 'normal' | 'angled' | 'square' | 'double-angled' | 'double-square' | 'double-dot' | 'half-curve' | 'curlew'
];

export class Fermata implements XMLElement<'fermata', FermataAttributes, FermataContents> {
  static readonly schema = {
    name: 'fermata',
    attributes: {
      color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
      'default-x': {
        type: 'label',
        label: 'default-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'default-y': {
        type: 'label',
        label: 'default-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
      'font-size': {
        type: 'optional',
        value: {
          type: 'choices',
          choices: [
            { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
            { type: 'float', min: -Infinity, max: Infinity },
          ],
        },
      },
      'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
      'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
      id: { type: 'optional', value: { type: 'regex', pattern: /[A-Za-z_][A-Za-z0-9.-_]*/, zero: '_' } },
      'relative-x': {
        type: 'label',
        label: 'relative-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'relative-y': {
        type: 'label',
        label: 'relative-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      type: { type: 'optional', value: { type: 'choices', choices: ['upright', 'inverted'] } },
    },
    contents: [
      {
        type: 'required',
        value: {
          type: 'label',
          label: 'fermata-shape',
          value: {
            type: 'choices',
            choices: [
              '',
              'normal',
              'angled',
              'square',
              'double-angled',
              'double-square',
              'double-dot',
              'half-curve',
              'curlew',
            ],
          },
        },
      },
    ],
  } as const;

  readonly schema = Fermata.schema;

  attributes: FermataAttributes;
  contents: FermataContents;

  constructor(opts?: { attributes?: Partial<FermataAttributes>; contents?: FermataContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Fermata.schema);
    this.contents = opts?.contents ?? operations.zero(Fermata.schema.contents);
  }
  getColor(): string | null {
    return this.attributes['color'];
  }
  setColor(color: string | null): Fermata {
    this.attributes['color'] = color;
    return this;
  }
  getDefaultX(): number | null {
    return this.attributes['default-x'];
  }
  setDefaultX(defaultX: number | null): Fermata {
    this.attributes['default-x'] = defaultX;
    return this;
  }
  getDefaultY(): number | null {
    return this.attributes['default-y'];
  }
  setDefaultY(defaultY: number | null): Fermata {
    this.attributes['default-y'] = defaultY;
    return this;
  }
  getFontFamily(): string | null {
    return this.attributes['font-family'];
  }
  setFontFamily(fontFamily: string | null): Fermata {
    this.attributes['font-family'] = fontFamily;
    return this;
  }
  getFontSize(): 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null {
    return this.attributes['font-size'];
  }
  setFontSize(
    fontSize: 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null
  ): Fermata {
    this.attributes['font-size'] = fontSize;
    return this;
  }
  getFontStyle(): 'normal' | 'italic' | null {
    return this.attributes['font-style'];
  }
  setFontStyle(fontStyle: 'normal' | 'italic' | null): Fermata {
    this.attributes['font-style'] = fontStyle;
    return this;
  }
  getFontWeight(): 'normal' | 'bold' | null {
    return this.attributes['font-weight'];
  }
  setFontWeight(fontWeight: 'normal' | 'bold' | null): Fermata {
    this.attributes['font-weight'] = fontWeight;
    return this;
  }
  getId(): string | null {
    return this.attributes['id'];
  }
  setId(id: string | null): Fermata {
    this.attributes['id'] = id;
    return this;
  }
  getRelativeX(): number | null {
    return this.attributes['relative-x'];
  }
  setRelativeX(relativeX: number | null): Fermata {
    this.attributes['relative-x'] = relativeX;
    return this;
  }
  getRelativeY(): number | null {
    return this.attributes['relative-y'];
  }
  setRelativeY(relativeY: number | null): Fermata {
    this.attributes['relative-y'] = relativeY;
    return this;
  }
  getType(): 'upright' | 'inverted' | null {
    return this.attributes['type'];
  }
  setType(type: 'upright' | 'inverted' | null): Fermata {
    this.attributes['type'] = type;
    return this;
  }
  getFermataShape():
    | ''
    | 'normal'
    | 'angled'
    | 'square'
    | 'double-angled'
    | 'double-square'
    | 'double-dot'
    | 'half-curve'
    | 'curlew' {
    return this.contents[0];
  }
  setFermataShape(
    fermataShape:
      | ''
      | 'normal'
      | 'angled'
      | 'square'
      | 'double-angled'
      | 'double-square'
      | 'double-dot'
      | 'half-curve'
      | 'curlew'
  ): Fermata {
    this.contents[0] = fermataShape;
    return this;
  }
}

export type ArpeggiateAttributes = {
  color: string | null;
  'default-x': number | null;
  'default-y': number | null;
  direction: 'up' | 'down' | null;
  id: string | null;
  number: number | null;
  placement: 'above' | 'below' | null;
  'relative-x': number | null;
  'relative-y': number | null;
  unbroken: 'yes' | 'no' | null;
};

export type ArpeggiateContents = [];

export class Arpeggiate implements XMLElement<'arpeggiate', ArpeggiateAttributes, ArpeggiateContents> {
  static readonly schema = {
    name: 'arpeggiate',
    attributes: {
      color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
      'default-x': {
        type: 'label',
        label: 'default-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'default-y': {
        type: 'label',
        label: 'default-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      direction: { type: 'optional', value: { type: 'choices', choices: ['up', 'down'] } },
      id: { type: 'optional', value: { type: 'regex', pattern: /[A-Za-z_][A-Za-z0-9.-_]*/, zero: '_' } },
      number: { type: 'optional', value: { type: 'int', min: 1, max: 16 } },
      placement: { type: 'optional', value: { type: 'choices', choices: ['above', 'below'] } },
      'relative-x': {
        type: 'label',
        label: 'relative-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'relative-y': {
        type: 'label',
        label: 'relative-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      unbroken: { type: 'optional', value: { type: 'choices', choices: ['yes', 'no'] } },
    },
    contents: [],
  } as const;

  readonly schema = Arpeggiate.schema;

  attributes: ArpeggiateAttributes;
  contents: ArpeggiateContents;

  constructor(opts?: { attributes?: Partial<ArpeggiateAttributes>; contents?: ArpeggiateContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Arpeggiate.schema);
    this.contents = opts?.contents ?? operations.zero(Arpeggiate.schema.contents);
  }
  getColor(): string | null {
    return this.attributes['color'];
  }
  setColor(color: string | null): Arpeggiate {
    this.attributes['color'] = color;
    return this;
  }
  getDefaultX(): number | null {
    return this.attributes['default-x'];
  }
  setDefaultX(defaultX: number | null): Arpeggiate {
    this.attributes['default-x'] = defaultX;
    return this;
  }
  getDefaultY(): number | null {
    return this.attributes['default-y'];
  }
  setDefaultY(defaultY: number | null): Arpeggiate {
    this.attributes['default-y'] = defaultY;
    return this;
  }
  getDirection(): 'up' | 'down' | null {
    return this.attributes['direction'];
  }
  setDirection(direction: 'up' | 'down' | null): Arpeggiate {
    this.attributes['direction'] = direction;
    return this;
  }
  getId(): string | null {
    return this.attributes['id'];
  }
  setId(id: string | null): Arpeggiate {
    this.attributes['id'] = id;
    return this;
  }
  getNumber(): number | null {
    return this.attributes['number'];
  }
  setNumber(number: number | null): Arpeggiate {
    this.attributes['number'] = number;
    return this;
  }
  getPlacement(): 'above' | 'below' | null {
    return this.attributes['placement'];
  }
  setPlacement(placement: 'above' | 'below' | null): Arpeggiate {
    this.attributes['placement'] = placement;
    return this;
  }
  getRelativeX(): number | null {
    return this.attributes['relative-x'];
  }
  setRelativeX(relativeX: number | null): Arpeggiate {
    this.attributes['relative-x'] = relativeX;
    return this;
  }
  getRelativeY(): number | null {
    return this.attributes['relative-y'];
  }
  setRelativeY(relativeY: number | null): Arpeggiate {
    this.attributes['relative-y'] = relativeY;
    return this;
  }
  getUnbroken(): 'yes' | 'no' | null {
    return this.attributes['unbroken'];
  }
  setUnbroken(unbroken: 'yes' | 'no' | null): Arpeggiate {
    this.attributes['unbroken'] = unbroken;
    return this;
  }
}

export type NonArpeggiateAttributes = {
  type: 'top' | 'bottom';
  color: string | null;
  'default-x': number | null;
  'default-y': number | null;
  id: string | null;
  number: number | null;
  placement: 'above' | 'below' | null;
  'relative-x': number | null;
  'relative-y': number | null;
};

export type NonArpeggiateContents = [];

export class NonArpeggiate implements XMLElement<'non-arpeggiate', NonArpeggiateAttributes, NonArpeggiateContents> {
  static readonly schema = {
    name: 'non-arpeggiate',
    attributes: {
      type: { type: 'required', value: { type: 'choices', choices: ['top', 'bottom'] } },
      color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
      'default-x': {
        type: 'label',
        label: 'default-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'default-y': {
        type: 'label',
        label: 'default-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      id: { type: 'optional', value: { type: 'regex', pattern: /[A-Za-z_][A-Za-z0-9.-_]*/, zero: '_' } },
      number: { type: 'optional', value: { type: 'int', min: 1, max: 16 } },
      placement: { type: 'optional', value: { type: 'choices', choices: ['above', 'below'] } },
      'relative-x': {
        type: 'label',
        label: 'relative-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'relative-y': {
        type: 'label',
        label: 'relative-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
    },
    contents: [],
  } as const;

  readonly schema = NonArpeggiate.schema;

  attributes: NonArpeggiateAttributes;
  contents: NonArpeggiateContents;

  constructor(opts?: { attributes?: Partial<NonArpeggiateAttributes>; contents?: NonArpeggiateContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, NonArpeggiate.schema);
    this.contents = opts?.contents ?? operations.zero(NonArpeggiate.schema.contents);
  }
  getType(): 'top' | 'bottom' {
    return this.attributes['type'];
  }
  setType(type: 'top' | 'bottom'): NonArpeggiate {
    this.attributes['type'] = type;
    return this;
  }
  getColor(): string | null {
    return this.attributes['color'];
  }
  setColor(color: string | null): NonArpeggiate {
    this.attributes['color'] = color;
    return this;
  }
  getDefaultX(): number | null {
    return this.attributes['default-x'];
  }
  setDefaultX(defaultX: number | null): NonArpeggiate {
    this.attributes['default-x'] = defaultX;
    return this;
  }
  getDefaultY(): number | null {
    return this.attributes['default-y'];
  }
  setDefaultY(defaultY: number | null): NonArpeggiate {
    this.attributes['default-y'] = defaultY;
    return this;
  }
  getId(): string | null {
    return this.attributes['id'];
  }
  setId(id: string | null): NonArpeggiate {
    this.attributes['id'] = id;
    return this;
  }
  getNumber(): number | null {
    return this.attributes['number'];
  }
  setNumber(number: number | null): NonArpeggiate {
    this.attributes['number'] = number;
    return this;
  }
  getPlacement(): 'above' | 'below' | null {
    return this.attributes['placement'];
  }
  setPlacement(placement: 'above' | 'below' | null): NonArpeggiate {
    this.attributes['placement'] = placement;
    return this;
  }
  getRelativeX(): number | null {
    return this.attributes['relative-x'];
  }
  setRelativeX(relativeX: number | null): NonArpeggiate {
    this.attributes['relative-x'] = relativeX;
    return this;
  }
  getRelativeY(): number | null {
    return this.attributes['relative-y'];
  }
  setRelativeY(relativeY: number | null): NonArpeggiate {
    this.attributes['relative-y'] = relativeY;
    return this;
  }
}

export type OtherNotationAttributes = {
  type: 'start' | 'stop' | 'single';
  color: string | null;
  'default-x': number | null;
  'default-y': number | null;
  id: string | null;
  number: number | null;
  placement: 'above' | 'below' | null;
  'relative-x': number | null;
  'relative-y': number | null;
  smufl: string | null;
};

export type OtherNotationContents = [string];

export class OtherNotation implements XMLElement<'other-notation', OtherNotationAttributes, OtherNotationContents> {
  static readonly schema = {
    name: 'other-notation',
    attributes: {
      type: { type: 'required', value: { type: 'choices', choices: ['start', 'stop', 'single'] } },
      color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
      'default-x': {
        type: 'label',
        label: 'default-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'default-y': {
        type: 'label',
        label: 'default-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      id: { type: 'optional', value: { type: 'regex', pattern: /[A-Za-z_][A-Za-z0-9.-_]*/, zero: '_' } },
      number: { type: 'optional', value: { type: 'int', min: 1, max: 16 } },
      placement: { type: 'optional', value: { type: 'choices', choices: ['above', 'below'] } },
      'relative-x': {
        type: 'label',
        label: 'relative-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'relative-y': {
        type: 'label',
        label: 'relative-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      smufl: { type: 'optional', value: { type: 'string' } },
    },
    contents: [{ type: 'required', value: { type: 'string' } }],
  } as const;

  readonly schema = OtherNotation.schema;

  attributes: OtherNotationAttributes;
  contents: OtherNotationContents;

  constructor(opts?: { attributes?: Partial<OtherNotationAttributes>; contents?: OtherNotationContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, OtherNotation.schema);
    this.contents = opts?.contents ?? operations.zero(OtherNotation.schema.contents);
  }
  getType(): 'start' | 'stop' | 'single' {
    return this.attributes['type'];
  }
  setType(type: 'start' | 'stop' | 'single'): OtherNotation {
    this.attributes['type'] = type;
    return this;
  }
  getColor(): string | null {
    return this.attributes['color'];
  }
  setColor(color: string | null): OtherNotation {
    this.attributes['color'] = color;
    return this;
  }
  getDefaultX(): number | null {
    return this.attributes['default-x'];
  }
  setDefaultX(defaultX: number | null): OtherNotation {
    this.attributes['default-x'] = defaultX;
    return this;
  }
  getDefaultY(): number | null {
    return this.attributes['default-y'];
  }
  setDefaultY(defaultY: number | null): OtherNotation {
    this.attributes['default-y'] = defaultY;
    return this;
  }
  getId(): string | null {
    return this.attributes['id'];
  }
  setId(id: string | null): OtherNotation {
    this.attributes['id'] = id;
    return this;
  }
  getNumber(): number | null {
    return this.attributes['number'];
  }
  setNumber(number: number | null): OtherNotation {
    this.attributes['number'] = number;
    return this;
  }
  getPlacement(): 'above' | 'below' | null {
    return this.attributes['placement'];
  }
  setPlacement(placement: 'above' | 'below' | null): OtherNotation {
    this.attributes['placement'] = placement;
    return this;
  }
  getRelativeX(): number | null {
    return this.attributes['relative-x'];
  }
  setRelativeX(relativeX: number | null): OtherNotation {
    this.attributes['relative-x'] = relativeX;
    return this;
  }
  getRelativeY(): number | null {
    return this.attributes['relative-y'];
  }
  setRelativeY(relativeY: number | null): OtherNotation {
    this.attributes['relative-y'] = relativeY;
    return this;
  }
  getSmufl(): string | null {
    return this.attributes['smufl'];
  }
  setSmufl(smufl: string | null): OtherNotation {
    this.attributes['smufl'] = smufl;
    return this;
  }
  getText(): string {
    return this.contents[0];
  }
  setText(text: string): OtherNotation {
    this.contents[0] = text;
    return this;
  }
}

export type NotationsAttributes = { id: string | null; 'print-object': 'yes' | 'no' | null };

export type NotationsContents = [
  Footnote | null,
  Level | null,
  Array<
    | Tied
    | Slur
    | Tuplet
    | Glissando
    | Slide
    | Ornaments
    | Technical
    | Articulations
    | Dynamics
    | Fermata
    | Arpeggiate
    | NonArpeggiate
    | AccidentalMark
    | OtherNotation
  >
];

export class Notations implements XMLElement<'notations', NotationsAttributes, NotationsContents> {
  static readonly schema = {
    name: 'notations',
    attributes: {
      id: { type: 'optional', value: { type: 'regex', pattern: /[A-Za-z_][A-Za-z0-9.-_]*/, zero: '_' } },
      'print-object': { type: 'optional', value: { type: 'choices', choices: ['yes', 'no'] } },
    },
    contents: [
      { type: 'optional', value: Footnote },
      { type: 'optional', value: Level },
      {
        type: 'label',
        label: 'notations',
        value: {
          type: 'zeroOrMore',
          value: {
            type: 'choices',
            choices: [
              Tied,
              Slur,
              Tuplet,
              Glissando,
              Slide,
              Ornaments,
              Technical,
              Articulations,
              Dynamics,
              Fermata,
              Arpeggiate,
              NonArpeggiate,
              AccidentalMark,
              OtherNotation,
            ],
          },
        },
      },
    ],
  } as const;

  readonly schema = Notations.schema;

  attributes: NotationsAttributes;
  contents: NotationsContents;

  constructor(opts?: { attributes?: Partial<NotationsAttributes>; contents?: NotationsContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Notations.schema);
    this.contents = opts?.contents ?? operations.zero(Notations.schema.contents);
  }
  getId(): string | null {
    return this.attributes['id'];
  }
  setId(id: string | null): Notations {
    this.attributes['id'] = id;
    return this;
  }
  getPrintObject(): 'yes' | 'no' | null {
    return this.attributes['print-object'];
  }
  setPrintObject(printObject: 'yes' | 'no' | null): Notations {
    this.attributes['print-object'] = printObject;
    return this;
  }
  getFootnote(): Footnote | null {
    return this.contents[0];
  }
  setFootnote(footnote: Footnote | null): Notations {
    this.contents[0] = footnote;
    return this;
  }
  getLevel(): Level | null {
    return this.contents[1];
  }
  setLevel(level: Level | null): Notations {
    this.contents[1] = level;
    return this;
  }
  getNotations(): Array<
    | Tied
    | Slur
    | Tuplet
    | Glissando
    | Slide
    | Ornaments
    | Technical
    | Articulations
    | Dynamics
    | Fermata
    | Arpeggiate
    | NonArpeggiate
    | AccidentalMark
    | OtherNotation
  > {
    return this.contents[2];
  }
  setNotations(
    notations: Array<
      | Tied
      | Slur
      | Tuplet
      | Glissando
      | Slide
      | Ornaments
      | Technical
      | Articulations
      | Dynamics
      | Fermata
      | Arpeggiate
      | NonArpeggiate
      | AccidentalMark
      | OtherNotation
    >
  ): Notations {
    this.contents[2] = notations;
    return this;
  }
}

export type SyllabicAttributes = Record<string, unknown>;

export type SyllabicContents = ['begin' | 'end' | 'middle' | 'single'];

export class Syllabic implements XMLElement<'syllabic', SyllabicAttributes, SyllabicContents> {
  static readonly schema = {
    name: 'syllabic',
    attributes: {},
    contents: [
      {
        type: 'required',
        value: {
          type: 'label',
          label: 'syllabic',
          value: { type: 'choices', choices: ['begin', 'end', 'middle', 'single'] },
        },
      },
    ],
  } as const;

  readonly schema = Syllabic.schema;

  attributes: SyllabicAttributes;
  contents: SyllabicContents;

  constructor(opts?: { attributes?: Partial<SyllabicAttributes>; contents?: SyllabicContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Syllabic.schema);
    this.contents = opts?.contents ?? operations.zero(Syllabic.schema.contents);
  }

  getSyllabic(): 'begin' | 'end' | 'middle' | 'single' {
    return this.contents[0];
  }
  setSyllabic(syllabic: 'begin' | 'end' | 'middle' | 'single'): Syllabic {
    this.contents[0] = syllabic;
    return this;
  }
}

export type TextAttributes = {
  color: string | null;
  dir: 'ltr' | 'rtl' | 'lro' | 'rlo' | null;
  'default-x': number | null;
  'default-y': number | null;
  'font-family': string | null;
  'font-size': 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null;
  'font-style': 'normal' | 'italic' | null;
  'font-weight': 'normal' | 'bold' | null;
  'letter-spacing': 'normal' | number | null;
  'line-through': number | null;
  overline: number | null;
  rotation: number | null;
  underline: number | null;
  'xml:lang': string | null;
};

export type TextContents = [string];

export class Text implements XMLElement<'text', TextAttributes, TextContents> {
  static readonly schema = {
    name: 'text',
    attributes: {
      color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
      dir: { type: 'optional', value: { type: 'choices', choices: ['ltr', 'rtl', 'lro', 'rlo'] } },
      'default-x': {
        type: 'label',
        label: 'default-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'default-y': {
        type: 'label',
        label: 'default-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
      'font-size': {
        type: 'optional',
        value: {
          type: 'choices',
          choices: [
            { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
            { type: 'float', min: -Infinity, max: Infinity },
          ],
        },
      },
      'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
      'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
      'letter-spacing': {
        type: 'optional',
        value: { type: 'choices', choices: ['normal', { type: 'float', min: -Infinity, max: Infinity }] },
      },
      'line-through': { type: 'optional', value: { type: 'int', min: 0, max: 3 } },
      overline: { type: 'optional', value: { type: 'int', min: 0, max: 3 } },
      rotation: { type: 'optional', value: { type: 'float', min: -180, max: 180 } },
      underline: { type: 'optional', value: { type: 'int', min: 0, max: 3 } },
      'xml:lang': { type: 'optional', value: { type: 'string' } },
    },
    contents: [{ type: 'string' }],
  } as const;

  readonly schema = Text.schema;

  attributes: TextAttributes;
  contents: TextContents;

  constructor(opts?: { attributes?: Partial<TextAttributes>; contents?: TextContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Text.schema);
    this.contents = opts?.contents ?? operations.zero(Text.schema.contents);
  }
  getColor(): string | null {
    return this.attributes['color'];
  }
  setColor(color: string | null): Text {
    this.attributes['color'] = color;
    return this;
  }
  getDir(): 'ltr' | 'rtl' | 'lro' | 'rlo' | null {
    return this.attributes['dir'];
  }
  setDir(dir: 'ltr' | 'rtl' | 'lro' | 'rlo' | null): Text {
    this.attributes['dir'] = dir;
    return this;
  }
  getDefaultX(): number | null {
    return this.attributes['default-x'];
  }
  setDefaultX(defaultX: number | null): Text {
    this.attributes['default-x'] = defaultX;
    return this;
  }
  getDefaultY(): number | null {
    return this.attributes['default-y'];
  }
  setDefaultY(defaultY: number | null): Text {
    this.attributes['default-y'] = defaultY;
    return this;
  }
  getFontFamily(): string | null {
    return this.attributes['font-family'];
  }
  setFontFamily(fontFamily: string | null): Text {
    this.attributes['font-family'] = fontFamily;
    return this;
  }
  getFontSize(): 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null {
    return this.attributes['font-size'];
  }
  setFontSize(
    fontSize: 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null
  ): Text {
    this.attributes['font-size'] = fontSize;
    return this;
  }
  getFontStyle(): 'normal' | 'italic' | null {
    return this.attributes['font-style'];
  }
  setFontStyle(fontStyle: 'normal' | 'italic' | null): Text {
    this.attributes['font-style'] = fontStyle;
    return this;
  }
  getFontWeight(): 'normal' | 'bold' | null {
    return this.attributes['font-weight'];
  }
  setFontWeight(fontWeight: 'normal' | 'bold' | null): Text {
    this.attributes['font-weight'] = fontWeight;
    return this;
  }
  getLetterSpacing(): 'normal' | number | null {
    return this.attributes['letter-spacing'];
  }
  setLetterSpacing(letterSpacing: 'normal' | number | null): Text {
    this.attributes['letter-spacing'] = letterSpacing;
    return this;
  }
  getLineThrough(): number | null {
    return this.attributes['line-through'];
  }
  setLineThrough(lineThrough: number | null): Text {
    this.attributes['line-through'] = lineThrough;
    return this;
  }
  getOverline(): number | null {
    return this.attributes['overline'];
  }
  setOverline(overline: number | null): Text {
    this.attributes['overline'] = overline;
    return this;
  }
  getRotation(): number | null {
    return this.attributes['rotation'];
  }
  setRotation(rotation: number | null): Text {
    this.attributes['rotation'] = rotation;
    return this;
  }
  getUnderline(): number | null {
    return this.attributes['underline'];
  }
  setUnderline(underline: number | null): Text {
    this.attributes['underline'] = underline;
    return this;
  }
  getXmlLang(): string | null {
    return this.attributes['xml:lang'];
  }
  setXmlLang(xmlLang: string | null): Text {
    this.attributes['xml:lang'] = xmlLang;
    return this;
  }
  getText(): string {
    return this.contents[0];
  }
  setText(text: string): Text {
    this.contents[0] = text;
    return this;
  }
}

export type ElisionAttributes = {
  color: string | null;
  'font-family': string | null;
  'font-size': 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null;
  'font-style': 'normal' | 'italic' | null;
  'font-weight': 'normal' | 'bold' | null;
  smufl: string | null;
};

export type ElisionContents = [];

export class Elision implements XMLElement<'elision', ElisionAttributes, ElisionContents> {
  static readonly schema = {
    name: 'elision',
    attributes: {
      color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
      'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
      'font-size': {
        type: 'optional',
        value: {
          type: 'choices',
          choices: [
            { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
            { type: 'float', min: -Infinity, max: Infinity },
          ],
        },
      },
      'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
      'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
      smufl: { type: 'optional', value: { type: 'regex', pattern: /lyrics/, zero: 'lyrics' } },
    },
    contents: [],
  } as const;

  readonly schema = Elision.schema;

  attributes: ElisionAttributes;
  contents: ElisionContents;

  constructor(opts?: { attributes?: Partial<ElisionAttributes>; contents?: ElisionContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Elision.schema);
    this.contents = opts?.contents ?? operations.zero(Elision.schema.contents);
  }
  getColor(): string | null {
    return this.attributes['color'];
  }
  setColor(color: string | null): Elision {
    this.attributes['color'] = color;
    return this;
  }
  getFontFamily(): string | null {
    return this.attributes['font-family'];
  }
  setFontFamily(fontFamily: string | null): Elision {
    this.attributes['font-family'] = fontFamily;
    return this;
  }
  getFontSize(): 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null {
    return this.attributes['font-size'];
  }
  setFontSize(
    fontSize: 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null
  ): Elision {
    this.attributes['font-size'] = fontSize;
    return this;
  }
  getFontStyle(): 'normal' | 'italic' | null {
    return this.attributes['font-style'];
  }
  setFontStyle(fontStyle: 'normal' | 'italic' | null): Elision {
    this.attributes['font-style'] = fontStyle;
    return this;
  }
  getFontWeight(): 'normal' | 'bold' | null {
    return this.attributes['font-weight'];
  }
  setFontWeight(fontWeight: 'normal' | 'bold' | null): Elision {
    this.attributes['font-weight'] = fontWeight;
    return this;
  }
  getSmufl(): string | null {
    return this.attributes['smufl'];
  }
  setSmufl(smufl: string | null): Elision {
    this.attributes['smufl'] = smufl;
    return this;
  }
}

export type ExtendAttributes = {
  color: string | null;
  'default-x': number | null;
  'default-y': number | null;
  'relative-x': number | null;
  'relative-y': number | null;
  type: 'start' | 'stop' | 'continue' | null;
};

export type ExtendContents = [];

export class Extend implements XMLElement<'extend', ExtendAttributes, ExtendContents> {
  static readonly schema = {
    name: 'extend',
    attributes: {
      color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
      'default-x': {
        type: 'label',
        label: 'default-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'default-y': {
        type: 'label',
        label: 'default-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'relative-x': {
        type: 'label',
        label: 'relative-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'relative-y': {
        type: 'label',
        label: 'relative-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      type: { type: 'optional', value: { type: 'choices', choices: ['start', 'stop', 'continue'] } },
    },
    contents: [],
  } as const;

  readonly schema = Extend.schema;

  attributes: ExtendAttributes;
  contents: ExtendContents;

  constructor(opts?: { attributes?: Partial<ExtendAttributes>; contents?: ExtendContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Extend.schema);
    this.contents = opts?.contents ?? operations.zero(Extend.schema.contents);
  }
  getColor(): string | null {
    return this.attributes['color'];
  }
  setColor(color: string | null): Extend {
    this.attributes['color'] = color;
    return this;
  }
  getDefaultX(): number | null {
    return this.attributes['default-x'];
  }
  setDefaultX(defaultX: number | null): Extend {
    this.attributes['default-x'] = defaultX;
    return this;
  }
  getDefaultY(): number | null {
    return this.attributes['default-y'];
  }
  setDefaultY(defaultY: number | null): Extend {
    this.attributes['default-y'] = defaultY;
    return this;
  }
  getRelativeX(): number | null {
    return this.attributes['relative-x'];
  }
  setRelativeX(relativeX: number | null): Extend {
    this.attributes['relative-x'] = relativeX;
    return this;
  }
  getRelativeY(): number | null {
    return this.attributes['relative-y'];
  }
  setRelativeY(relativeY: number | null): Extend {
    this.attributes['relative-y'] = relativeY;
    return this;
  }
  getType(): 'start' | 'stop' | 'continue' | null {
    return this.attributes['type'];
  }
  setType(type: 'start' | 'stop' | 'continue' | null): Extend {
    this.attributes['type'] = type;
    return this;
  }
}

export type LaughingAttributes = Record<string, unknown>;

export type LaughingContents = [];

export class Laughing implements XMLElement<'laughing', LaughingAttributes, LaughingContents> {
  static readonly schema = { name: 'laughing', attributes: {}, contents: [] } as const;

  readonly schema = Laughing.schema;

  attributes: LaughingAttributes;
  contents: LaughingContents;

  constructor(opts?: { attributes?: Partial<LaughingAttributes>; contents?: LaughingContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Laughing.schema);
    this.contents = opts?.contents ?? operations.zero(Laughing.schema.contents);
  }
}

export type HummingAttributes = Record<string, unknown>;

export type HummingContents = [];

export class Humming implements XMLElement<'humming', HummingAttributes, HummingContents> {
  static readonly schema = { name: 'humming', attributes: {}, contents: [] } as const;

  readonly schema = Humming.schema;

  attributes: HummingAttributes;
  contents: HummingContents;

  constructor(opts?: { attributes?: Partial<HummingAttributes>; contents?: HummingContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Humming.schema);
    this.contents = opts?.contents ?? operations.zero(Humming.schema.contents);
  }
}

export type EndLineAttributes = Record<string, unknown>;

export type EndLineContents = [];

export class EndLine implements XMLElement<'end-line', EndLineAttributes, EndLineContents> {
  static readonly schema = { name: 'end-line', attributes: {}, contents: [] } as const;

  readonly schema = EndLine.schema;

  attributes: EndLineAttributes;
  contents: EndLineContents;

  constructor(opts?: { attributes?: Partial<EndLineAttributes>; contents?: EndLineContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, EndLine.schema);
    this.contents = opts?.contents ?? operations.zero(EndLine.schema.contents);
  }
}

export type EndParagraphAttributes = Record<string, unknown>;

export type EndParagraphContents = [];

export class EndParagraph implements XMLElement<'end-paragraph', EndParagraphAttributes, EndParagraphContents> {
  static readonly schema = { name: 'end-paragraph', attributes: {}, contents: [] } as const;

  readonly schema = EndParagraph.schema;

  attributes: EndParagraphAttributes;
  contents: EndParagraphContents;

  constructor(opts?: { attributes?: Partial<EndParagraphAttributes>; contents?: EndParagraphContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, EndParagraph.schema);
    this.contents = opts?.contents ?? operations.zero(EndParagraph.schema.contents);
  }
}

export type Intelligible = [Syllabic | null, Text, Array<[[Elision, Syllabic | null] | null, Text]>, Extend | null];

export type LyricAttributes = {
  color: string | null;
  'default-x': number | null;
  'default-y': number | null;
  id: string | null;
  justify: 'left' | 'center' | 'right' | null;
  name: string | null;
  number: string | null;
  placement: 'above' | 'below' | null;
  'print-object': 'yes' | 'no' | null;
  'relative-x': number | null;
  'relative-y': number | null;
  'time-only': string | null;
};

export type LyricContents = [
  Intelligible | Extend | Laughing | Humming,
  EndLine | null,
  EndParagraph | null,
  Footnote | null,
  Level | null
];

export class Lyric implements XMLElement<'lyric', LyricAttributes, LyricContents> {
  static readonly schema = {
    name: 'lyric',
    attributes: {
      color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
      'default-x': {
        type: 'label',
        label: 'default-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'default-y': {
        type: 'label',
        label: 'default-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      id: { type: 'optional', value: { type: 'regex', pattern: /[A-Za-z_][A-Za-z0-9.-_]*/, zero: '_' } },
      justify: { type: 'optional', value: { type: 'choices', choices: ['left', 'center', 'right'] } },
      name: { type: 'optional', value: { type: 'string' } },
      number: { type: 'optional', value: { type: 'string' } },
      placement: { type: 'optional', value: { type: 'choices', choices: ['above', 'below'] } },
      'print-object': { type: 'optional', value: { type: 'choices', choices: ['yes', 'no'] } },
      'relative-x': {
        type: 'label',
        label: 'relative-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'relative-y': {
        type: 'label',
        label: 'relative-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'time-only': { type: 'optional', value: { type: 'regex', pattern: /[1-9][0-9]*(, ?[1-9][0-9]*)*/, zero: '1' } },
    },
    contents: [
      {
        type: 'label',
        label: 'lyric-value',
        value: {
          type: 'choices',
          choices: [
            {
              type: 'label',
              label: 'intelligible',
              value: [
                { type: 'optional', value: Syllabic },
                { type: 'required', value: Text },
                {
                  type: 'zeroOrMore',
                  value: [
                    {
                      type: 'optional',
                      value: [
                        { type: 'required', value: Elision },
                        { type: 'optional', value: Syllabic },
                      ],
                    },
                    { type: 'required', value: Text },
                  ],
                },
                { type: 'optional', value: Extend },
              ],
            },
            Extend,
            Laughing,
            Humming,
          ],
        },
      },
      { type: 'optional', value: EndLine },
      { type: 'optional', value: EndParagraph },
      { type: 'optional', value: Footnote },
      { type: 'optional', value: Level },
    ],
  } as const;

  readonly schema = Lyric.schema;

  attributes: LyricAttributes;
  contents: LyricContents;

  constructor(opts?: { attributes?: Partial<LyricAttributes>; contents?: LyricContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Lyric.schema);
    this.contents = opts?.contents ?? operations.zero(Lyric.schema.contents);
  }
  getColor(): string | null {
    return this.attributes['color'];
  }
  setColor(color: string | null): Lyric {
    this.attributes['color'] = color;
    return this;
  }
  getDefaultX(): number | null {
    return this.attributes['default-x'];
  }
  setDefaultX(defaultX: number | null): Lyric {
    this.attributes['default-x'] = defaultX;
    return this;
  }
  getDefaultY(): number | null {
    return this.attributes['default-y'];
  }
  setDefaultY(defaultY: number | null): Lyric {
    this.attributes['default-y'] = defaultY;
    return this;
  }
  getId(): string | null {
    return this.attributes['id'];
  }
  setId(id: string | null): Lyric {
    this.attributes['id'] = id;
    return this;
  }
  getJustify(): 'left' | 'center' | 'right' | null {
    return this.attributes['justify'];
  }
  setJustify(justify: 'left' | 'center' | 'right' | null): Lyric {
    this.attributes['justify'] = justify;
    return this;
  }
  getName(): string | null {
    return this.attributes['name'];
  }
  setName(name: string | null): Lyric {
    this.attributes['name'] = name;
    return this;
  }
  getNumber(): string | null {
    return this.attributes['number'];
  }
  setNumber(number: string | null): Lyric {
    this.attributes['number'] = number;
    return this;
  }
  getPlacement(): 'above' | 'below' | null {
    return this.attributes['placement'];
  }
  setPlacement(placement: 'above' | 'below' | null): Lyric {
    this.attributes['placement'] = placement;
    return this;
  }
  getPrintObject(): 'yes' | 'no' | null {
    return this.attributes['print-object'];
  }
  setPrintObject(printObject: 'yes' | 'no' | null): Lyric {
    this.attributes['print-object'] = printObject;
    return this;
  }
  getRelativeX(): number | null {
    return this.attributes['relative-x'];
  }
  setRelativeX(relativeX: number | null): Lyric {
    this.attributes['relative-x'] = relativeX;
    return this;
  }
  getRelativeY(): number | null {
    return this.attributes['relative-y'];
  }
  setRelativeY(relativeY: number | null): Lyric {
    this.attributes['relative-y'] = relativeY;
    return this;
  }
  getTimeOnly(): string | null {
    return this.attributes['time-only'];
  }
  setTimeOnly(timeOnly: string | null): Lyric {
    this.attributes['time-only'] = timeOnly;
    return this;
  }
  getLyricValue(): Intelligible | Extend | Laughing | Humming {
    return this.contents[0];
  }
  setLyricValue(lyricValue: Intelligible | Extend | Laughing | Humming): Lyric {
    this.contents[0] = lyricValue;
    return this;
  }
  getEndLine(): EndLine | null {
    return this.contents[1];
  }
  setEndLine(endLine: EndLine | null): Lyric {
    this.contents[1] = endLine;
    return this;
  }
  getEndParagraph(): EndParagraph | null {
    return this.contents[2];
  }
  setEndParagraph(endParagraph: EndParagraph | null): Lyric {
    this.contents[2] = endParagraph;
    return this;
  }
  getFootnote(): Footnote | null {
    return this.contents[3];
  }
  setFootnote(footnote: Footnote | null): Lyric {
    this.contents[3] = footnote;
    return this;
  }
  getLevel(): Level | null {
    return this.contents[4];
  }
  setLevel(level: Level | null): Lyric {
    this.contents[4] = level;
    return this;
  }
}

export type IpaAttributes = Record<string, unknown>;

export type IpaContents = [string];

export class Ipa implements XMLElement<'ipa', IpaAttributes, IpaContents> {
  static readonly schema = {
    name: 'ipa',
    attributes: {},
    contents: [{ type: 'required', value: { type: 'string' } }],
  } as const;

  readonly schema = Ipa.schema;

  attributes: IpaAttributes;
  contents: IpaContents;

  constructor(opts?: { attributes?: Partial<IpaAttributes>; contents?: IpaContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Ipa.schema);
    this.contents = opts?.contents ?? operations.zero(Ipa.schema.contents);
  }

  getText(): string {
    return this.contents[0];
  }
  setText(text: string): Ipa {
    this.contents[0] = text;
    return this;
  }
}

export type MuteAttributes = Record<string, unknown>;

export type MuteContents = [
  | 'on'
  | 'off'
  | 'bucket'
  | 'cup'
  | 'echo'
  | 'harmon-no-stem'
  | 'harmon-stem'
  | 'hat'
  | 'palm'
  | 'plunger'
  | 'practice'
  | 'solotone'
  | 'stop-hand'
  | 'stop-mute'
  | 'straight'
];

export class Mute implements XMLElement<'mute', MuteAttributes, MuteContents> {
  static readonly schema = {
    name: 'mute',
    attributes: {},
    contents: [
      {
        type: 'required',
        value: {
          type: 'label',
          label: 'mute',
          value: {
            type: 'choices',
            choices: [
              'on',
              'off',
              'bucket',
              'cup',
              'echo',
              'harmon-no-stem',
              'harmon-stem',
              'hat',
              'palm',
              'plunger',
              'practice',
              'solotone',
              'stop-hand',
              'stop-mute',
              'straight',
            ],
          },
        },
      },
    ],
  } as const;

  readonly schema = Mute.schema;

  attributes: MuteAttributes;
  contents: MuteContents;

  constructor(opts?: { attributes?: Partial<MuteAttributes>; contents?: MuteContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Mute.schema);
    this.contents = opts?.contents ?? operations.zero(Mute.schema.contents);
  }

  getMute():
    | 'on'
    | 'off'
    | 'bucket'
    | 'cup'
    | 'echo'
    | 'harmon-no-stem'
    | 'harmon-stem'
    | 'hat'
    | 'palm'
    | 'plunger'
    | 'practice'
    | 'solotone'
    | 'stop-hand'
    | 'stop-mute'
    | 'straight' {
    return this.contents[0];
  }
  setMute(
    mute:
      | 'on'
      | 'off'
      | 'bucket'
      | 'cup'
      | 'echo'
      | 'harmon-no-stem'
      | 'harmon-stem'
      | 'hat'
      | 'palm'
      | 'plunger'
      | 'practice'
      | 'solotone'
      | 'stop-hand'
      | 'stop-mute'
      | 'straight'
  ): Mute {
    this.contents[0] = mute;
    return this;
  }
}

export type SemiPitchedAttributes = Record<string, unknown>;

export type SemiPitchedContents = ['high' | 'low' | 'medium' | 'medium-high' | 'medium-low' | 'very-low'];

export class SemiPitched implements XMLElement<'semi-pitched', SemiPitchedAttributes, SemiPitchedContents> {
  static readonly schema = {
    name: 'semi-pitched',
    attributes: {},
    contents: [
      {
        type: 'required',
        value: {
          type: 'label',
          label: 'semi-pitched',
          value: { type: 'choices', choices: ['high', 'low', 'medium', 'medium-high', 'medium-low', 'very-low'] },
        },
      },
    ],
  } as const;

  readonly schema = SemiPitched.schema;

  attributes: SemiPitchedAttributes;
  contents: SemiPitchedContents;

  constructor(opts?: { attributes?: Partial<SemiPitchedAttributes>; contents?: SemiPitchedContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, SemiPitched.schema);
    this.contents = opts?.contents ?? operations.zero(SemiPitched.schema.contents);
  }

  getSemiPitched(): 'high' | 'low' | 'medium' | 'medium-high' | 'medium-low' | 'very-low' {
    return this.contents[0];
  }
  setSemiPitched(semiPitched: 'high' | 'low' | 'medium' | 'medium-high' | 'medium-low' | 'very-low'): SemiPitched {
    this.contents[0] = semiPitched;
    return this;
  }
}

export type OtherPlayAttributes = { type: string };

export type OtherPlayContents = [];

export class OtherPlay implements XMLElement<'other-play', OtherPlayAttributes, OtherPlayContents> {
  static readonly schema = {
    name: 'other-play',
    attributes: { type: { type: 'required', value: { type: 'string' } } },
    contents: [],
  } as const;

  readonly schema = OtherPlay.schema;

  attributes: OtherPlayAttributes;
  contents: OtherPlayContents;

  constructor(opts?: { attributes?: Partial<OtherPlayAttributes>; contents?: OtherPlayContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, OtherPlay.schema);
    this.contents = opts?.contents ?? operations.zero(OtherPlay.schema.contents);
  }
  getType(): string {
    return this.attributes['type'];
  }
  setType(type: string): OtherPlay {
    this.attributes['type'] = type;
    return this;
  }
}

export type PlayAttributes = { id: string | null };

export type PlayContents = [Array<Ipa | Mute | SemiPitched | OtherPlay>];

export class Play implements XMLElement<'play', PlayAttributes, PlayContents> {
  static readonly schema = {
    name: 'play',
    attributes: { id: { type: 'optional', value: { type: 'regex', pattern: /[A-Za-z_][A-Za-z0-9.-_]*/, zero: '_' } } },
    contents: [
      {
        type: 'label',
        label: 'play-value',
        value: { type: 'zeroOrMore', value: { type: 'choices', choices: [Ipa, Mute, SemiPitched, OtherPlay] } },
      },
    ],
  } as const;

  readonly schema = Play.schema;

  attributes: PlayAttributes;
  contents: PlayContents;

  constructor(opts?: { attributes?: Partial<PlayAttributes>; contents?: PlayContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Play.schema);
    this.contents = opts?.contents ?? operations.zero(Play.schema.contents);
  }
  getId(): string | null {
    return this.attributes['id'];
  }
  setId(id: string | null): Play {
    this.attributes['id'] = id;
    return this;
  }
  getPlayValue(): Array<Ipa | Mute | SemiPitched | OtherPlay> {
    return this.contents[0];
  }
  setPlayValue(playValue: Array<Ipa | Mute | SemiPitched | OtherPlay>): Play {
    this.contents[0] = playValue;
    return this;
  }
}

export type AssessAttributes = { type: 'yes' | 'no'; player: string | null; 'time-only': string | null };

export type AssessContents = [];

export class Assess implements XMLElement<'assess', AssessAttributes, AssessContents> {
  static readonly schema = {
    name: 'assess',
    attributes: {
      type: { type: 'required', value: { type: 'choices', choices: ['yes', 'no'] } },
      player: { type: 'optional', value: { type: 'regex', pattern: /[A-Za-z_][A-Za-z0-9.-_]*/, zero: '_' } },
      'time-only': { type: 'optional', value: { type: 'regex', pattern: /[1-9][0-9]*(, ?[1-9][0-9]*)*/, zero: '1' } },
    },
    contents: [],
  } as const;

  readonly schema = Assess.schema;

  attributes: AssessAttributes;
  contents: AssessContents;

  constructor(opts?: { attributes?: Partial<AssessAttributes>; contents?: AssessContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Assess.schema);
    this.contents = opts?.contents ?? operations.zero(Assess.schema.contents);
  }
  getType(): 'yes' | 'no' {
    return this.attributes['type'];
  }
  setType(type: 'yes' | 'no'): Assess {
    this.attributes['type'] = type;
    return this;
  }
  getPlayer(): string | null {
    return this.attributes['player'];
  }
  setPlayer(player: string | null): Assess {
    this.attributes['player'] = player;
    return this;
  }
  getTimeOnly(): string | null {
    return this.attributes['time-only'];
  }
  setTimeOnly(timeOnly: string | null): Assess {
    this.attributes['time-only'] = timeOnly;
    return this;
  }
}

export type WaitAttributes = { player: string | null; 'time-only': string | null };

export type WaitContents = [];

export class Wait implements XMLElement<'wait', WaitAttributes, WaitContents> {
  static readonly schema = {
    name: 'wait',
    attributes: {
      player: { type: 'optional', value: { type: 'regex', pattern: /[A-Za-z_][A-Za-z0-9.-_]*/, zero: '_' } },
      'time-only': { type: 'optional', value: { type: 'regex', pattern: /[1-9][0-9]*(, ?[1-9][0-9]*)*/, zero: '1' } },
    },
    contents: [],
  } as const;

  readonly schema = Wait.schema;

  attributes: WaitAttributes;
  contents: WaitContents;

  constructor(opts?: { attributes?: Partial<WaitAttributes>; contents?: WaitContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Wait.schema);
    this.contents = opts?.contents ?? operations.zero(Wait.schema.contents);
  }
  getPlayer(): string | null {
    return this.attributes['player'];
  }
  setPlayer(player: string | null): Wait {
    this.attributes['player'] = player;
    return this;
  }
  getTimeOnly(): string | null {
    return this.attributes['time-only'];
  }
  setTimeOnly(timeOnly: string | null): Wait {
    this.attributes['time-only'] = timeOnly;
    return this;
  }
}

export type OtherListenAttributes = { type: string; player: string | null; 'time-only': string | null };

export type OtherListenContents = [string];

export class OtherListen implements XMLElement<'other-listen', OtherListenAttributes, OtherListenContents> {
  static readonly schema = {
    name: 'other-listen',
    attributes: {
      type: { type: 'required', value: { type: 'string' } },
      player: { type: 'optional', value: { type: 'regex', pattern: /[A-Za-z_][A-Za-z0-9.-_]*/, zero: '_' } },
      'time-only': { type: 'optional', value: { type: 'regex', pattern: /[1-9][0-9]*(, ?[1-9][0-9]*)*/, zero: '1' } },
    },
    contents: [{ type: 'required', value: { type: 'string' } }],
  } as const;

  readonly schema = OtherListen.schema;

  attributes: OtherListenAttributes;
  contents: OtherListenContents;

  constructor(opts?: { attributes?: Partial<OtherListenAttributes>; contents?: OtherListenContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, OtherListen.schema);
    this.contents = opts?.contents ?? operations.zero(OtherListen.schema.contents);
  }
  getType(): string {
    return this.attributes['type'];
  }
  setType(type: string): OtherListen {
    this.attributes['type'] = type;
    return this;
  }
  getPlayer(): string | null {
    return this.attributes['player'];
  }
  setPlayer(player: string | null): OtherListen {
    this.attributes['player'] = player;
    return this;
  }
  getTimeOnly(): string | null {
    return this.attributes['time-only'];
  }
  setTimeOnly(timeOnly: string | null): OtherListen {
    this.attributes['time-only'] = timeOnly;
    return this;
  }
  getText(): string {
    return this.contents[0];
  }
  setText(text: string): OtherListen {
    this.contents[0] = text;
    return this;
  }
}

export type ListenAttributes = Record<string, unknown>;

export type ListenContents = [Array<Assess | Wait | OtherListen>];

export class Listen implements XMLElement<'listen', ListenAttributes, ListenContents> {
  static readonly schema = {
    name: 'listen',
    attributes: {},
    contents: [
      {
        type: 'label',
        label: 'listens',
        value: { type: 'oneOrMore', value: { type: 'choices', choices: [Assess, Wait, OtherListen] } },
      },
    ],
  } as const;

  readonly schema = Listen.schema;

  attributes: ListenAttributes;
  contents: ListenContents;

  constructor(opts?: { attributes?: Partial<ListenAttributes>; contents?: ListenContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Listen.schema);
    this.contents = opts?.contents ?? operations.zero(Listen.schema.contents);
  }

  getListens(): Array<Assess | Wait | OtherListen> {
    return this.contents[0];
  }
  setListens(listens: Array<Assess | Wait | OtherListen>): Listen {
    this.contents[0] = listens;
    return this;
  }
}

export type TiedNoteValue = [Chord | null, Pitch | Unpitched | Rest, Duration, [] | [Tie] | [Tie, Tie]];

export type CuedNoteValue = [Cue, Chord | null, Pitch | Unpitched | Rest, Duration];

export type TiedGraceNoteValue = [Grace, Chord | null, Pitch | Unpitched | Rest, [] | [Tie] | [Tie, Tie]];

export type CuedGraceNoteValue = [Grace, Cue, Chord | null, Pitch | Unpitched | Rest, Duration];

export type NoteAttributes = {
  attack: number | null;
  color: string | null;
  'default-x': number | null;
  'default-y': number | null;
  dynamics: number | null;
  'end-dynamics': number | null;
  'font-family': string | null;
  'font-size': 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null;
  'font-style': 'normal' | 'italic' | null;
  'font-weight': 'normal' | 'bold' | null;
  id: string | null;
  pizzicato: 'yes' | 'no' | null;
  'print-dot': 'yes' | 'no' | null;
  'print-leger': 'yes' | 'no' | null;
  'print-lyric': 'yes' | 'no' | null;
  'print-object': 'yes' | 'no' | null;
  'print-spacing': 'yes' | 'no' | null;
  'relative-x': number | null;
  'relative-y': number | null;
  release: number | null;
  'time-only': string | null;
};

export type NoteContents = [
  TiedNoteValue | CuedNoteValue | TiedGraceNoteValue | CuedGraceNoteValue,
  Array<Instrument>,
  Footnote | null,
  Level | null,
  Voice | null,
  Type | null,
  Array<Dot>,
  Accidental | null,
  TimeModification | null,
  Stem | null,
  Notehead | null,
  NoteheadText | null,
  Staff | null,
  (
    | []
    | [Beam]
    | [Beam, Beam]
    | [Beam, Beam, Beam]
    | [Beam, Beam, Beam, Beam]
    | [Beam, Beam, Beam, Beam, Beam]
    | [Beam, Beam, Beam, Beam, Beam, Beam]
    | [Beam, Beam, Beam, Beam, Beam, Beam, Beam]
    | [Beam, Beam, Beam, Beam, Beam, Beam, Beam, Beam]
  ),
  Array<Notations>,
  Array<Lyric>,
  Play | null,
  Listen | null
];

export class Note implements XMLElement<'note', NoteAttributes, NoteContents> {
  static readonly schema = {
    name: 'note',
    attributes: {
      attack: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
      'default-x': {
        type: 'label',
        label: 'default-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'default-y': {
        type: 'label',
        label: 'default-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      dynamics: { type: 'optional', value: { type: 'float', min: 0, max: Infinity } },
      'end-dynamics': { type: 'optional', value: { type: 'float', min: 0, max: Infinity } },
      'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
      'font-size': {
        type: 'optional',
        value: {
          type: 'choices',
          choices: [
            { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
            { type: 'float', min: -Infinity, max: Infinity },
          ],
        },
      },
      'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
      'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
      id: { type: 'optional', value: { type: 'regex', pattern: /[A-Za-z_][A-Za-z0-9.-_]*/, zero: '_' } },
      pizzicato: { type: 'optional', value: { type: 'choices', choices: ['yes', 'no'] } },
      'print-dot': { type: 'optional', value: { type: 'choices', choices: ['yes', 'no'] } },
      'print-leger': { type: 'optional', value: { type: 'choices', choices: ['yes', 'no'] } },
      'print-lyric': { type: 'optional', value: { type: 'choices', choices: ['yes', 'no'] } },
      'print-object': { type: 'optional', value: { type: 'choices', choices: ['yes', 'no'] } },
      'print-spacing': { type: 'optional', value: { type: 'choices', choices: ['yes', 'no'] } },
      'relative-x': {
        type: 'label',
        label: 'relative-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'relative-y': {
        type: 'label',
        label: 'relative-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      release: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      'time-only': { type: 'optional', value: { type: 'regex', pattern: /[1-9][0-9]*(, ?[1-9][0-9]*)*/, zero: '1' } },
    },
    contents: [
      {
        type: 'label',
        label: 'note-value',
        value: {
          type: 'choices',
          choices: [
            {
              type: 'label',
              label: 'tied-note-value',
              value: [
                { type: 'optional', value: Chord },
                { type: 'choices', choices: [Pitch, Unpitched, Rest] },
                { type: 'required', value: Duration },
                { type: 'choices', choices: [[], [Tie], [Tie, Tie]] },
              ],
            },
            {
              type: 'label',
              label: 'cued-note-value',
              value: [
                { type: 'required', value: Cue },
                { type: 'optional', value: Chord },
                { type: 'choices', choices: [Pitch, Unpitched, Rest] },
                { type: 'required', value: Duration },
              ],
            },
            {
              type: 'label',
              label: 'tied-grace-note-value',
              value: [
                { type: 'required', value: Grace },
                { type: 'optional', value: Chord },
                { type: 'choices', choices: [Pitch, Unpitched, Rest] },
                { type: 'choices', choices: [[], [Tie], [Tie, Tie]] },
              ],
            },
            {
              type: 'label',
              label: 'cued-grace-note-value',
              value: [
                { type: 'required', value: Grace },
                { type: 'required', value: Cue },
                { type: 'optional', value: Chord },
                { type: 'choices', choices: [Pitch, Unpitched, Rest] },
                { type: 'required', value: Duration },
              ],
            },
          ],
        },
      },
      { type: 'label', label: 'instruments', value: { type: 'zeroOrMore', value: Instrument } },
      { type: 'optional', value: Footnote },
      { type: 'optional', value: Level },
      { type: 'optional', value: Voice },
      { type: 'optional', value: Type },
      { type: 'label', label: 'dots', value: { type: 'zeroOrMore', value: Dot } },
      { type: 'optional', value: Accidental },
      { type: 'optional', value: TimeModification },
      { type: 'optional', value: Stem },
      { type: 'optional', value: Notehead },
      { type: 'optional', value: NoteheadText },
      { type: 'optional', value: Staff },
      {
        type: 'label',
        label: 'beams',
        value: {
          type: 'choices',
          choices: [
            [],
            [Beam],
            [Beam, Beam],
            [Beam, Beam, Beam],
            [Beam, Beam, Beam, Beam],
            [Beam, Beam, Beam, Beam, Beam],
            [Beam, Beam, Beam, Beam, Beam, Beam],
            [Beam, Beam, Beam, Beam, Beam, Beam, Beam],
            [Beam, Beam, Beam, Beam, Beam, Beam, Beam, Beam],
          ],
        },
      },
      { type: 'label', label: 'notations', value: { type: 'zeroOrMore', value: Notations } },
      { type: 'label', label: 'lyrics', value: { type: 'zeroOrMore', value: Lyric } },
      { type: 'optional', value: Play },
      { type: 'optional', value: Listen },
    ],
  } as const;

  readonly schema = Note.schema;

  attributes: NoteAttributes;
  contents: NoteContents;

  constructor(opts?: { attributes?: Partial<NoteAttributes>; contents?: NoteContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Note.schema);
    this.contents = opts?.contents ?? operations.zero(Note.schema.contents);
  }
  getAttack(): number | null {
    return this.attributes['attack'];
  }
  setAttack(attack: number | null): Note {
    this.attributes['attack'] = attack;
    return this;
  }
  getColor(): string | null {
    return this.attributes['color'];
  }
  setColor(color: string | null): Note {
    this.attributes['color'] = color;
    return this;
  }
  getDefaultX(): number | null {
    return this.attributes['default-x'];
  }
  setDefaultX(defaultX: number | null): Note {
    this.attributes['default-x'] = defaultX;
    return this;
  }
  getDefaultY(): number | null {
    return this.attributes['default-y'];
  }
  setDefaultY(defaultY: number | null): Note {
    this.attributes['default-y'] = defaultY;
    return this;
  }
  getDynamics(): number | null {
    return this.attributes['dynamics'];
  }
  setDynamics(dynamics: number | null): Note {
    this.attributes['dynamics'] = dynamics;
    return this;
  }
  getEndDynamics(): number | null {
    return this.attributes['end-dynamics'];
  }
  setEndDynamics(endDynamics: number | null): Note {
    this.attributes['end-dynamics'] = endDynamics;
    return this;
  }
  getFontFamily(): string | null {
    return this.attributes['font-family'];
  }
  setFontFamily(fontFamily: string | null): Note {
    this.attributes['font-family'] = fontFamily;
    return this;
  }
  getFontSize(): 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null {
    return this.attributes['font-size'];
  }
  setFontSize(
    fontSize: 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null
  ): Note {
    this.attributes['font-size'] = fontSize;
    return this;
  }
  getFontStyle(): 'normal' | 'italic' | null {
    return this.attributes['font-style'];
  }
  setFontStyle(fontStyle: 'normal' | 'italic' | null): Note {
    this.attributes['font-style'] = fontStyle;
    return this;
  }
  getFontWeight(): 'normal' | 'bold' | null {
    return this.attributes['font-weight'];
  }
  setFontWeight(fontWeight: 'normal' | 'bold' | null): Note {
    this.attributes['font-weight'] = fontWeight;
    return this;
  }
  getId(): string | null {
    return this.attributes['id'];
  }
  setId(id: string | null): Note {
    this.attributes['id'] = id;
    return this;
  }
  getPizzicato(): 'yes' | 'no' | null {
    return this.attributes['pizzicato'];
  }
  setPizzicato(pizzicato: 'yes' | 'no' | null): Note {
    this.attributes['pizzicato'] = pizzicato;
    return this;
  }
  getPrintDot(): 'yes' | 'no' | null {
    return this.attributes['print-dot'];
  }
  setPrintDot(printDot: 'yes' | 'no' | null): Note {
    this.attributes['print-dot'] = printDot;
    return this;
  }
  getPrintLeger(): 'yes' | 'no' | null {
    return this.attributes['print-leger'];
  }
  setPrintLeger(printLeger: 'yes' | 'no' | null): Note {
    this.attributes['print-leger'] = printLeger;
    return this;
  }
  getPrintLyric(): 'yes' | 'no' | null {
    return this.attributes['print-lyric'];
  }
  setPrintLyric(printLyric: 'yes' | 'no' | null): Note {
    this.attributes['print-lyric'] = printLyric;
    return this;
  }
  getPrintObject(): 'yes' | 'no' | null {
    return this.attributes['print-object'];
  }
  setPrintObject(printObject: 'yes' | 'no' | null): Note {
    this.attributes['print-object'] = printObject;
    return this;
  }
  getPrintSpacing(): 'yes' | 'no' | null {
    return this.attributes['print-spacing'];
  }
  setPrintSpacing(printSpacing: 'yes' | 'no' | null): Note {
    this.attributes['print-spacing'] = printSpacing;
    return this;
  }
  getRelativeX(): number | null {
    return this.attributes['relative-x'];
  }
  setRelativeX(relativeX: number | null): Note {
    this.attributes['relative-x'] = relativeX;
    return this;
  }
  getRelativeY(): number | null {
    return this.attributes['relative-y'];
  }
  setRelativeY(relativeY: number | null): Note {
    this.attributes['relative-y'] = relativeY;
    return this;
  }
  getRelease(): number | null {
    return this.attributes['release'];
  }
  setRelease(release: number | null): Note {
    this.attributes['release'] = release;
    return this;
  }
  getTimeOnly(): string | null {
    return this.attributes['time-only'];
  }
  setTimeOnly(timeOnly: string | null): Note {
    this.attributes['time-only'] = timeOnly;
    return this;
  }
  getNoteValue(): TiedNoteValue | CuedNoteValue | TiedGraceNoteValue | CuedGraceNoteValue {
    return this.contents[0];
  }
  setNoteValue(noteValue: TiedNoteValue | CuedNoteValue | TiedGraceNoteValue | CuedGraceNoteValue): Note {
    this.contents[0] = noteValue;
    return this;
  }
  getInstruments(): Array<Instrument> {
    return this.contents[1];
  }
  setInstruments(instruments: Array<Instrument>): Note {
    this.contents[1] = instruments;
    return this;
  }
  getFootnote(): Footnote | null {
    return this.contents[2];
  }
  setFootnote(footnote: Footnote | null): Note {
    this.contents[2] = footnote;
    return this;
  }
  getLevel(): Level | null {
    return this.contents[3];
  }
  setLevel(level: Level | null): Note {
    this.contents[3] = level;
    return this;
  }
  getVoice(): Voice | null {
    return this.contents[4];
  }
  setVoice(voice: Voice | null): Note {
    this.contents[4] = voice;
    return this;
  }
  getType(): Type | null {
    return this.contents[5];
  }
  setType(type: Type | null): Note {
    this.contents[5] = type;
    return this;
  }
  getDots(): Array<Dot> {
    return this.contents[6];
  }
  setDots(dots: Array<Dot>): Note {
    this.contents[6] = dots;
    return this;
  }
  getAccidental(): Accidental | null {
    return this.contents[7];
  }
  setAccidental(accidental: Accidental | null): Note {
    this.contents[7] = accidental;
    return this;
  }
  getTimeModification(): TimeModification | null {
    return this.contents[8];
  }
  setTimeModification(timeModification: TimeModification | null): Note {
    this.contents[8] = timeModification;
    return this;
  }
  getStem(): Stem | null {
    return this.contents[9];
  }
  setStem(stem: Stem | null): Note {
    this.contents[9] = stem;
    return this;
  }
  getNotehead(): Notehead | null {
    return this.contents[10];
  }
  setNotehead(notehead: Notehead | null): Note {
    this.contents[10] = notehead;
    return this;
  }
  getNoteheadText(): NoteheadText | null {
    return this.contents[11];
  }
  setNoteheadText(noteheadText: NoteheadText | null): Note {
    this.contents[11] = noteheadText;
    return this;
  }
  getStaff(): Staff | null {
    return this.contents[12];
  }
  setStaff(staff: Staff | null): Note {
    this.contents[12] = staff;
    return this;
  }
  getBeams():
    | []
    | [Beam]
    | [Beam, Beam]
    | [Beam, Beam, Beam]
    | [Beam, Beam, Beam, Beam]
    | [Beam, Beam, Beam, Beam, Beam]
    | [Beam, Beam, Beam, Beam, Beam, Beam]
    | [Beam, Beam, Beam, Beam, Beam, Beam, Beam]
    | [Beam, Beam, Beam, Beam, Beam, Beam, Beam, Beam] {
    return this.contents[13];
  }
  setBeams(
    beams:
      | []
      | [Beam]
      | [Beam, Beam]
      | [Beam, Beam, Beam]
      | [Beam, Beam, Beam, Beam]
      | [Beam, Beam, Beam, Beam, Beam]
      | [Beam, Beam, Beam, Beam, Beam, Beam]
      | [Beam, Beam, Beam, Beam, Beam, Beam, Beam]
      | [Beam, Beam, Beam, Beam, Beam, Beam, Beam, Beam]
  ): Note {
    this.contents[13] = beams;
    return this;
  }
  getNotations(): Array<Notations> {
    return this.contents[14];
  }
  setNotations(notations: Array<Notations>): Note {
    this.contents[14] = notations;
    return this;
  }
  getLyrics(): Array<Lyric> {
    return this.contents[15];
  }
  setLyrics(lyrics: Array<Lyric>): Note {
    this.contents[15] = lyrics;
    return this;
  }
  getPlay(): Play | null {
    return this.contents[16];
  }
  setPlay(play: Play | null): Note {
    this.contents[16] = play;
    return this;
  }
  getListen(): Listen | null {
    return this.contents[17];
  }
  setListen(listen: Listen | null): Note {
    this.contents[17] = listen;
    return this;
  }
}

export type BackupAttributes = Record<string, unknown>;

export type BackupContents = [Duration, Footnote | null, Level | null];

export class Backup implements XMLElement<'backup', BackupAttributes, BackupContents> {
  static readonly schema = {
    name: 'backup',
    attributes: {},
    contents: [
      { type: 'required', value: Duration },
      { type: 'optional', value: Footnote },
      { type: 'optional', value: Level },
    ],
  } as const;

  readonly schema = Backup.schema;

  attributes: BackupAttributes;
  contents: BackupContents;

  constructor(opts?: { attributes?: Partial<BackupAttributes>; contents?: BackupContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Backup.schema);
    this.contents = opts?.contents ?? operations.zero(Backup.schema.contents);
  }

  getDuration(): Duration {
    return this.contents[0];
  }
  setDuration(duration: Duration): Backup {
    this.contents[0] = duration;
    return this;
  }
  getFootnote(): Footnote | null {
    return this.contents[1];
  }
  setFootnote(footnote: Footnote | null): Backup {
    this.contents[1] = footnote;
    return this;
  }
  getLevel(): Level | null {
    return this.contents[2];
  }
  setLevel(level: Level | null): Backup {
    this.contents[2] = level;
    return this;
  }
}

export type ForwardAttributes = Record<string, unknown>;

export type ForwardContents = [Duration, Footnote | null, Level | null, Voice | null, Staff | null];

export class Forward implements XMLElement<'forward', ForwardAttributes, ForwardContents> {
  static readonly schema = {
    name: 'forward',
    attributes: {},
    contents: [
      { type: 'required', value: Duration },
      { type: 'optional', value: Footnote },
      { type: 'optional', value: Level },
      { type: 'optional', value: Voice },
      { type: 'optional', value: Staff },
    ],
  } as const;

  readonly schema = Forward.schema;

  attributes: ForwardAttributes;
  contents: ForwardContents;

  constructor(opts?: { attributes?: Partial<ForwardAttributes>; contents?: ForwardContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Forward.schema);
    this.contents = opts?.contents ?? operations.zero(Forward.schema.contents);
  }

  getDuration(): Duration {
    return this.contents[0];
  }
  setDuration(duration: Duration): Forward {
    this.contents[0] = duration;
    return this;
  }
  getFootnote(): Footnote | null {
    return this.contents[1];
  }
  setFootnote(footnote: Footnote | null): Forward {
    this.contents[1] = footnote;
    return this;
  }
  getLevel(): Level | null {
    return this.contents[2];
  }
  setLevel(level: Level | null): Forward {
    this.contents[2] = level;
    return this;
  }
  getVoice(): Voice | null {
    return this.contents[3];
  }
  setVoice(voice: Voice | null): Forward {
    this.contents[3] = voice;
    return this;
  }
  getStaff(): Staff | null {
    return this.contents[4];
  }
  setStaff(staff: Staff | null): Forward {
    this.contents[4] = staff;
    return this;
  }
}

export type RehearsalAttributes = {
  color: string | null;
  'default-x': number | null;
  'default-y': number | null;
  dir: 'ltr' | 'rtl' | 'lro' | 'rlo' | null;
  enclosure:
    | 'none'
    | 'rectangle'
    | 'square'
    | 'oval'
    | 'circle'
    | 'bracket'
    | 'inverted-bracket'
    | 'triangle'
    | 'diamond'
    | 'pentagon'
    | 'hexagon'
    | 'heptagon'
    | 'octagon'
    | 'nonagon'
    | 'decagon'
    | null;
  'font-family': string | null;
  'font-size': 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null;
  'font-style': 'normal' | 'italic' | null;
  'font-weight': 'normal' | 'bold' | null;
  halign: 'left' | 'center' | 'right' | null;
  id: string | null;
  'letter-spacing': 'normal' | number | null;
  'line-height': 'normal' | number | null;
  'line-through': number | null;
  overline: number | null;
  'relative-x': number | null;
  'relative-y': number | null;
  rotation: number | null;
  underline: number | null;
  valign: 'top' | 'middle' | 'bottom' | 'baseline' | null;
  'xml:lang': string | null;
  'xml:space': 'default' | 'preserve' | null;
};

export type RehearsalContents = [string];

export class Rehearsal implements XMLElement<'rehearsal', RehearsalAttributes, RehearsalContents> {
  static readonly schema = {
    name: 'rehearsal',
    attributes: {
      color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
      'default-x': {
        type: 'label',
        label: 'default-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'default-y': {
        type: 'label',
        label: 'default-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      dir: { type: 'optional', value: { type: 'choices', choices: ['ltr', 'rtl', 'lro', 'rlo'] } },
      enclosure: {
        type: 'optional',
        value: {
          type: 'choices',
          choices: [
            'none',
            'rectangle',
            'square',
            'oval',
            'circle',
            'bracket',
            'inverted-bracket',
            'triangle',
            'diamond',
            'pentagon',
            'hexagon',
            'heptagon',
            'octagon',
            'nonagon',
            'decagon',
          ],
        },
      },
      'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
      'font-size': {
        type: 'optional',
        value: {
          type: 'choices',
          choices: [
            { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
            { type: 'float', min: -Infinity, max: Infinity },
          ],
        },
      },
      'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
      'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
      halign: { type: 'optional', value: { type: 'choices', choices: ['left', 'center', 'right'] } },
      id: { type: 'optional', value: { type: 'regex', pattern: /[A-Za-z_][A-Za-z0-9.-_]*/, zero: '_' } },
      'letter-spacing': {
        type: 'optional',
        value: { type: 'choices', choices: ['normal', { type: 'float', min: -Infinity, max: Infinity }] },
      },
      'line-height': {
        type: 'optional',
        value: { type: 'choices', choices: ['normal', { type: 'float', min: -Infinity, max: Infinity }] },
      },
      'line-through': { type: 'optional', value: { type: 'int', min: 0, max: 3 } },
      overline: { type: 'optional', value: { type: 'int', min: 0, max: 3 } },
      'relative-x': {
        type: 'label',
        label: 'relative-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'relative-y': {
        type: 'label',
        label: 'relative-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      rotation: { type: 'optional', value: { type: 'float', min: -180, max: 180 } },
      underline: { type: 'optional', value: { type: 'int', min: 0, max: 3 } },
      valign: { type: 'optional', value: { type: 'choices', choices: ['top', 'middle', 'bottom', 'baseline'] } },
      'xml:lang': { type: 'optional', value: { type: 'string' } },
      'xml:space': { type: 'optional', value: { type: 'choices', choices: ['default', 'preserve'] } },
    },
    contents: [{ type: 'required', value: { type: 'string' } }],
  } as const;

  readonly schema = Rehearsal.schema;

  attributes: RehearsalAttributes;
  contents: RehearsalContents;

  constructor(opts?: { attributes?: Partial<RehearsalAttributes>; contents?: RehearsalContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Rehearsal.schema);
    this.contents = opts?.contents ?? operations.zero(Rehearsal.schema.contents);
  }
  getColor(): string | null {
    return this.attributes['color'];
  }
  setColor(color: string | null): Rehearsal {
    this.attributes['color'] = color;
    return this;
  }
  getDefaultX(): number | null {
    return this.attributes['default-x'];
  }
  setDefaultX(defaultX: number | null): Rehearsal {
    this.attributes['default-x'] = defaultX;
    return this;
  }
  getDefaultY(): number | null {
    return this.attributes['default-y'];
  }
  setDefaultY(defaultY: number | null): Rehearsal {
    this.attributes['default-y'] = defaultY;
    return this;
  }
  getDir(): 'ltr' | 'rtl' | 'lro' | 'rlo' | null {
    return this.attributes['dir'];
  }
  setDir(dir: 'ltr' | 'rtl' | 'lro' | 'rlo' | null): Rehearsal {
    this.attributes['dir'] = dir;
    return this;
  }
  getEnclosure():
    | 'none'
    | 'rectangle'
    | 'square'
    | 'oval'
    | 'circle'
    | 'bracket'
    | 'inverted-bracket'
    | 'triangle'
    | 'diamond'
    | 'pentagon'
    | 'hexagon'
    | 'heptagon'
    | 'octagon'
    | 'nonagon'
    | 'decagon'
    | null {
    return this.attributes['enclosure'];
  }
  setEnclosure(
    enclosure:
      | 'none'
      | 'rectangle'
      | 'square'
      | 'oval'
      | 'circle'
      | 'bracket'
      | 'inverted-bracket'
      | 'triangle'
      | 'diamond'
      | 'pentagon'
      | 'hexagon'
      | 'heptagon'
      | 'octagon'
      | 'nonagon'
      | 'decagon'
      | null
  ): Rehearsal {
    this.attributes['enclosure'] = enclosure;
    return this;
  }
  getFontFamily(): string | null {
    return this.attributes['font-family'];
  }
  setFontFamily(fontFamily: string | null): Rehearsal {
    this.attributes['font-family'] = fontFamily;
    return this;
  }
  getFontSize(): 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null {
    return this.attributes['font-size'];
  }
  setFontSize(
    fontSize: 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null
  ): Rehearsal {
    this.attributes['font-size'] = fontSize;
    return this;
  }
  getFontStyle(): 'normal' | 'italic' | null {
    return this.attributes['font-style'];
  }
  setFontStyle(fontStyle: 'normal' | 'italic' | null): Rehearsal {
    this.attributes['font-style'] = fontStyle;
    return this;
  }
  getFontWeight(): 'normal' | 'bold' | null {
    return this.attributes['font-weight'];
  }
  setFontWeight(fontWeight: 'normal' | 'bold' | null): Rehearsal {
    this.attributes['font-weight'] = fontWeight;
    return this;
  }
  getHalign(): 'left' | 'center' | 'right' | null {
    return this.attributes['halign'];
  }
  setHalign(halign: 'left' | 'center' | 'right' | null): Rehearsal {
    this.attributes['halign'] = halign;
    return this;
  }
  getId(): string | null {
    return this.attributes['id'];
  }
  setId(id: string | null): Rehearsal {
    this.attributes['id'] = id;
    return this;
  }
  getLetterSpacing(): 'normal' | number | null {
    return this.attributes['letter-spacing'];
  }
  setLetterSpacing(letterSpacing: 'normal' | number | null): Rehearsal {
    this.attributes['letter-spacing'] = letterSpacing;
    return this;
  }
  getLineHeight(): 'normal' | number | null {
    return this.attributes['line-height'];
  }
  setLineHeight(lineHeight: 'normal' | number | null): Rehearsal {
    this.attributes['line-height'] = lineHeight;
    return this;
  }
  getLineThrough(): number | null {
    return this.attributes['line-through'];
  }
  setLineThrough(lineThrough: number | null): Rehearsal {
    this.attributes['line-through'] = lineThrough;
    return this;
  }
  getOverline(): number | null {
    return this.attributes['overline'];
  }
  setOverline(overline: number | null): Rehearsal {
    this.attributes['overline'] = overline;
    return this;
  }
  getRelativeX(): number | null {
    return this.attributes['relative-x'];
  }
  setRelativeX(relativeX: number | null): Rehearsal {
    this.attributes['relative-x'] = relativeX;
    return this;
  }
  getRelativeY(): number | null {
    return this.attributes['relative-y'];
  }
  setRelativeY(relativeY: number | null): Rehearsal {
    this.attributes['relative-y'] = relativeY;
    return this;
  }
  getRotation(): number | null {
    return this.attributes['rotation'];
  }
  setRotation(rotation: number | null): Rehearsal {
    this.attributes['rotation'] = rotation;
    return this;
  }
  getUnderline(): number | null {
    return this.attributes['underline'];
  }
  setUnderline(underline: number | null): Rehearsal {
    this.attributes['underline'] = underline;
    return this;
  }
  getValign(): 'top' | 'middle' | 'bottom' | 'baseline' | null {
    return this.attributes['valign'];
  }
  setValign(valign: 'top' | 'middle' | 'bottom' | 'baseline' | null): Rehearsal {
    this.attributes['valign'] = valign;
    return this;
  }
  getXmlLang(): string | null {
    return this.attributes['xml:lang'];
  }
  setXmlLang(xmlLang: string | null): Rehearsal {
    this.attributes['xml:lang'] = xmlLang;
    return this;
  }
  getXmlSpace(): 'default' | 'preserve' | null {
    return this.attributes['xml:space'];
  }
  setXmlSpace(xmlSpace: 'default' | 'preserve' | null): Rehearsal {
    this.attributes['xml:space'] = xmlSpace;
    return this;
  }
  getText(): string {
    return this.contents[0];
  }
  setText(text: string): Rehearsal {
    this.contents[0] = text;
    return this;
  }
}

export type SegnoAttributes = {
  color: string | null;
  'default-x': number | null;
  'default-y': number | null;
  'font-family': string | null;
  'font-size': 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null;
  'font-style': 'normal' | 'italic' | null;
  'font-weight': 'normal' | 'bold' | null;
  halign: 'left' | 'center' | 'right' | null;
  id: string | null;
  'relative-x': number | null;
  'relative-y': number | null;
  smufl: string | null;
  valign: 'top' | 'middle' | 'bottom' | 'baseline' | null;
};

export type SegnoContents = [];

export class Segno implements XMLElement<'segno', SegnoAttributes, SegnoContents> {
  static readonly schema = {
    name: 'segno',
    attributes: {
      color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
      'default-x': {
        type: 'label',
        label: 'default-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'default-y': {
        type: 'label',
        label: 'default-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
      'font-size': {
        type: 'optional',
        value: {
          type: 'choices',
          choices: [
            { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
            { type: 'float', min: -Infinity, max: Infinity },
          ],
        },
      },
      'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
      'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
      halign: { type: 'optional', value: { type: 'choices', choices: ['left', 'center', 'right'] } },
      id: { type: 'optional', value: { type: 'regex', pattern: /[A-Za-z_][A-Za-z0-9.-_]*/, zero: '_' } },
      'relative-x': {
        type: 'label',
        label: 'relative-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'relative-y': {
        type: 'label',
        label: 'relative-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      smufl: {
        type: 'optional',
        value: { type: 'regex', pattern: /(acc|medRenFla|medRenNatura|medRenShar|kievanAccidental)/, zero: 'acc' },
      },
      valign: { type: 'optional', value: { type: 'choices', choices: ['top', 'middle', 'bottom', 'baseline'] } },
    },
    contents: [],
  } as const;

  readonly schema = Segno.schema;

  attributes: SegnoAttributes;
  contents: SegnoContents;

  constructor(opts?: { attributes?: Partial<SegnoAttributes>; contents?: SegnoContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Segno.schema);
    this.contents = opts?.contents ?? operations.zero(Segno.schema.contents);
  }
  getColor(): string | null {
    return this.attributes['color'];
  }
  setColor(color: string | null): Segno {
    this.attributes['color'] = color;
    return this;
  }
  getDefaultX(): number | null {
    return this.attributes['default-x'];
  }
  setDefaultX(defaultX: number | null): Segno {
    this.attributes['default-x'] = defaultX;
    return this;
  }
  getDefaultY(): number | null {
    return this.attributes['default-y'];
  }
  setDefaultY(defaultY: number | null): Segno {
    this.attributes['default-y'] = defaultY;
    return this;
  }
  getFontFamily(): string | null {
    return this.attributes['font-family'];
  }
  setFontFamily(fontFamily: string | null): Segno {
    this.attributes['font-family'] = fontFamily;
    return this;
  }
  getFontSize(): 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null {
    return this.attributes['font-size'];
  }
  setFontSize(
    fontSize: 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null
  ): Segno {
    this.attributes['font-size'] = fontSize;
    return this;
  }
  getFontStyle(): 'normal' | 'italic' | null {
    return this.attributes['font-style'];
  }
  setFontStyle(fontStyle: 'normal' | 'italic' | null): Segno {
    this.attributes['font-style'] = fontStyle;
    return this;
  }
  getFontWeight(): 'normal' | 'bold' | null {
    return this.attributes['font-weight'];
  }
  setFontWeight(fontWeight: 'normal' | 'bold' | null): Segno {
    this.attributes['font-weight'] = fontWeight;
    return this;
  }
  getHalign(): 'left' | 'center' | 'right' | null {
    return this.attributes['halign'];
  }
  setHalign(halign: 'left' | 'center' | 'right' | null): Segno {
    this.attributes['halign'] = halign;
    return this;
  }
  getId(): string | null {
    return this.attributes['id'];
  }
  setId(id: string | null): Segno {
    this.attributes['id'] = id;
    return this;
  }
  getRelativeX(): number | null {
    return this.attributes['relative-x'];
  }
  setRelativeX(relativeX: number | null): Segno {
    this.attributes['relative-x'] = relativeX;
    return this;
  }
  getRelativeY(): number | null {
    return this.attributes['relative-y'];
  }
  setRelativeY(relativeY: number | null): Segno {
    this.attributes['relative-y'] = relativeY;
    return this;
  }
  getSmufl(): string | null {
    return this.attributes['smufl'];
  }
  setSmufl(smufl: string | null): Segno {
    this.attributes['smufl'] = smufl;
    return this;
  }
  getValign(): 'top' | 'middle' | 'bottom' | 'baseline' | null {
    return this.attributes['valign'];
  }
  setValign(valign: 'top' | 'middle' | 'bottom' | 'baseline' | null): Segno {
    this.attributes['valign'] = valign;
    return this;
  }
}

export type CodaAttributes = {
  color: string | null;
  'default-x': number | null;
  'default-y': number | null;
  'font-family': string | null;
  'font-size': 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null;
  'font-style': 'normal' | 'italic' | null;
  'font-weight': 'normal' | 'bold' | null;
  halign: 'left' | 'center' | 'right' | null;
  id: string | null;
  'relative-x': number | null;
  'relative-y': number | null;
  smufl: string | null;
  valign: 'top' | 'middle' | 'bottom' | 'baseline' | null;
};

export type CodaContents = [];

export class Coda implements XMLElement<'coda', CodaAttributes, CodaContents> {
  static readonly schema = {
    name: 'coda',
    attributes: {
      color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
      'default-x': {
        type: 'label',
        label: 'default-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'default-y': {
        type: 'label',
        label: 'default-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
      'font-size': {
        type: 'optional',
        value: {
          type: 'choices',
          choices: [
            { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
            { type: 'float', min: -Infinity, max: Infinity },
          ],
        },
      },
      'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
      'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
      halign: { type: 'optional', value: { type: 'choices', choices: ['left', 'center', 'right'] } },
      id: { type: 'optional', value: { type: 'regex', pattern: /[A-Za-z_][A-Za-z0-9.-_]*/, zero: '_' } },
      'relative-x': {
        type: 'label',
        label: 'relative-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'relative-y': {
        type: 'label',
        label: 'relative-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      smufl: {
        type: 'optional',
        value: { type: 'regex', pattern: /(acc|medRenFla|medRenNatura|medRenShar|kievanAccidental)/, zero: 'acc' },
      },
      valign: { type: 'optional', value: { type: 'choices', choices: ['top', 'middle', 'bottom', 'baseline'] } },
    },
    contents: [],
  } as const;

  readonly schema = Coda.schema;

  attributes: CodaAttributes;
  contents: CodaContents;

  constructor(opts?: { attributes?: Partial<CodaAttributes>; contents?: CodaContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Coda.schema);
    this.contents = opts?.contents ?? operations.zero(Coda.schema.contents);
  }
  getColor(): string | null {
    return this.attributes['color'];
  }
  setColor(color: string | null): Coda {
    this.attributes['color'] = color;
    return this;
  }
  getDefaultX(): number | null {
    return this.attributes['default-x'];
  }
  setDefaultX(defaultX: number | null): Coda {
    this.attributes['default-x'] = defaultX;
    return this;
  }
  getDefaultY(): number | null {
    return this.attributes['default-y'];
  }
  setDefaultY(defaultY: number | null): Coda {
    this.attributes['default-y'] = defaultY;
    return this;
  }
  getFontFamily(): string | null {
    return this.attributes['font-family'];
  }
  setFontFamily(fontFamily: string | null): Coda {
    this.attributes['font-family'] = fontFamily;
    return this;
  }
  getFontSize(): 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null {
    return this.attributes['font-size'];
  }
  setFontSize(
    fontSize: 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null
  ): Coda {
    this.attributes['font-size'] = fontSize;
    return this;
  }
  getFontStyle(): 'normal' | 'italic' | null {
    return this.attributes['font-style'];
  }
  setFontStyle(fontStyle: 'normal' | 'italic' | null): Coda {
    this.attributes['font-style'] = fontStyle;
    return this;
  }
  getFontWeight(): 'normal' | 'bold' | null {
    return this.attributes['font-weight'];
  }
  setFontWeight(fontWeight: 'normal' | 'bold' | null): Coda {
    this.attributes['font-weight'] = fontWeight;
    return this;
  }
  getHalign(): 'left' | 'center' | 'right' | null {
    return this.attributes['halign'];
  }
  setHalign(halign: 'left' | 'center' | 'right' | null): Coda {
    this.attributes['halign'] = halign;
    return this;
  }
  getId(): string | null {
    return this.attributes['id'];
  }
  setId(id: string | null): Coda {
    this.attributes['id'] = id;
    return this;
  }
  getRelativeX(): number | null {
    return this.attributes['relative-x'];
  }
  setRelativeX(relativeX: number | null): Coda {
    this.attributes['relative-x'] = relativeX;
    return this;
  }
  getRelativeY(): number | null {
    return this.attributes['relative-y'];
  }
  setRelativeY(relativeY: number | null): Coda {
    this.attributes['relative-y'] = relativeY;
    return this;
  }
  getSmufl(): string | null {
    return this.attributes['smufl'];
  }
  setSmufl(smufl: string | null): Coda {
    this.attributes['smufl'] = smufl;
    return this;
  }
  getValign(): 'top' | 'middle' | 'bottom' | 'baseline' | null {
    return this.attributes['valign'];
  }
  setValign(valign: 'top' | 'middle' | 'bottom' | 'baseline' | null): Coda {
    this.attributes['valign'] = valign;
    return this;
  }
}

export type WordsAttributes = {
  color: string | null;
  'default-x': number | null;
  'default-y': number | null;
  dir: 'ltr' | 'rtl' | 'lro' | 'rlo' | null;
  enclosure:
    | 'none'
    | 'rectangle'
    | 'square'
    | 'oval'
    | 'circle'
    | 'bracket'
    | 'inverted-bracket'
    | 'triangle'
    | 'diamond'
    | 'pentagon'
    | 'hexagon'
    | 'heptagon'
    | 'octagon'
    | 'nonagon'
    | 'decagon'
    | null;
  'font-family': string | null;
  'font-size': 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null;
  'font-style': 'normal' | 'italic' | null;
  'font-weight': 'normal' | 'bold' | null;
  halign: 'left' | 'center' | 'right' | null;
  id: string | null;
  justify: 'left' | 'center' | 'right' | null;
  'letter-spacing': 'normal' | number | null;
  'line-height': 'normal' | number | null;
  'line-through': number | null;
  overline: number | null;
  'relative-x': number | null;
  'relative-y': number | null;
  rotation: number | null;
  underline: number | null;
  valign: 'top' | 'middle' | 'bottom' | 'baseline' | null;
  'xml:lang': string | null;
  'xml:space': 'default' | 'preserve' | null;
};

export type WordsContents = [string];

export class Words implements XMLElement<'words', WordsAttributes, WordsContents> {
  static readonly schema = {
    name: 'words',
    attributes: {
      color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
      'default-x': {
        type: 'label',
        label: 'default-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'default-y': {
        type: 'label',
        label: 'default-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      dir: { type: 'optional', value: { type: 'choices', choices: ['ltr', 'rtl', 'lro', 'rlo'] } },
      enclosure: {
        type: 'optional',
        value: {
          type: 'choices',
          choices: [
            'none',
            'rectangle',
            'square',
            'oval',
            'circle',
            'bracket',
            'inverted-bracket',
            'triangle',
            'diamond',
            'pentagon',
            'hexagon',
            'heptagon',
            'octagon',
            'nonagon',
            'decagon',
          ],
        },
      },
      'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
      'font-size': {
        type: 'optional',
        value: {
          type: 'choices',
          choices: [
            { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
            { type: 'float', min: -Infinity, max: Infinity },
          ],
        },
      },
      'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
      'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
      halign: { type: 'optional', value: { type: 'choices', choices: ['left', 'center', 'right'] } },
      id: { type: 'optional', value: { type: 'regex', pattern: /[A-Za-z_][A-Za-z0-9.-_]*/, zero: '_' } },
      justify: { type: 'optional', value: { type: 'choices', choices: ['left', 'center', 'right'] } },
      'letter-spacing': {
        type: 'optional',
        value: { type: 'choices', choices: ['normal', { type: 'float', min: -Infinity, max: Infinity }] },
      },
      'line-height': {
        type: 'optional',
        value: { type: 'choices', choices: ['normal', { type: 'float', min: -Infinity, max: Infinity }] },
      },
      'line-through': { type: 'optional', value: { type: 'int', min: 0, max: 3 } },
      overline: { type: 'optional', value: { type: 'int', min: 0, max: 3 } },
      'relative-x': {
        type: 'label',
        label: 'relative-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'relative-y': {
        type: 'label',
        label: 'relative-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      rotation: { type: 'optional', value: { type: 'float', min: -180, max: 180 } },
      underline: { type: 'optional', value: { type: 'int', min: 0, max: 3 } },
      valign: { type: 'optional', value: { type: 'choices', choices: ['top', 'middle', 'bottom', 'baseline'] } },
      'xml:lang': { type: 'optional', value: { type: 'string' } },
      'xml:space': { type: 'optional', value: { type: 'choices', choices: ['default', 'preserve'] } },
    },
    contents: [{ type: 'required', value: { type: 'string' } }],
  } as const;

  readonly schema = Words.schema;

  attributes: WordsAttributes;
  contents: WordsContents;

  constructor(opts?: { attributes?: Partial<WordsAttributes>; contents?: WordsContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Words.schema);
    this.contents = opts?.contents ?? operations.zero(Words.schema.contents);
  }
  getColor(): string | null {
    return this.attributes['color'];
  }
  setColor(color: string | null): Words {
    this.attributes['color'] = color;
    return this;
  }
  getDefaultX(): number | null {
    return this.attributes['default-x'];
  }
  setDefaultX(defaultX: number | null): Words {
    this.attributes['default-x'] = defaultX;
    return this;
  }
  getDefaultY(): number | null {
    return this.attributes['default-y'];
  }
  setDefaultY(defaultY: number | null): Words {
    this.attributes['default-y'] = defaultY;
    return this;
  }
  getDir(): 'ltr' | 'rtl' | 'lro' | 'rlo' | null {
    return this.attributes['dir'];
  }
  setDir(dir: 'ltr' | 'rtl' | 'lro' | 'rlo' | null): Words {
    this.attributes['dir'] = dir;
    return this;
  }
  getEnclosure():
    | 'none'
    | 'rectangle'
    | 'square'
    | 'oval'
    | 'circle'
    | 'bracket'
    | 'inverted-bracket'
    | 'triangle'
    | 'diamond'
    | 'pentagon'
    | 'hexagon'
    | 'heptagon'
    | 'octagon'
    | 'nonagon'
    | 'decagon'
    | null {
    return this.attributes['enclosure'];
  }
  setEnclosure(
    enclosure:
      | 'none'
      | 'rectangle'
      | 'square'
      | 'oval'
      | 'circle'
      | 'bracket'
      | 'inverted-bracket'
      | 'triangle'
      | 'diamond'
      | 'pentagon'
      | 'hexagon'
      | 'heptagon'
      | 'octagon'
      | 'nonagon'
      | 'decagon'
      | null
  ): Words {
    this.attributes['enclosure'] = enclosure;
    return this;
  }
  getFontFamily(): string | null {
    return this.attributes['font-family'];
  }
  setFontFamily(fontFamily: string | null): Words {
    this.attributes['font-family'] = fontFamily;
    return this;
  }
  getFontSize(): 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null {
    return this.attributes['font-size'];
  }
  setFontSize(
    fontSize: 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null
  ): Words {
    this.attributes['font-size'] = fontSize;
    return this;
  }
  getFontStyle(): 'normal' | 'italic' | null {
    return this.attributes['font-style'];
  }
  setFontStyle(fontStyle: 'normal' | 'italic' | null): Words {
    this.attributes['font-style'] = fontStyle;
    return this;
  }
  getFontWeight(): 'normal' | 'bold' | null {
    return this.attributes['font-weight'];
  }
  setFontWeight(fontWeight: 'normal' | 'bold' | null): Words {
    this.attributes['font-weight'] = fontWeight;
    return this;
  }
  getHalign(): 'left' | 'center' | 'right' | null {
    return this.attributes['halign'];
  }
  setHalign(halign: 'left' | 'center' | 'right' | null): Words {
    this.attributes['halign'] = halign;
    return this;
  }
  getId(): string | null {
    return this.attributes['id'];
  }
  setId(id: string | null): Words {
    this.attributes['id'] = id;
    return this;
  }
  getJustify(): 'left' | 'center' | 'right' | null {
    return this.attributes['justify'];
  }
  setJustify(justify: 'left' | 'center' | 'right' | null): Words {
    this.attributes['justify'] = justify;
    return this;
  }
  getLetterSpacing(): 'normal' | number | null {
    return this.attributes['letter-spacing'];
  }
  setLetterSpacing(letterSpacing: 'normal' | number | null): Words {
    this.attributes['letter-spacing'] = letterSpacing;
    return this;
  }
  getLineHeight(): 'normal' | number | null {
    return this.attributes['line-height'];
  }
  setLineHeight(lineHeight: 'normal' | number | null): Words {
    this.attributes['line-height'] = lineHeight;
    return this;
  }
  getLineThrough(): number | null {
    return this.attributes['line-through'];
  }
  setLineThrough(lineThrough: number | null): Words {
    this.attributes['line-through'] = lineThrough;
    return this;
  }
  getOverline(): number | null {
    return this.attributes['overline'];
  }
  setOverline(overline: number | null): Words {
    this.attributes['overline'] = overline;
    return this;
  }
  getRelativeX(): number | null {
    return this.attributes['relative-x'];
  }
  setRelativeX(relativeX: number | null): Words {
    this.attributes['relative-x'] = relativeX;
    return this;
  }
  getRelativeY(): number | null {
    return this.attributes['relative-y'];
  }
  setRelativeY(relativeY: number | null): Words {
    this.attributes['relative-y'] = relativeY;
    return this;
  }
  getRotation(): number | null {
    return this.attributes['rotation'];
  }
  setRotation(rotation: number | null): Words {
    this.attributes['rotation'] = rotation;
    return this;
  }
  getUnderline(): number | null {
    return this.attributes['underline'];
  }
  setUnderline(underline: number | null): Words {
    this.attributes['underline'] = underline;
    return this;
  }
  getValign(): 'top' | 'middle' | 'bottom' | 'baseline' | null {
    return this.attributes['valign'];
  }
  setValign(valign: 'top' | 'middle' | 'bottom' | 'baseline' | null): Words {
    this.attributes['valign'] = valign;
    return this;
  }
  getXmlLang(): string | null {
    return this.attributes['xml:lang'];
  }
  setXmlLang(xmlLang: string | null): Words {
    this.attributes['xml:lang'] = xmlLang;
    return this;
  }
  getXmlSpace(): 'default' | 'preserve' | null {
    return this.attributes['xml:space'];
  }
  setXmlSpace(xmlSpace: 'default' | 'preserve' | null): Words {
    this.attributes['xml:space'] = xmlSpace;
    return this;
  }
  getText(): string {
    return this.contents[0];
  }
  setText(text: string): Words {
    this.contents[0] = text;
    return this;
  }
}

export type SymbolAttributes = {
  color: string | null;
  'default-x': number | null;
  'default-y': number | null;
  dir: 'ltr' | 'rtl' | 'lro' | 'rlo' | null;
  enclosure:
    | 'none'
    | 'rectangle'
    | 'square'
    | 'oval'
    | 'circle'
    | 'bracket'
    | 'inverted-bracket'
    | 'triangle'
    | 'diamond'
    | 'pentagon'
    | 'hexagon'
    | 'heptagon'
    | 'octagon'
    | 'nonagon'
    | 'decagon'
    | null;
  'font-family': string | null;
  'font-size': 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null;
  'font-style': 'normal' | 'italic' | null;
  'font-weight': 'normal' | 'bold' | null;
  halign: 'left' | 'center' | 'right' | null;
  id: string | null;
  justify: 'left' | 'center' | 'right' | null;
  'letter-spacing': 'normal' | number | null;
  'line-height': 'normal' | number | null;
  'line-through': number | null;
  overline: number | null;
  'relative-x': number | null;
  'relative-y': number | null;
  rotation: number | null;
  underline: number | null;
  valign: 'top' | 'middle' | 'bottom' | 'baseline' | null;
};

export type SymbolContents = [];

export class Symbol implements XMLElement<'symbol', SymbolAttributes, SymbolContents> {
  static readonly schema = {
    name: 'symbol',
    attributes: {
      color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
      'default-x': {
        type: 'label',
        label: 'default-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'default-y': {
        type: 'label',
        label: 'default-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      dir: { type: 'optional', value: { type: 'choices', choices: ['ltr', 'rtl', 'lro', 'rlo'] } },
      enclosure: {
        type: 'optional',
        value: {
          type: 'choices',
          choices: [
            'none',
            'rectangle',
            'square',
            'oval',
            'circle',
            'bracket',
            'inverted-bracket',
            'triangle',
            'diamond',
            'pentagon',
            'hexagon',
            'heptagon',
            'octagon',
            'nonagon',
            'decagon',
          ],
        },
      },
      'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
      'font-size': {
        type: 'optional',
        value: {
          type: 'choices',
          choices: [
            { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
            { type: 'float', min: -Infinity, max: Infinity },
          ],
        },
      },
      'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
      'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
      halign: { type: 'optional', value: { type: 'choices', choices: ['left', 'center', 'right'] } },
      id: { type: 'optional', value: { type: 'regex', pattern: /[A-Za-z_][A-Za-z0-9.-_]*/, zero: '_' } },
      justify: { type: 'optional', value: { type: 'choices', choices: ['left', 'center', 'right'] } },
      'letter-spacing': {
        type: 'optional',
        value: { type: 'choices', choices: ['normal', { type: 'float', min: -Infinity, max: Infinity }] },
      },
      'line-height': {
        type: 'optional',
        value: { type: 'choices', choices: ['normal', { type: 'float', min: -Infinity, max: Infinity }] },
      },
      'line-through': { type: 'optional', value: { type: 'int', min: 0, max: 3 } },
      overline: { type: 'optional', value: { type: 'int', min: 0, max: 3 } },
      'relative-x': {
        type: 'label',
        label: 'relative-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'relative-y': {
        type: 'label',
        label: 'relative-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      rotation: { type: 'optional', value: { type: 'float', min: -180, max: 180 } },
      underline: { type: 'optional', value: { type: 'int', min: 0, max: 3 } },
      valign: { type: 'optional', value: { type: 'choices', choices: ['top', 'middle', 'bottom', 'baseline'] } },
    },
    contents: [],
  } as const;

  readonly schema = Symbol.schema;

  attributes: SymbolAttributes;
  contents: SymbolContents;

  constructor(opts?: { attributes?: Partial<SymbolAttributes>; contents?: SymbolContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Symbol.schema);
    this.contents = opts?.contents ?? operations.zero(Symbol.schema.contents);
  }
  getColor(): string | null {
    return this.attributes['color'];
  }
  setColor(color: string | null): Symbol {
    this.attributes['color'] = color;
    return this;
  }
  getDefaultX(): number | null {
    return this.attributes['default-x'];
  }
  setDefaultX(defaultX: number | null): Symbol {
    this.attributes['default-x'] = defaultX;
    return this;
  }
  getDefaultY(): number | null {
    return this.attributes['default-y'];
  }
  setDefaultY(defaultY: number | null): Symbol {
    this.attributes['default-y'] = defaultY;
    return this;
  }
  getDir(): 'ltr' | 'rtl' | 'lro' | 'rlo' | null {
    return this.attributes['dir'];
  }
  setDir(dir: 'ltr' | 'rtl' | 'lro' | 'rlo' | null): Symbol {
    this.attributes['dir'] = dir;
    return this;
  }
  getEnclosure():
    | 'none'
    | 'rectangle'
    | 'square'
    | 'oval'
    | 'circle'
    | 'bracket'
    | 'inverted-bracket'
    | 'triangle'
    | 'diamond'
    | 'pentagon'
    | 'hexagon'
    | 'heptagon'
    | 'octagon'
    | 'nonagon'
    | 'decagon'
    | null {
    return this.attributes['enclosure'];
  }
  setEnclosure(
    enclosure:
      | 'none'
      | 'rectangle'
      | 'square'
      | 'oval'
      | 'circle'
      | 'bracket'
      | 'inverted-bracket'
      | 'triangle'
      | 'diamond'
      | 'pentagon'
      | 'hexagon'
      | 'heptagon'
      | 'octagon'
      | 'nonagon'
      | 'decagon'
      | null
  ): Symbol {
    this.attributes['enclosure'] = enclosure;
    return this;
  }
  getFontFamily(): string | null {
    return this.attributes['font-family'];
  }
  setFontFamily(fontFamily: string | null): Symbol {
    this.attributes['font-family'] = fontFamily;
    return this;
  }
  getFontSize(): 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null {
    return this.attributes['font-size'];
  }
  setFontSize(
    fontSize: 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null
  ): Symbol {
    this.attributes['font-size'] = fontSize;
    return this;
  }
  getFontStyle(): 'normal' | 'italic' | null {
    return this.attributes['font-style'];
  }
  setFontStyle(fontStyle: 'normal' | 'italic' | null): Symbol {
    this.attributes['font-style'] = fontStyle;
    return this;
  }
  getFontWeight(): 'normal' | 'bold' | null {
    return this.attributes['font-weight'];
  }
  setFontWeight(fontWeight: 'normal' | 'bold' | null): Symbol {
    this.attributes['font-weight'] = fontWeight;
    return this;
  }
  getHalign(): 'left' | 'center' | 'right' | null {
    return this.attributes['halign'];
  }
  setHalign(halign: 'left' | 'center' | 'right' | null): Symbol {
    this.attributes['halign'] = halign;
    return this;
  }
  getId(): string | null {
    return this.attributes['id'];
  }
  setId(id: string | null): Symbol {
    this.attributes['id'] = id;
    return this;
  }
  getJustify(): 'left' | 'center' | 'right' | null {
    return this.attributes['justify'];
  }
  setJustify(justify: 'left' | 'center' | 'right' | null): Symbol {
    this.attributes['justify'] = justify;
    return this;
  }
  getLetterSpacing(): 'normal' | number | null {
    return this.attributes['letter-spacing'];
  }
  setLetterSpacing(letterSpacing: 'normal' | number | null): Symbol {
    this.attributes['letter-spacing'] = letterSpacing;
    return this;
  }
  getLineHeight(): 'normal' | number | null {
    return this.attributes['line-height'];
  }
  setLineHeight(lineHeight: 'normal' | number | null): Symbol {
    this.attributes['line-height'] = lineHeight;
    return this;
  }
  getLineThrough(): number | null {
    return this.attributes['line-through'];
  }
  setLineThrough(lineThrough: number | null): Symbol {
    this.attributes['line-through'] = lineThrough;
    return this;
  }
  getOverline(): number | null {
    return this.attributes['overline'];
  }
  setOverline(overline: number | null): Symbol {
    this.attributes['overline'] = overline;
    return this;
  }
  getRelativeX(): number | null {
    return this.attributes['relative-x'];
  }
  setRelativeX(relativeX: number | null): Symbol {
    this.attributes['relative-x'] = relativeX;
    return this;
  }
  getRelativeY(): number | null {
    return this.attributes['relative-y'];
  }
  setRelativeY(relativeY: number | null): Symbol {
    this.attributes['relative-y'] = relativeY;
    return this;
  }
  getRotation(): number | null {
    return this.attributes['rotation'];
  }
  setRotation(rotation: number | null): Symbol {
    this.attributes['rotation'] = rotation;
    return this;
  }
  getUnderline(): number | null {
    return this.attributes['underline'];
  }
  setUnderline(underline: number | null): Symbol {
    this.attributes['underline'] = underline;
    return this;
  }
  getValign(): 'top' | 'middle' | 'bottom' | 'baseline' | null {
    return this.attributes['valign'];
  }
  setValign(valign: 'top' | 'middle' | 'bottom' | 'baseline' | null): Symbol {
    this.attributes['valign'] = valign;
    return this;
  }
}

export type WedgeAttributes = {
  type: 'crescendo' | 'diminuendo' | 'stop' | 'continue';
  color: string | null;
  'dash-length': number | null;
  'default-x': number | null;
  'default-y': number | null;
  id: string | null;
  'line-type': 'dashed' | 'dotted' | 'solid' | 'wavy' | null;
  niente: 'yes' | 'no' | null;
  number: number | null;
  'relative-x': number | null;
  'relative-y': number | null;
  'space-length': number | null;
  spread: number | null;
};

export type WedgeContents = [];

export class Wedge implements XMLElement<'wedge', WedgeAttributes, WedgeContents> {
  static readonly schema = {
    name: 'wedge',
    attributes: {
      type: { type: 'required', value: { type: 'choices', choices: ['crescendo', 'diminuendo', 'stop', 'continue'] } },
      color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
      'dash-length': { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      'default-x': {
        type: 'label',
        label: 'default-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'default-y': {
        type: 'label',
        label: 'default-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      id: { type: 'optional', value: { type: 'regex', pattern: /[A-Za-z_][A-Za-z0-9.-_]*/, zero: '_' } },
      'line-type': { type: 'optional', value: { type: 'choices', choices: ['dashed', 'dotted', 'solid', 'wavy'] } },
      niente: { type: 'optional', value: { type: 'choices', choices: ['yes', 'no'] } },
      number: { type: 'optional', value: { type: 'int', min: 1, max: 16 } },
      'relative-x': {
        type: 'label',
        label: 'relative-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'relative-y': {
        type: 'label',
        label: 'relative-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'space-length': { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      spread: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
    },
    contents: [],
  } as const;

  readonly schema = Wedge.schema;

  attributes: WedgeAttributes;
  contents: WedgeContents;

  constructor(opts?: { attributes?: Partial<WedgeAttributes>; contents?: WedgeContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Wedge.schema);
    this.contents = opts?.contents ?? operations.zero(Wedge.schema.contents);
  }
  getType(): 'crescendo' | 'diminuendo' | 'stop' | 'continue' {
    return this.attributes['type'];
  }
  setType(type: 'crescendo' | 'diminuendo' | 'stop' | 'continue'): Wedge {
    this.attributes['type'] = type;
    return this;
  }
  getColor(): string | null {
    return this.attributes['color'];
  }
  setColor(color: string | null): Wedge {
    this.attributes['color'] = color;
    return this;
  }
  getDashLength(): number | null {
    return this.attributes['dash-length'];
  }
  setDashLength(dashLength: number | null): Wedge {
    this.attributes['dash-length'] = dashLength;
    return this;
  }
  getDefaultX(): number | null {
    return this.attributes['default-x'];
  }
  setDefaultX(defaultX: number | null): Wedge {
    this.attributes['default-x'] = defaultX;
    return this;
  }
  getDefaultY(): number | null {
    return this.attributes['default-y'];
  }
  setDefaultY(defaultY: number | null): Wedge {
    this.attributes['default-y'] = defaultY;
    return this;
  }
  getId(): string | null {
    return this.attributes['id'];
  }
  setId(id: string | null): Wedge {
    this.attributes['id'] = id;
    return this;
  }
  getLineType(): 'dashed' | 'dotted' | 'solid' | 'wavy' | null {
    return this.attributes['line-type'];
  }
  setLineType(lineType: 'dashed' | 'dotted' | 'solid' | 'wavy' | null): Wedge {
    this.attributes['line-type'] = lineType;
    return this;
  }
  getNiente(): 'yes' | 'no' | null {
    return this.attributes['niente'];
  }
  setNiente(niente: 'yes' | 'no' | null): Wedge {
    this.attributes['niente'] = niente;
    return this;
  }
  getNumber(): number | null {
    return this.attributes['number'];
  }
  setNumber(number: number | null): Wedge {
    this.attributes['number'] = number;
    return this;
  }
  getRelativeX(): number | null {
    return this.attributes['relative-x'];
  }
  setRelativeX(relativeX: number | null): Wedge {
    this.attributes['relative-x'] = relativeX;
    return this;
  }
  getRelativeY(): number | null {
    return this.attributes['relative-y'];
  }
  setRelativeY(relativeY: number | null): Wedge {
    this.attributes['relative-y'] = relativeY;
    return this;
  }
  getSpaceLength(): number | null {
    return this.attributes['space-length'];
  }
  setSpaceLength(spaceLength: number | null): Wedge {
    this.attributes['space-length'] = spaceLength;
    return this;
  }
  getSpread(): number | null {
    return this.attributes['spread'];
  }
  setSpread(spread: number | null): Wedge {
    this.attributes['spread'] = spread;
    return this;
  }
}

export type DashesAttributes = {
  type: 'start' | 'stop' | 'continue';
  color: string | null;
  'dash-length': number | null;
  'default-x': number | null;
  'default-y': number | null;
  id: string | null;
  number: number | null;
  'relative-x': number | null;
  'relative-y': number | null;
  'space-length': number | null;
};

export type DashesContents = [];

export class Dashes implements XMLElement<'dashes', DashesAttributes, DashesContents> {
  static readonly schema = {
    name: 'dashes',
    attributes: {
      type: { type: 'required', value: { type: 'choices', choices: ['start', 'stop', 'continue'] } },
      color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
      'dash-length': { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      'default-x': {
        type: 'label',
        label: 'default-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'default-y': {
        type: 'label',
        label: 'default-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      id: { type: 'optional', value: { type: 'regex', pattern: /[A-Za-z_][A-Za-z0-9.-_]*/, zero: '_' } },
      number: { type: 'optional', value: { type: 'int', min: 1, max: 16 } },
      'relative-x': {
        type: 'label',
        label: 'relative-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'relative-y': {
        type: 'label',
        label: 'relative-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'space-length': { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
    },
    contents: [],
  } as const;

  readonly schema = Dashes.schema;

  attributes: DashesAttributes;
  contents: DashesContents;

  constructor(opts?: { attributes?: Partial<DashesAttributes>; contents?: DashesContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Dashes.schema);
    this.contents = opts?.contents ?? operations.zero(Dashes.schema.contents);
  }
  getType(): 'start' | 'stop' | 'continue' {
    return this.attributes['type'];
  }
  setType(type: 'start' | 'stop' | 'continue'): Dashes {
    this.attributes['type'] = type;
    return this;
  }
  getColor(): string | null {
    return this.attributes['color'];
  }
  setColor(color: string | null): Dashes {
    this.attributes['color'] = color;
    return this;
  }
  getDashLength(): number | null {
    return this.attributes['dash-length'];
  }
  setDashLength(dashLength: number | null): Dashes {
    this.attributes['dash-length'] = dashLength;
    return this;
  }
  getDefaultX(): number | null {
    return this.attributes['default-x'];
  }
  setDefaultX(defaultX: number | null): Dashes {
    this.attributes['default-x'] = defaultX;
    return this;
  }
  getDefaultY(): number | null {
    return this.attributes['default-y'];
  }
  setDefaultY(defaultY: number | null): Dashes {
    this.attributes['default-y'] = defaultY;
    return this;
  }
  getId(): string | null {
    return this.attributes['id'];
  }
  setId(id: string | null): Dashes {
    this.attributes['id'] = id;
    return this;
  }
  getNumber(): number | null {
    return this.attributes['number'];
  }
  setNumber(number: number | null): Dashes {
    this.attributes['number'] = number;
    return this;
  }
  getRelativeX(): number | null {
    return this.attributes['relative-x'];
  }
  setRelativeX(relativeX: number | null): Dashes {
    this.attributes['relative-x'] = relativeX;
    return this;
  }
  getRelativeY(): number | null {
    return this.attributes['relative-y'];
  }
  setRelativeY(relativeY: number | null): Dashes {
    this.attributes['relative-y'] = relativeY;
    return this;
  }
  getSpaceLength(): number | null {
    return this.attributes['space-length'];
  }
  setSpaceLength(spaceLength: number | null): Dashes {
    this.attributes['space-length'] = spaceLength;
    return this;
  }
}

export type BracketAttributes = {
  'line-end': 'none' | 'up' | 'down' | 'both' | 'arrow';
  type: 'start' | 'stop' | 'continue';
  color: string | null;
  'dash-length': number | null;
  'default-x': number | null;
  'default-y': number | null;
  'end-length': number | null;
  id: string | null;
  'line-type': 'dashed' | 'dotted' | 'solid' | 'wavy' | null;
  number: number | null;
  'relative-x': number | null;
  'relative-y': number | null;
  'space-length': number | null;
};

export type BracketContents = [];

export class Bracket implements XMLElement<'bracket', BracketAttributes, BracketContents> {
  static readonly schema = {
    name: 'bracket',
    attributes: {
      'line-end': { type: 'required', value: { type: 'choices', choices: ['none', 'up', 'down', 'both', 'arrow'] } },
      type: { type: 'required', value: { type: 'choices', choices: ['start', 'stop', 'continue'] } },
      color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
      'dash-length': { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      'default-x': {
        type: 'label',
        label: 'default-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'default-y': {
        type: 'label',
        label: 'default-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'end-length': { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      id: { type: 'optional', value: { type: 'regex', pattern: /[A-Za-z_][A-Za-z0-9.-_]*/, zero: '_' } },
      'line-type': { type: 'optional', value: { type: 'choices', choices: ['dashed', 'dotted', 'solid', 'wavy'] } },
      number: { type: 'optional', value: { type: 'int', min: 1, max: 16 } },
      'relative-x': {
        type: 'label',
        label: 'relative-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'relative-y': {
        type: 'label',
        label: 'relative-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'space-length': { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
    },
    contents: [],
  } as const;

  readonly schema = Bracket.schema;

  attributes: BracketAttributes;
  contents: BracketContents;

  constructor(opts?: { attributes?: Partial<BracketAttributes>; contents?: BracketContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Bracket.schema);
    this.contents = opts?.contents ?? operations.zero(Bracket.schema.contents);
  }
  getLineEnd(): 'none' | 'up' | 'down' | 'both' | 'arrow' {
    return this.attributes['line-end'];
  }
  setLineEnd(lineEnd: 'none' | 'up' | 'down' | 'both' | 'arrow'): Bracket {
    this.attributes['line-end'] = lineEnd;
    return this;
  }
  getType(): 'start' | 'stop' | 'continue' {
    return this.attributes['type'];
  }
  setType(type: 'start' | 'stop' | 'continue'): Bracket {
    this.attributes['type'] = type;
    return this;
  }
  getColor(): string | null {
    return this.attributes['color'];
  }
  setColor(color: string | null): Bracket {
    this.attributes['color'] = color;
    return this;
  }
  getDashLength(): number | null {
    return this.attributes['dash-length'];
  }
  setDashLength(dashLength: number | null): Bracket {
    this.attributes['dash-length'] = dashLength;
    return this;
  }
  getDefaultX(): number | null {
    return this.attributes['default-x'];
  }
  setDefaultX(defaultX: number | null): Bracket {
    this.attributes['default-x'] = defaultX;
    return this;
  }
  getDefaultY(): number | null {
    return this.attributes['default-y'];
  }
  setDefaultY(defaultY: number | null): Bracket {
    this.attributes['default-y'] = defaultY;
    return this;
  }
  getEndLength(): number | null {
    return this.attributes['end-length'];
  }
  setEndLength(endLength: number | null): Bracket {
    this.attributes['end-length'] = endLength;
    return this;
  }
  getId(): string | null {
    return this.attributes['id'];
  }
  setId(id: string | null): Bracket {
    this.attributes['id'] = id;
    return this;
  }
  getLineType(): 'dashed' | 'dotted' | 'solid' | 'wavy' | null {
    return this.attributes['line-type'];
  }
  setLineType(lineType: 'dashed' | 'dotted' | 'solid' | 'wavy' | null): Bracket {
    this.attributes['line-type'] = lineType;
    return this;
  }
  getNumber(): number | null {
    return this.attributes['number'];
  }
  setNumber(number: number | null): Bracket {
    this.attributes['number'] = number;
    return this;
  }
  getRelativeX(): number | null {
    return this.attributes['relative-x'];
  }
  setRelativeX(relativeX: number | null): Bracket {
    this.attributes['relative-x'] = relativeX;
    return this;
  }
  getRelativeY(): number | null {
    return this.attributes['relative-y'];
  }
  setRelativeY(relativeY: number | null): Bracket {
    this.attributes['relative-y'] = relativeY;
    return this;
  }
  getSpaceLength(): number | null {
    return this.attributes['space-length'];
  }
  setSpaceLength(spaceLength: number | null): Bracket {
    this.attributes['space-length'] = spaceLength;
    return this;
  }
}

export type PedalAttributes = {
  type: 'start' | 'stop' | 'sostenuto' | 'change' | 'continue' | 'discountiue' | 'resume';
  abbreviated: 'yes' | 'no' | null;
  color: string | null;
  'default-x': number | null;
  'default-y': number | null;
  'font-family': string | null;
  'font-size': 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null;
  'font-style': 'normal' | 'italic' | null;
  'font-weight': 'normal' | 'bold' | null;
  id: string | null;
  line: 'yes' | 'no' | null;
  number: number | null;
  'relative-x': number | null;
  'relative-y': number | null;
  sign: 'yes' | 'no' | null;
};

export type PedalContents = [];

export class Pedal implements XMLElement<'pedal', PedalAttributes, PedalContents> {
  static readonly schema = {
    name: 'pedal',
    attributes: {
      type: {
        type: 'required',
        value: {
          type: 'choices',
          choices: ['start', 'stop', 'sostenuto', 'change', 'continue', 'discountiue', 'resume'],
        },
      },
      abbreviated: { type: 'optional', value: { type: 'choices', choices: ['yes', 'no'] } },
      color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
      'default-x': {
        type: 'label',
        label: 'default-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'default-y': {
        type: 'label',
        label: 'default-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
      'font-size': {
        type: 'optional',
        value: {
          type: 'choices',
          choices: [
            { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
            { type: 'float', min: -Infinity, max: Infinity },
          ],
        },
      },
      'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
      'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
      id: { type: 'optional', value: { type: 'regex', pattern: /[A-Za-z_][A-Za-z0-9.-_]*/, zero: '_' } },
      line: { type: 'optional', value: { type: 'choices', choices: ['yes', 'no'] } },
      number: { type: 'optional', value: { type: 'int', min: 1, max: 16 } },
      'relative-x': {
        type: 'label',
        label: 'relative-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'relative-y': {
        type: 'label',
        label: 'relative-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      sign: { type: 'optional', value: { type: 'choices', choices: ['yes', 'no'] } },
    },
    contents: [],
  } as const;

  readonly schema = Pedal.schema;

  attributes: PedalAttributes;
  contents: PedalContents;

  constructor(opts?: { attributes?: Partial<PedalAttributes>; contents?: PedalContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Pedal.schema);
    this.contents = opts?.contents ?? operations.zero(Pedal.schema.contents);
  }
  getType(): 'start' | 'stop' | 'sostenuto' | 'change' | 'continue' | 'discountiue' | 'resume' {
    return this.attributes['type'];
  }
  setType(type: 'start' | 'stop' | 'sostenuto' | 'change' | 'continue' | 'discountiue' | 'resume'): Pedal {
    this.attributes['type'] = type;
    return this;
  }
  getAbbreviated(): 'yes' | 'no' | null {
    return this.attributes['abbreviated'];
  }
  setAbbreviated(abbreviated: 'yes' | 'no' | null): Pedal {
    this.attributes['abbreviated'] = abbreviated;
    return this;
  }
  getColor(): string | null {
    return this.attributes['color'];
  }
  setColor(color: string | null): Pedal {
    this.attributes['color'] = color;
    return this;
  }
  getDefaultX(): number | null {
    return this.attributes['default-x'];
  }
  setDefaultX(defaultX: number | null): Pedal {
    this.attributes['default-x'] = defaultX;
    return this;
  }
  getDefaultY(): number | null {
    return this.attributes['default-y'];
  }
  setDefaultY(defaultY: number | null): Pedal {
    this.attributes['default-y'] = defaultY;
    return this;
  }
  getFontFamily(): string | null {
    return this.attributes['font-family'];
  }
  setFontFamily(fontFamily: string | null): Pedal {
    this.attributes['font-family'] = fontFamily;
    return this;
  }
  getFontSize(): 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null {
    return this.attributes['font-size'];
  }
  setFontSize(
    fontSize: 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null
  ): Pedal {
    this.attributes['font-size'] = fontSize;
    return this;
  }
  getFontStyle(): 'normal' | 'italic' | null {
    return this.attributes['font-style'];
  }
  setFontStyle(fontStyle: 'normal' | 'italic' | null): Pedal {
    this.attributes['font-style'] = fontStyle;
    return this;
  }
  getFontWeight(): 'normal' | 'bold' | null {
    return this.attributes['font-weight'];
  }
  setFontWeight(fontWeight: 'normal' | 'bold' | null): Pedal {
    this.attributes['font-weight'] = fontWeight;
    return this;
  }
  getId(): string | null {
    return this.attributes['id'];
  }
  setId(id: string | null): Pedal {
    this.attributes['id'] = id;
    return this;
  }
  getLine(): 'yes' | 'no' | null {
    return this.attributes['line'];
  }
  setLine(line: 'yes' | 'no' | null): Pedal {
    this.attributes['line'] = line;
    return this;
  }
  getNumber(): number | null {
    return this.attributes['number'];
  }
  setNumber(number: number | null): Pedal {
    this.attributes['number'] = number;
    return this;
  }
  getRelativeX(): number | null {
    return this.attributes['relative-x'];
  }
  setRelativeX(relativeX: number | null): Pedal {
    this.attributes['relative-x'] = relativeX;
    return this;
  }
  getRelativeY(): number | null {
    return this.attributes['relative-y'];
  }
  setRelativeY(relativeY: number | null): Pedal {
    this.attributes['relative-y'] = relativeY;
    return this;
  }
  getSign(): 'yes' | 'no' | null {
    return this.attributes['sign'];
  }
  setSign(sign: 'yes' | 'no' | null): Pedal {
    this.attributes['sign'] = sign;
    return this;
  }
}

export type BeatUnitAttributes = Record<string, unknown>;

export type BeatUnitContents = [
  | 'whole'
  | '1024th'
  | '512th'
  | '256th'
  | '128th'
  | '64th'
  | '32nd'
  | '16th'
  | 'eighth'
  | 'half'
  | 'quarter'
  | 'whole'
  | 'breve'
  | 'long'
  | 'maxima'
];

export class BeatUnit implements XMLElement<'beat-unit', BeatUnitAttributes, BeatUnitContents> {
  static readonly schema = {
    name: 'beat-unit',
    attributes: {},
    contents: [
      {
        type: 'required',
        value: {
          type: 'label',
          label: 'note-type-value',
          value: {
            type: 'choices',
            choices: [
              'whole',
              '1024th',
              '512th',
              '256th',
              '128th',
              '64th',
              '32nd',
              '16th',
              'eighth',
              'half',
              'quarter',
              'whole',
              'breve',
              'long',
              'maxima',
            ],
          },
        },
      },
    ],
  } as const;

  readonly schema = BeatUnit.schema;

  attributes: BeatUnitAttributes;
  contents: BeatUnitContents;

  constructor(opts?: { attributes?: Partial<BeatUnitAttributes>; contents?: BeatUnitContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, BeatUnit.schema);
    this.contents = opts?.contents ?? operations.zero(BeatUnit.schema.contents);
  }

  getNoteTypeValue():
    | 'whole'
    | '1024th'
    | '512th'
    | '256th'
    | '128th'
    | '64th'
    | '32nd'
    | '16th'
    | 'eighth'
    | 'half'
    | 'quarter'
    | 'whole'
    | 'breve'
    | 'long'
    | 'maxima' {
    return this.contents[0];
  }
  setNoteTypeValue(
    noteTypeValue:
      | 'whole'
      | '1024th'
      | '512th'
      | '256th'
      | '128th'
      | '64th'
      | '32nd'
      | '16th'
      | 'eighth'
      | 'half'
      | 'quarter'
      | 'whole'
      | 'breve'
      | 'long'
      | 'maxima'
  ): BeatUnit {
    this.contents[0] = noteTypeValue;
    return this;
  }
}

export type BeatUnitDotAttributes = Record<string, unknown>;

export type BeatUnitDotContents = [];

export class BeatUnitDot implements XMLElement<'beat-unit-dot', BeatUnitDotAttributes, BeatUnitDotContents> {
  static readonly schema = { name: 'beat-unit-dot', attributes: {}, contents: [] } as const;

  readonly schema = BeatUnitDot.schema;

  attributes: BeatUnitDotAttributes;
  contents: BeatUnitDotContents;

  constructor(opts?: { attributes?: Partial<BeatUnitDotAttributes>; contents?: BeatUnitDotContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, BeatUnitDot.schema);
    this.contents = opts?.contents ?? operations.zero(BeatUnitDot.schema.contents);
  }
}

export type BeatUnitTiedAttributes = Record<string, unknown>;

export type BeatUnitTiedContents = [BeatUnit, Array<BeatUnitDot>];

export class BeatUnitTied implements XMLElement<'beat-unit-tied', BeatUnitTiedAttributes, BeatUnitTiedContents> {
  static readonly schema = {
    name: 'beat-unit-tied',
    attributes: {},
    contents: [
      { type: 'required', value: BeatUnit },
      { type: 'label', label: 'beat-unit-dots', value: { type: 'zeroOrMore', value: BeatUnitDot } },
    ],
  } as const;

  readonly schema = BeatUnitTied.schema;

  attributes: BeatUnitTiedAttributes;
  contents: BeatUnitTiedContents;

  constructor(opts?: { attributes?: Partial<BeatUnitTiedAttributes>; contents?: BeatUnitTiedContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, BeatUnitTied.schema);
    this.contents = opts?.contents ?? operations.zero(BeatUnitTied.schema.contents);
  }

  getBeatUnit(): BeatUnit {
    return this.contents[0];
  }
  setBeatUnit(beatUnit: BeatUnit): BeatUnitTied {
    this.contents[0] = beatUnit;
    return this;
  }
  getBeatUnitDots(): Array<BeatUnitDot> {
    return this.contents[1];
  }
  setBeatUnitDots(beatUnitDots: Array<BeatUnitDot>): BeatUnitTied {
    this.contents[1] = beatUnitDots;
    return this;
  }
}

export type PerMinuteAttributes = {
  'font-family': string | null;
  'font-size': 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null;
  'font-style': 'normal' | 'italic' | null;
  'font-weight': 'normal' | 'bold' | null;
};

export type PerMinuteContents = [string];

export class PerMinute implements XMLElement<'per-minute', PerMinuteAttributes, PerMinuteContents> {
  static readonly schema = {
    name: 'per-minute',
    attributes: {
      'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
      'font-size': {
        type: 'optional',
        value: {
          type: 'choices',
          choices: [
            { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
            { type: 'float', min: -Infinity, max: Infinity },
          ],
        },
      },
      'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
      'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
    },
    contents: [{ type: 'required', value: { type: 'string' } }],
  } as const;

  readonly schema = PerMinute.schema;

  attributes: PerMinuteAttributes;
  contents: PerMinuteContents;

  constructor(opts?: { attributes?: Partial<PerMinuteAttributes>; contents?: PerMinuteContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, PerMinute.schema);
    this.contents = opts?.contents ?? operations.zero(PerMinute.schema.contents);
  }
  getFontFamily(): string | null {
    return this.attributes['font-family'];
  }
  setFontFamily(fontFamily: string | null): PerMinute {
    this.attributes['font-family'] = fontFamily;
    return this;
  }
  getFontSize(): 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null {
    return this.attributes['font-size'];
  }
  setFontSize(
    fontSize: 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null
  ): PerMinute {
    this.attributes['font-size'] = fontSize;
    return this;
  }
  getFontStyle(): 'normal' | 'italic' | null {
    return this.attributes['font-style'];
  }
  setFontStyle(fontStyle: 'normal' | 'italic' | null): PerMinute {
    this.attributes['font-style'] = fontStyle;
    return this;
  }
  getFontWeight(): 'normal' | 'bold' | null {
    return this.attributes['font-weight'];
  }
  setFontWeight(fontWeight: 'normal' | 'bold' | null): PerMinute {
    this.attributes['font-weight'] = fontWeight;
    return this;
  }
  getText(): string {
    return this.contents[0];
  }
  setText(text: string): PerMinute {
    this.contents[0] = text;
    return this;
  }
}

export type MetronomeArrowsAttributes = Record<string, unknown>;

export type MetronomeArrowsContents = [];

export class MetronomeArrows
  implements XMLElement<'metronome-arrows', MetronomeArrowsAttributes, MetronomeArrowsContents>
{
  static readonly schema = { name: 'metronome-arrows', attributes: {}, contents: [] } as const;

  readonly schema = MetronomeArrows.schema;

  attributes: MetronomeArrowsAttributes;
  contents: MetronomeArrowsContents;

  constructor(opts?: { attributes?: Partial<MetronomeArrowsAttributes>; contents?: MetronomeArrowsContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, MetronomeArrows.schema);
    this.contents = opts?.contents ?? operations.zero(MetronomeArrows.schema.contents);
  }
}

export type MetronomeTypeAttributes = Record<string, unknown>;

export type MetronomeTypeContents = [
  | 'whole'
  | '1024th'
  | '512th'
  | '256th'
  | '128th'
  | '64th'
  | '32nd'
  | '16th'
  | 'eighth'
  | 'half'
  | 'quarter'
  | 'whole'
  | 'breve'
  | 'long'
  | 'maxima'
];

export class MetronomeType implements XMLElement<'metronome-type', MetronomeTypeAttributes, MetronomeTypeContents> {
  static readonly schema = {
    name: 'metronome-type',
    attributes: {},
    contents: [
      {
        type: 'required',
        value: {
          type: 'label',
          label: 'note-type-value',
          value: {
            type: 'choices',
            choices: [
              'whole',
              '1024th',
              '512th',
              '256th',
              '128th',
              '64th',
              '32nd',
              '16th',
              'eighth',
              'half',
              'quarter',
              'whole',
              'breve',
              'long',
              'maxima',
            ],
          },
        },
      },
    ],
  } as const;

  readonly schema = MetronomeType.schema;

  attributes: MetronomeTypeAttributes;
  contents: MetronomeTypeContents;

  constructor(opts?: { attributes?: Partial<MetronomeTypeAttributes>; contents?: MetronomeTypeContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, MetronomeType.schema);
    this.contents = opts?.contents ?? operations.zero(MetronomeType.schema.contents);
  }

  getNoteTypeValue():
    | 'whole'
    | '1024th'
    | '512th'
    | '256th'
    | '128th'
    | '64th'
    | '32nd'
    | '16th'
    | 'eighth'
    | 'half'
    | 'quarter'
    | 'whole'
    | 'breve'
    | 'long'
    | 'maxima' {
    return this.contents[0];
  }
  setNoteTypeValue(
    noteTypeValue:
      | 'whole'
      | '1024th'
      | '512th'
      | '256th'
      | '128th'
      | '64th'
      | '32nd'
      | '16th'
      | 'eighth'
      | 'half'
      | 'quarter'
      | 'whole'
      | 'breve'
      | 'long'
      | 'maxima'
  ): MetronomeType {
    this.contents[0] = noteTypeValue;
    return this;
  }
}

export type MetronomeDotAttributes = Record<string, unknown>;

export type MetronomeDotContents = [];

export class MetronomeDot implements XMLElement<'metronome-dot', MetronomeDotAttributes, MetronomeDotContents> {
  static readonly schema = { name: 'metronome-dot', attributes: {}, contents: [] } as const;

  readonly schema = MetronomeDot.schema;

  attributes: MetronomeDotAttributes;
  contents: MetronomeDotContents;

  constructor(opts?: { attributes?: Partial<MetronomeDotAttributes>; contents?: MetronomeDotContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, MetronomeDot.schema);
    this.contents = opts?.contents ?? operations.zero(MetronomeDot.schema.contents);
  }
}

export type MetronomeBeamAttributes = { number: number | null };

export type MetronomeBeamContents = ['backward hook' | 'begin' | 'continue' | 'end' | 'forward hook'];

export class MetronomeBeam implements XMLElement<'metronome-beam', MetronomeBeamAttributes, MetronomeBeamContents> {
  static readonly schema = {
    name: 'metronome-beam',
    attributes: { number: { type: 'optional', value: { type: 'int', min: 1, max: 8 } } },
    contents: [
      {
        type: 'required',
        value: {
          type: 'label',
          label: 'beam-value',
          value: { type: 'choices', choices: ['backward hook', 'begin', 'continue', 'end', 'forward hook'] },
        },
      },
    ],
  } as const;

  readonly schema = MetronomeBeam.schema;

  attributes: MetronomeBeamAttributes;
  contents: MetronomeBeamContents;

  constructor(opts?: { attributes?: Partial<MetronomeBeamAttributes>; contents?: MetronomeBeamContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, MetronomeBeam.schema);
    this.contents = opts?.contents ?? operations.zero(MetronomeBeam.schema.contents);
  }
  getNumber(): number | null {
    return this.attributes['number'];
  }
  setNumber(number: number | null): MetronomeBeam {
    this.attributes['number'] = number;
    return this;
  }
  getBeamValue(): 'backward hook' | 'begin' | 'continue' | 'end' | 'forward hook' {
    return this.contents[0];
  }
  setBeamValue(beamValue: 'backward hook' | 'begin' | 'continue' | 'end' | 'forward hook'): MetronomeBeam {
    this.contents[0] = beamValue;
    return this;
  }
}

export type MetronomeTiedAttributes = { type: 'start' | 'stop' };

export type MetronomeTiedContents = [];

export class MetronomeTied implements XMLElement<'metronome-tied', MetronomeTiedAttributes, MetronomeTiedContents> {
  static readonly schema = {
    name: 'metronome-tied',
    attributes: { type: { type: 'required', value: { type: 'choices', choices: ['start', 'stop'] } } },
    contents: [],
  } as const;

  readonly schema = MetronomeTied.schema;

  attributes: MetronomeTiedAttributes;
  contents: MetronomeTiedContents;

  constructor(opts?: { attributes?: Partial<MetronomeTiedAttributes>; contents?: MetronomeTiedContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, MetronomeTied.schema);
    this.contents = opts?.contents ?? operations.zero(MetronomeTied.schema.contents);
  }
  getType(): 'start' | 'stop' {
    return this.attributes['type'];
  }
  setType(type: 'start' | 'stop'): MetronomeTied {
    this.attributes['type'] = type;
    return this;
  }
}

export type MetronomeTupletAttributes = {
  type: 'start' | 'stop';
  bracket: 'yes' | 'no' | null;
  'show-number': 'none' | 'actual' | 'both' | null;
};

export type MetronomeTupletContents = [ActualNotes, NormalNotes, [NormalType, Array<NormalDot>] | null];

export class MetronomeTuplet
  implements XMLElement<'metronome-tuplet', MetronomeTupletAttributes, MetronomeTupletContents>
{
  static readonly schema = {
    name: 'metronome-tuplet',
    attributes: {
      type: { type: 'required', value: { type: 'choices', choices: ['start', 'stop'] } },
      bracket: { type: 'optional', value: { type: 'choices', choices: ['yes', 'no'] } },
      'show-number': { type: 'optional', value: { type: 'choices', choices: ['none', 'actual', 'both'] } },
    },
    contents: [
      { type: 'required', value: ActualNotes },
      { type: 'required', value: NormalNotes },
      {
        type: 'label',
        label: 'normal',
        value: {
          type: 'optional',
          value: [
            { type: 'required', value: NormalType },
            { type: 'zeroOrMore', value: NormalDot },
          ],
        },
      },
    ],
  } as const;

  readonly schema = MetronomeTuplet.schema;

  attributes: MetronomeTupletAttributes;
  contents: MetronomeTupletContents;

  constructor(opts?: { attributes?: Partial<MetronomeTupletAttributes>; contents?: MetronomeTupletContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, MetronomeTuplet.schema);
    this.contents = opts?.contents ?? operations.zero(MetronomeTuplet.schema.contents);
  }
  getType(): 'start' | 'stop' {
    return this.attributes['type'];
  }
  setType(type: 'start' | 'stop'): MetronomeTuplet {
    this.attributes['type'] = type;
    return this;
  }
  getBracket(): 'yes' | 'no' | null {
    return this.attributes['bracket'];
  }
  setBracket(bracket: 'yes' | 'no' | null): MetronomeTuplet {
    this.attributes['bracket'] = bracket;
    return this;
  }
  getShowNumber(): 'none' | 'actual' | 'both' | null {
    return this.attributes['show-number'];
  }
  setShowNumber(showNumber: 'none' | 'actual' | 'both' | null): MetronomeTuplet {
    this.attributes['show-number'] = showNumber;
    return this;
  }
  getActualNotes(): ActualNotes {
    return this.contents[0];
  }
  setActualNotes(actualNotes: ActualNotes): MetronomeTuplet {
    this.contents[0] = actualNotes;
    return this;
  }
  getNormalNotes(): NormalNotes {
    return this.contents[1];
  }
  setNormalNotes(normalNotes: NormalNotes): MetronomeTuplet {
    this.contents[1] = normalNotes;
    return this;
  }
  getNormal(): [NormalType, Array<NormalDot>] | null {
    return this.contents[2];
  }
  setNormal(normal: [NormalType, Array<NormalDot>] | null): MetronomeTuplet {
    this.contents[2] = normal;
    return this;
  }
}

export type MetronomeNoteAttributes = Record<string, unknown>;

export type MetronomeNoteContents = [
  MetronomeType,
  Array<MetronomeDot>,
  Array<MetronomeBeam>,
  MetronomeTied | null,
  MetronomeTuplet | null
];

export class MetronomeNote implements XMLElement<'metronome-note', MetronomeNoteAttributes, MetronomeNoteContents> {
  static readonly schema = {
    name: 'metronome-note',
    attributes: {},
    contents: [
      { type: 'required', value: MetronomeType },
      { type: 'label', label: 'metronome-dots', value: { type: 'zeroOrMore', value: MetronomeDot } },
      { type: 'label', label: 'metronome-beams', value: { type: 'zeroOrMore', value: MetronomeBeam } },
      { type: 'optional', value: MetronomeTied },
      { type: 'optional', value: MetronomeTuplet },
    ],
  } as const;

  readonly schema = MetronomeNote.schema;

  attributes: MetronomeNoteAttributes;
  contents: MetronomeNoteContents;

  constructor(opts?: { attributes?: Partial<MetronomeNoteAttributes>; contents?: MetronomeNoteContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, MetronomeNote.schema);
    this.contents = opts?.contents ?? operations.zero(MetronomeNote.schema.contents);
  }

  getMetronomeType(): MetronomeType {
    return this.contents[0];
  }
  setMetronomeType(metronomeType: MetronomeType): MetronomeNote {
    this.contents[0] = metronomeType;
    return this;
  }
  getMetronomeDots(): Array<MetronomeDot> {
    return this.contents[1];
  }
  setMetronomeDots(metronomeDots: Array<MetronomeDot>): MetronomeNote {
    this.contents[1] = metronomeDots;
    return this;
  }
  getMetronomeBeams(): Array<MetronomeBeam> {
    return this.contents[2];
  }
  setMetronomeBeams(metronomeBeams: Array<MetronomeBeam>): MetronomeNote {
    this.contents[2] = metronomeBeams;
    return this;
  }
  getMetronomeTied(): MetronomeTied | null {
    return this.contents[3];
  }
  setMetronomeTied(metronomeTied: MetronomeTied | null): MetronomeNote {
    this.contents[3] = metronomeTied;
    return this;
  }
  getMetronomeTuplet(): MetronomeTuplet | null {
    return this.contents[4];
  }
  setMetronomeTuplet(metronomeTuplet: MetronomeTuplet | null): MetronomeNote {
    this.contents[4] = metronomeTuplet;
    return this;
  }
}

export type MetronomeRelationAttributes = Record<string, unknown>;

export type MetronomeRelationContents = [string | null];

export class MetronomeRelation
  implements XMLElement<'metronome-relation', MetronomeRelationAttributes, MetronomeRelationContents>
{
  static readonly schema = {
    name: 'metronome-relation',
    attributes: {},
    contents: [{ type: 'optional', value: { type: 'string' } }],
  } as const;

  readonly schema = MetronomeRelation.schema;

  attributes: MetronomeRelationAttributes;
  contents: MetronomeRelationContents;

  constructor(opts?: { attributes?: Partial<MetronomeRelationAttributes>; contents?: MetronomeRelationContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, MetronomeRelation.schema);
    this.contents = opts?.contents ?? operations.zero(MetronomeRelation.schema.contents);
  }

  getText(): string | null {
    return this.contents[0];
  }
  setText(text: string | null): MetronomeRelation {
    this.contents[0] = text;
    return this;
  }
}

export type BeatSpec = [
  BeatUnit,
  Array<BeatUnitDot>,
  Array<BeatUnitTied>,
  PerMinute | [BeatUnit, Array<BeatUnitDot>, Array<BeatUnitTied>]
];

export type MetronomeSpec = [
  MetronomeArrows | null,
  Array<MetronomeNote>,
  [MetronomeRelation, Array<MetronomeNote>] | null
];

export type MetronomeAttributes = {
  color: string | null;
  'default-x': number | null;
  'default-y': number | null;
  'font-family': string | null;
  'font-size': 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null;
  'font-style': 'normal' | 'italic' | null;
  'font-weight': 'normal' | 'bold' | null;
  halign: 'left' | 'center' | 'right' | null;
  id: string | null;
  justify: 'left' | 'center' | 'right' | null;
  parentheses: 'yes' | 'no' | null;
  'print-object': 'yes' | 'no' | null;
  'relative-x': number | null;
  'relative-y': number | null;
  valign: 'top' | 'middle' | 'bottom' | 'baseline' | null;
};

export type MetronomeContents = [BeatSpec | MetronomeSpec];

export class Metronome implements XMLElement<'metronome', MetronomeAttributes, MetronomeContents> {
  static readonly schema = {
    name: 'metronome',
    attributes: {
      color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
      'default-x': {
        type: 'label',
        label: 'default-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'default-y': {
        type: 'label',
        label: 'default-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
      'font-size': {
        type: 'optional',
        value: {
          type: 'choices',
          choices: [
            { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
            { type: 'float', min: -Infinity, max: Infinity },
          ],
        },
      },
      'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
      'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
      halign: { type: 'optional', value: { type: 'choices', choices: ['left', 'center', 'right'] } },
      id: { type: 'optional', value: { type: 'regex', pattern: /[A-Za-z_][A-Za-z0-9.-_]*/, zero: '_' } },
      justify: { type: 'optional', value: { type: 'choices', choices: ['left', 'center', 'right'] } },
      parentheses: { type: 'optional', value: { type: 'choices', choices: ['yes', 'no'] } },
      'print-object': { type: 'optional', value: { type: 'choices', choices: ['yes', 'no'] } },
      'relative-x': {
        type: 'label',
        label: 'relative-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'relative-y': {
        type: 'label',
        label: 'relative-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      valign: { type: 'optional', value: { type: 'choices', choices: ['top', 'middle', 'bottom', 'baseline'] } },
    },
    contents: [
      {
        type: 'label',
        label: 'metronome',
        value: {
          type: 'choices',
          choices: [
            {
              type: 'label',
              label: 'beat-spec',
              value: [
                { type: 'required', value: BeatUnit },
                { type: 'zeroOrMore', value: BeatUnitDot },
                { type: 'zeroOrMore', value: BeatUnitTied },
                {
                  type: 'choices',
                  choices: [
                    PerMinute,
                    [
                      { type: 'required', value: BeatUnit },
                      { type: 'zeroOrMore', value: BeatUnitDot },
                      { type: 'zeroOrMore', value: BeatUnitTied },
                    ],
                  ],
                },
              ],
            },
            {
              type: 'label',
              label: 'metronome-spec',
              value: [
                { type: 'optional', value: MetronomeArrows },
                { type: 'oneOrMore', value: MetronomeNote },
                {
                  type: 'optional',
                  value: [
                    { type: 'required', value: MetronomeRelation },
                    { type: 'oneOrMore', value: MetronomeNote },
                  ],
                },
              ],
            },
          ],
        },
      },
    ],
  } as const;

  readonly schema = Metronome.schema;

  attributes: MetronomeAttributes;
  contents: MetronomeContents;

  constructor(opts?: { attributes?: Partial<MetronomeAttributes>; contents?: MetronomeContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Metronome.schema);
    this.contents = opts?.contents ?? operations.zero(Metronome.schema.contents);
  }
  getColor(): string | null {
    return this.attributes['color'];
  }
  setColor(color: string | null): Metronome {
    this.attributes['color'] = color;
    return this;
  }
  getDefaultX(): number | null {
    return this.attributes['default-x'];
  }
  setDefaultX(defaultX: number | null): Metronome {
    this.attributes['default-x'] = defaultX;
    return this;
  }
  getDefaultY(): number | null {
    return this.attributes['default-y'];
  }
  setDefaultY(defaultY: number | null): Metronome {
    this.attributes['default-y'] = defaultY;
    return this;
  }
  getFontFamily(): string | null {
    return this.attributes['font-family'];
  }
  setFontFamily(fontFamily: string | null): Metronome {
    this.attributes['font-family'] = fontFamily;
    return this;
  }
  getFontSize(): 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null {
    return this.attributes['font-size'];
  }
  setFontSize(
    fontSize: 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null
  ): Metronome {
    this.attributes['font-size'] = fontSize;
    return this;
  }
  getFontStyle(): 'normal' | 'italic' | null {
    return this.attributes['font-style'];
  }
  setFontStyle(fontStyle: 'normal' | 'italic' | null): Metronome {
    this.attributes['font-style'] = fontStyle;
    return this;
  }
  getFontWeight(): 'normal' | 'bold' | null {
    return this.attributes['font-weight'];
  }
  setFontWeight(fontWeight: 'normal' | 'bold' | null): Metronome {
    this.attributes['font-weight'] = fontWeight;
    return this;
  }
  getHalign(): 'left' | 'center' | 'right' | null {
    return this.attributes['halign'];
  }
  setHalign(halign: 'left' | 'center' | 'right' | null): Metronome {
    this.attributes['halign'] = halign;
    return this;
  }
  getId(): string | null {
    return this.attributes['id'];
  }
  setId(id: string | null): Metronome {
    this.attributes['id'] = id;
    return this;
  }
  getJustify(): 'left' | 'center' | 'right' | null {
    return this.attributes['justify'];
  }
  setJustify(justify: 'left' | 'center' | 'right' | null): Metronome {
    this.attributes['justify'] = justify;
    return this;
  }
  getParentheses(): 'yes' | 'no' | null {
    return this.attributes['parentheses'];
  }
  setParentheses(parentheses: 'yes' | 'no' | null): Metronome {
    this.attributes['parentheses'] = parentheses;
    return this;
  }
  getPrintObject(): 'yes' | 'no' | null {
    return this.attributes['print-object'];
  }
  setPrintObject(printObject: 'yes' | 'no' | null): Metronome {
    this.attributes['print-object'] = printObject;
    return this;
  }
  getRelativeX(): number | null {
    return this.attributes['relative-x'];
  }
  setRelativeX(relativeX: number | null): Metronome {
    this.attributes['relative-x'] = relativeX;
    return this;
  }
  getRelativeY(): number | null {
    return this.attributes['relative-y'];
  }
  setRelativeY(relativeY: number | null): Metronome {
    this.attributes['relative-y'] = relativeY;
    return this;
  }
  getValign(): 'top' | 'middle' | 'bottom' | 'baseline' | null {
    return this.attributes['valign'];
  }
  setValign(valign: 'top' | 'middle' | 'bottom' | 'baseline' | null): Metronome {
    this.attributes['valign'] = valign;
    return this;
  }
  getMetronome(): BeatSpec | MetronomeSpec {
    return this.contents[0];
  }
  setMetronome(metronome: BeatSpec | MetronomeSpec): Metronome {
    this.contents[0] = metronome;
    return this;
  }
}

export type OctaveShiftAttributes = {
  type: 'up' | 'down' | 'stop' | 'continue';
  color: string | null;
  'dash-length': number | null;
  'default-x': number | null;
  'default-y': number | null;
  'font-family': string | null;
  'font-size': 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null;
  'font-style': 'normal' | 'italic' | null;
  'font-weight': 'normal' | 'bold' | null;
  id: string | null;
  number: number | null;
  'relative-x': number | null;
  'relative-y': number | null;
  size: number | null;
  'space-length': number | null;
};

export type OctaveShiftContents = [];

export class OctaveShift implements XMLElement<'octave-shift', OctaveShiftAttributes, OctaveShiftContents> {
  static readonly schema = {
    name: 'octave-shift',
    attributes: {
      type: { type: 'required', value: { type: 'choices', choices: ['up', 'down', 'stop', 'continue'] } },
      color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
      'dash-length': { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      'default-x': {
        type: 'label',
        label: 'default-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'default-y': {
        type: 'label',
        label: 'default-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
      'font-size': {
        type: 'optional',
        value: {
          type: 'choices',
          choices: [
            { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
            { type: 'float', min: -Infinity, max: Infinity },
          ],
        },
      },
      'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
      'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
      id: { type: 'optional', value: { type: 'regex', pattern: /[A-Za-z_][A-Za-z0-9.-_]*/, zero: '_' } },
      number: { type: 'optional', value: { type: 'int', min: 1, max: 16 } },
      'relative-x': {
        type: 'label',
        label: 'relative-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'relative-y': {
        type: 'label',
        label: 'relative-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      size: { type: 'optional', value: { type: 'int', min: 1, max: Infinity } },
      'space-length': { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
    },
    contents: [],
  } as const;

  readonly schema = OctaveShift.schema;

  attributes: OctaveShiftAttributes;
  contents: OctaveShiftContents;

  constructor(opts?: { attributes?: Partial<OctaveShiftAttributes>; contents?: OctaveShiftContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, OctaveShift.schema);
    this.contents = opts?.contents ?? operations.zero(OctaveShift.schema.contents);
  }
  getType(): 'up' | 'down' | 'stop' | 'continue' {
    return this.attributes['type'];
  }
  setType(type: 'up' | 'down' | 'stop' | 'continue'): OctaveShift {
    this.attributes['type'] = type;
    return this;
  }
  getColor(): string | null {
    return this.attributes['color'];
  }
  setColor(color: string | null): OctaveShift {
    this.attributes['color'] = color;
    return this;
  }
  getDashLength(): number | null {
    return this.attributes['dash-length'];
  }
  setDashLength(dashLength: number | null): OctaveShift {
    this.attributes['dash-length'] = dashLength;
    return this;
  }
  getDefaultX(): number | null {
    return this.attributes['default-x'];
  }
  setDefaultX(defaultX: number | null): OctaveShift {
    this.attributes['default-x'] = defaultX;
    return this;
  }
  getDefaultY(): number | null {
    return this.attributes['default-y'];
  }
  setDefaultY(defaultY: number | null): OctaveShift {
    this.attributes['default-y'] = defaultY;
    return this;
  }
  getFontFamily(): string | null {
    return this.attributes['font-family'];
  }
  setFontFamily(fontFamily: string | null): OctaveShift {
    this.attributes['font-family'] = fontFamily;
    return this;
  }
  getFontSize(): 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null {
    return this.attributes['font-size'];
  }
  setFontSize(
    fontSize: 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null
  ): OctaveShift {
    this.attributes['font-size'] = fontSize;
    return this;
  }
  getFontStyle(): 'normal' | 'italic' | null {
    return this.attributes['font-style'];
  }
  setFontStyle(fontStyle: 'normal' | 'italic' | null): OctaveShift {
    this.attributes['font-style'] = fontStyle;
    return this;
  }
  getFontWeight(): 'normal' | 'bold' | null {
    return this.attributes['font-weight'];
  }
  setFontWeight(fontWeight: 'normal' | 'bold' | null): OctaveShift {
    this.attributes['font-weight'] = fontWeight;
    return this;
  }
  getId(): string | null {
    return this.attributes['id'];
  }
  setId(id: string | null): OctaveShift {
    this.attributes['id'] = id;
    return this;
  }
  getNumber(): number | null {
    return this.attributes['number'];
  }
  setNumber(number: number | null): OctaveShift {
    this.attributes['number'] = number;
    return this;
  }
  getRelativeX(): number | null {
    return this.attributes['relative-x'];
  }
  setRelativeX(relativeX: number | null): OctaveShift {
    this.attributes['relative-x'] = relativeX;
    return this;
  }
  getRelativeY(): number | null {
    return this.attributes['relative-y'];
  }
  setRelativeY(relativeY: number | null): OctaveShift {
    this.attributes['relative-y'] = relativeY;
    return this;
  }
  getSize(): number | null {
    return this.attributes['size'];
  }
  setSize(size: number | null): OctaveShift {
    this.attributes['size'] = size;
    return this;
  }
  getSpaceLength(): number | null {
    return this.attributes['space-length'];
  }
  setSpaceLength(spaceLength: number | null): OctaveShift {
    this.attributes['space-length'] = spaceLength;
    return this;
  }
}

export type PedalStepAttributes = Record<string, unknown>;

export type PedalStepContents = ['A' | 'B' | 'C' | 'D' | 'E' | 'F' | 'G'];

export class PedalStep implements XMLElement<'pedal-step', PedalStepAttributes, PedalStepContents> {
  static readonly schema = {
    name: 'pedal-step',
    attributes: {},
    contents: [
      {
        type: 'required',
        value: {
          type: 'label',
          label: 'step',
          value: { type: 'choices', choices: ['A', 'B', 'C', 'D', 'E', 'F', 'G'] },
        },
      },
    ],
  } as const;

  readonly schema = PedalStep.schema;

  attributes: PedalStepAttributes;
  contents: PedalStepContents;

  constructor(opts?: { attributes?: Partial<PedalStepAttributes>; contents?: PedalStepContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, PedalStep.schema);
    this.contents = opts?.contents ?? operations.zero(PedalStep.schema.contents);
  }

  getStep(): 'A' | 'B' | 'C' | 'D' | 'E' | 'F' | 'G' {
    return this.contents[0];
  }
  setStep(step: 'A' | 'B' | 'C' | 'D' | 'E' | 'F' | 'G'): PedalStep {
    this.contents[0] = step;
    return this;
  }
}

export type PedalAlterAttributes = Record<string, unknown>;

export type PedalAlterContents = [number];

export class PedalAlter implements XMLElement<'pedal-alter', PedalAlterAttributes, PedalAlterContents> {
  static readonly schema = {
    name: 'pedal-alter',
    attributes: {},
    contents: [
      {
        type: 'required',
        value: { type: 'label', label: 'semitones', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
    ],
  } as const;

  readonly schema = PedalAlter.schema;

  attributes: PedalAlterAttributes;
  contents: PedalAlterContents;

  constructor(opts?: { attributes?: Partial<PedalAlterAttributes>; contents?: PedalAlterContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, PedalAlter.schema);
    this.contents = opts?.contents ?? operations.zero(PedalAlter.schema.contents);
  }

  getSemitones(): number {
    return this.contents[0];
  }
  setSemitones(semitones: number): PedalAlter {
    this.contents[0] = semitones;
    return this;
  }
}

export type PedalTuningAttributes = Record<string, unknown>;

export type PedalTuningContents = [PedalStep, PedalAlter];

export class PedalTuning implements XMLElement<'pedal-tuning', PedalTuningAttributes, PedalTuningContents> {
  static readonly schema = {
    name: 'pedal-tuning',
    attributes: {},
    contents: [
      { type: 'required', value: PedalStep },
      { type: 'required', value: PedalAlter },
    ],
  } as const;

  readonly schema = PedalTuning.schema;

  attributes: PedalTuningAttributes;
  contents: PedalTuningContents;

  constructor(opts?: { attributes?: Partial<PedalTuningAttributes>; contents?: PedalTuningContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, PedalTuning.schema);
    this.contents = opts?.contents ?? operations.zero(PedalTuning.schema.contents);
  }

  getPedalStep(): PedalStep {
    return this.contents[0];
  }
  setPedalStep(pedalStep: PedalStep): PedalTuning {
    this.contents[0] = pedalStep;
    return this;
  }
  getPedalAlter(): PedalAlter {
    return this.contents[1];
  }
  setPedalAlter(pedalAlter: PedalAlter): PedalTuning {
    this.contents[1] = pedalAlter;
    return this;
  }
}

export type HarpPedalsAttributes = {
  color: string | null;
  'default-x': number | null;
  'default-y': number | null;
  'font-family': string | null;
  'font-size': 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null;
  'font-style': 'normal' | 'italic' | null;
  'font-weight': 'normal' | 'bold' | null;
  halign: 'left' | 'center' | 'right' | null;
  id: string | null;
  'relative-x': number | null;
  'relative-y': number | null;
  valign: 'top' | 'middle' | 'bottom' | 'baseline' | null;
};

export type HarpPedalsContents = [Array<PedalTuning>];

export class HarpPedals implements XMLElement<'harp-pedals', HarpPedalsAttributes, HarpPedalsContents> {
  static readonly schema = {
    name: 'harp-pedals',
    attributes: {
      color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
      'default-x': {
        type: 'label',
        label: 'default-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'default-y': {
        type: 'label',
        label: 'default-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
      'font-size': {
        type: 'optional',
        value: {
          type: 'choices',
          choices: [
            { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
            { type: 'float', min: -Infinity, max: Infinity },
          ],
        },
      },
      'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
      'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
      halign: { type: 'optional', value: { type: 'choices', choices: ['left', 'center', 'right'] } },
      id: { type: 'optional', value: { type: 'regex', pattern: /[A-Za-z_][A-Za-z0-9.-_]*/, zero: '_' } },
      'relative-x': {
        type: 'label',
        label: 'relative-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'relative-y': {
        type: 'label',
        label: 'relative-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      valign: { type: 'optional', value: { type: 'choices', choices: ['top', 'middle', 'bottom', 'baseline'] } },
    },
    contents: [{ type: 'label', label: 'pedal-tunings', value: { type: 'oneOrMore', value: PedalTuning } }],
  } as const;

  readonly schema = HarpPedals.schema;

  attributes: HarpPedalsAttributes;
  contents: HarpPedalsContents;

  constructor(opts?: { attributes?: Partial<HarpPedalsAttributes>; contents?: HarpPedalsContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, HarpPedals.schema);
    this.contents = opts?.contents ?? operations.zero(HarpPedals.schema.contents);
  }
  getColor(): string | null {
    return this.attributes['color'];
  }
  setColor(color: string | null): HarpPedals {
    this.attributes['color'] = color;
    return this;
  }
  getDefaultX(): number | null {
    return this.attributes['default-x'];
  }
  setDefaultX(defaultX: number | null): HarpPedals {
    this.attributes['default-x'] = defaultX;
    return this;
  }
  getDefaultY(): number | null {
    return this.attributes['default-y'];
  }
  setDefaultY(defaultY: number | null): HarpPedals {
    this.attributes['default-y'] = defaultY;
    return this;
  }
  getFontFamily(): string | null {
    return this.attributes['font-family'];
  }
  setFontFamily(fontFamily: string | null): HarpPedals {
    this.attributes['font-family'] = fontFamily;
    return this;
  }
  getFontSize(): 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null {
    return this.attributes['font-size'];
  }
  setFontSize(
    fontSize: 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null
  ): HarpPedals {
    this.attributes['font-size'] = fontSize;
    return this;
  }
  getFontStyle(): 'normal' | 'italic' | null {
    return this.attributes['font-style'];
  }
  setFontStyle(fontStyle: 'normal' | 'italic' | null): HarpPedals {
    this.attributes['font-style'] = fontStyle;
    return this;
  }
  getFontWeight(): 'normal' | 'bold' | null {
    return this.attributes['font-weight'];
  }
  setFontWeight(fontWeight: 'normal' | 'bold' | null): HarpPedals {
    this.attributes['font-weight'] = fontWeight;
    return this;
  }
  getHalign(): 'left' | 'center' | 'right' | null {
    return this.attributes['halign'];
  }
  setHalign(halign: 'left' | 'center' | 'right' | null): HarpPedals {
    this.attributes['halign'] = halign;
    return this;
  }
  getId(): string | null {
    return this.attributes['id'];
  }
  setId(id: string | null): HarpPedals {
    this.attributes['id'] = id;
    return this;
  }
  getRelativeX(): number | null {
    return this.attributes['relative-x'];
  }
  setRelativeX(relativeX: number | null): HarpPedals {
    this.attributes['relative-x'] = relativeX;
    return this;
  }
  getRelativeY(): number | null {
    return this.attributes['relative-y'];
  }
  setRelativeY(relativeY: number | null): HarpPedals {
    this.attributes['relative-y'] = relativeY;
    return this;
  }
  getValign(): 'top' | 'middle' | 'bottom' | 'baseline' | null {
    return this.attributes['valign'];
  }
  setValign(valign: 'top' | 'middle' | 'bottom' | 'baseline' | null): HarpPedals {
    this.attributes['valign'] = valign;
    return this;
  }
  getPedalTunings(): Array<PedalTuning> {
    return this.contents[0];
  }
  setPedalTunings(pedalTunings: Array<PedalTuning>): HarpPedals {
    this.contents[0] = pedalTunings;
    return this;
  }
}

export type DampAttributes = {
  color: string | null;
  'default-x': number | null;
  'default-y': number | null;
  'font-family': string | null;
  'font-size': 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null;
  'font-style': 'normal' | 'italic' | null;
  'font-weight': 'normal' | 'bold' | null;
  halign: 'left' | 'center' | 'right' | null;
  id: string | null;
  'relative-x': number | null;
  'relative-y': number | null;
  valign: 'top' | 'middle' | 'bottom' | 'baseline' | null;
};

export type DampContents = [];

export class Damp implements XMLElement<'damp', DampAttributes, DampContents> {
  static readonly schema = {
    name: 'damp',
    attributes: {
      color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
      'default-x': {
        type: 'label',
        label: 'default-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'default-y': {
        type: 'label',
        label: 'default-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
      'font-size': {
        type: 'optional',
        value: {
          type: 'choices',
          choices: [
            { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
            { type: 'float', min: -Infinity, max: Infinity },
          ],
        },
      },
      'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
      'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
      halign: { type: 'optional', value: { type: 'choices', choices: ['left', 'center', 'right'] } },
      id: { type: 'optional', value: { type: 'regex', pattern: /[A-Za-z_][A-Za-z0-9.-_]*/, zero: '_' } },
      'relative-x': {
        type: 'label',
        label: 'relative-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'relative-y': {
        type: 'label',
        label: 'relative-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      valign: { type: 'optional', value: { type: 'choices', choices: ['top', 'middle', 'bottom', 'baseline'] } },
    },
    contents: [],
  } as const;

  readonly schema = Damp.schema;

  attributes: DampAttributes;
  contents: DampContents;

  constructor(opts?: { attributes?: Partial<DampAttributes>; contents?: DampContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Damp.schema);
    this.contents = opts?.contents ?? operations.zero(Damp.schema.contents);
  }
  getColor(): string | null {
    return this.attributes['color'];
  }
  setColor(color: string | null): Damp {
    this.attributes['color'] = color;
    return this;
  }
  getDefaultX(): number | null {
    return this.attributes['default-x'];
  }
  setDefaultX(defaultX: number | null): Damp {
    this.attributes['default-x'] = defaultX;
    return this;
  }
  getDefaultY(): number | null {
    return this.attributes['default-y'];
  }
  setDefaultY(defaultY: number | null): Damp {
    this.attributes['default-y'] = defaultY;
    return this;
  }
  getFontFamily(): string | null {
    return this.attributes['font-family'];
  }
  setFontFamily(fontFamily: string | null): Damp {
    this.attributes['font-family'] = fontFamily;
    return this;
  }
  getFontSize(): 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null {
    return this.attributes['font-size'];
  }
  setFontSize(
    fontSize: 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null
  ): Damp {
    this.attributes['font-size'] = fontSize;
    return this;
  }
  getFontStyle(): 'normal' | 'italic' | null {
    return this.attributes['font-style'];
  }
  setFontStyle(fontStyle: 'normal' | 'italic' | null): Damp {
    this.attributes['font-style'] = fontStyle;
    return this;
  }
  getFontWeight(): 'normal' | 'bold' | null {
    return this.attributes['font-weight'];
  }
  setFontWeight(fontWeight: 'normal' | 'bold' | null): Damp {
    this.attributes['font-weight'] = fontWeight;
    return this;
  }
  getHalign(): 'left' | 'center' | 'right' | null {
    return this.attributes['halign'];
  }
  setHalign(halign: 'left' | 'center' | 'right' | null): Damp {
    this.attributes['halign'] = halign;
    return this;
  }
  getId(): string | null {
    return this.attributes['id'];
  }
  setId(id: string | null): Damp {
    this.attributes['id'] = id;
    return this;
  }
  getRelativeX(): number | null {
    return this.attributes['relative-x'];
  }
  setRelativeX(relativeX: number | null): Damp {
    this.attributes['relative-x'] = relativeX;
    return this;
  }
  getRelativeY(): number | null {
    return this.attributes['relative-y'];
  }
  setRelativeY(relativeY: number | null): Damp {
    this.attributes['relative-y'] = relativeY;
    return this;
  }
  getValign(): 'top' | 'middle' | 'bottom' | 'baseline' | null {
    return this.attributes['valign'];
  }
  setValign(valign: 'top' | 'middle' | 'bottom' | 'baseline' | null): Damp {
    this.attributes['valign'] = valign;
    return this;
  }
}

export type DampAllAttributes = {
  color: string | null;
  'default-x': number | null;
  'default-y': number | null;
  'font-family': string | null;
  'font-size': 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null;
  'font-style': 'normal' | 'italic' | null;
  'font-weight': 'normal' | 'bold' | null;
  halign: 'left' | 'center' | 'right' | null;
  id: string | null;
  'relative-x': number | null;
  'relative-y': number | null;
  valign: 'top' | 'middle' | 'bottom' | 'baseline' | null;
};

export type DampAllContents = [];

export class DampAll implements XMLElement<'damp-all', DampAllAttributes, DampAllContents> {
  static readonly schema = {
    name: 'damp-all',
    attributes: {
      color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
      'default-x': {
        type: 'label',
        label: 'default-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'default-y': {
        type: 'label',
        label: 'default-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
      'font-size': {
        type: 'optional',
        value: {
          type: 'choices',
          choices: [
            { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
            { type: 'float', min: -Infinity, max: Infinity },
          ],
        },
      },
      'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
      'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
      halign: { type: 'optional', value: { type: 'choices', choices: ['left', 'center', 'right'] } },
      id: { type: 'optional', value: { type: 'regex', pattern: /[A-Za-z_][A-Za-z0-9.-_]*/, zero: '_' } },
      'relative-x': {
        type: 'label',
        label: 'relative-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'relative-y': {
        type: 'label',
        label: 'relative-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      valign: { type: 'optional', value: { type: 'choices', choices: ['top', 'middle', 'bottom', 'baseline'] } },
    },
    contents: [],
  } as const;

  readonly schema = DampAll.schema;

  attributes: DampAllAttributes;
  contents: DampAllContents;

  constructor(opts?: { attributes?: Partial<DampAllAttributes>; contents?: DampAllContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, DampAll.schema);
    this.contents = opts?.contents ?? operations.zero(DampAll.schema.contents);
  }
  getColor(): string | null {
    return this.attributes['color'];
  }
  setColor(color: string | null): DampAll {
    this.attributes['color'] = color;
    return this;
  }
  getDefaultX(): number | null {
    return this.attributes['default-x'];
  }
  setDefaultX(defaultX: number | null): DampAll {
    this.attributes['default-x'] = defaultX;
    return this;
  }
  getDefaultY(): number | null {
    return this.attributes['default-y'];
  }
  setDefaultY(defaultY: number | null): DampAll {
    this.attributes['default-y'] = defaultY;
    return this;
  }
  getFontFamily(): string | null {
    return this.attributes['font-family'];
  }
  setFontFamily(fontFamily: string | null): DampAll {
    this.attributes['font-family'] = fontFamily;
    return this;
  }
  getFontSize(): 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null {
    return this.attributes['font-size'];
  }
  setFontSize(
    fontSize: 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null
  ): DampAll {
    this.attributes['font-size'] = fontSize;
    return this;
  }
  getFontStyle(): 'normal' | 'italic' | null {
    return this.attributes['font-style'];
  }
  setFontStyle(fontStyle: 'normal' | 'italic' | null): DampAll {
    this.attributes['font-style'] = fontStyle;
    return this;
  }
  getFontWeight(): 'normal' | 'bold' | null {
    return this.attributes['font-weight'];
  }
  setFontWeight(fontWeight: 'normal' | 'bold' | null): DampAll {
    this.attributes['font-weight'] = fontWeight;
    return this;
  }
  getHalign(): 'left' | 'center' | 'right' | null {
    return this.attributes['halign'];
  }
  setHalign(halign: 'left' | 'center' | 'right' | null): DampAll {
    this.attributes['halign'] = halign;
    return this;
  }
  getId(): string | null {
    return this.attributes['id'];
  }
  setId(id: string | null): DampAll {
    this.attributes['id'] = id;
    return this;
  }
  getRelativeX(): number | null {
    return this.attributes['relative-x'];
  }
  setRelativeX(relativeX: number | null): DampAll {
    this.attributes['relative-x'] = relativeX;
    return this;
  }
  getRelativeY(): number | null {
    return this.attributes['relative-y'];
  }
  setRelativeY(relativeY: number | null): DampAll {
    this.attributes['relative-y'] = relativeY;
    return this;
  }
  getValign(): 'top' | 'middle' | 'bottom' | 'baseline' | null {
    return this.attributes['valign'];
  }
  setValign(valign: 'top' | 'middle' | 'bottom' | 'baseline' | null): DampAll {
    this.attributes['valign'] = valign;
    return this;
  }
}

export type EyeglassesAttributes = {
  color: string | null;
  'default-x': number | null;
  'default-y': number | null;
  'font-family': string | null;
  'font-size': 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null;
  'font-style': 'normal' | 'italic' | null;
  'font-weight': 'normal' | 'bold' | null;
  halign: 'left' | 'center' | 'right' | null;
  id: string | null;
  'relative-x': number | null;
  'relative-y': number | null;
  valign: 'top' | 'middle' | 'bottom' | 'baseline' | null;
};

export type EyeglassesContents = [];

export class Eyeglasses implements XMLElement<'eyeglasses', EyeglassesAttributes, EyeglassesContents> {
  static readonly schema = {
    name: 'eyeglasses',
    attributes: {
      color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
      'default-x': {
        type: 'label',
        label: 'default-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'default-y': {
        type: 'label',
        label: 'default-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
      'font-size': {
        type: 'optional',
        value: {
          type: 'choices',
          choices: [
            { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
            { type: 'float', min: -Infinity, max: Infinity },
          ],
        },
      },
      'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
      'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
      halign: { type: 'optional', value: { type: 'choices', choices: ['left', 'center', 'right'] } },
      id: { type: 'optional', value: { type: 'regex', pattern: /[A-Za-z_][A-Za-z0-9.-_]*/, zero: '_' } },
      'relative-x': {
        type: 'label',
        label: 'relative-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'relative-y': {
        type: 'label',
        label: 'relative-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      valign: { type: 'optional', value: { type: 'choices', choices: ['top', 'middle', 'bottom', 'baseline'] } },
    },
    contents: [],
  } as const;

  readonly schema = Eyeglasses.schema;

  attributes: EyeglassesAttributes;
  contents: EyeglassesContents;

  constructor(opts?: { attributes?: Partial<EyeglassesAttributes>; contents?: EyeglassesContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Eyeglasses.schema);
    this.contents = opts?.contents ?? operations.zero(Eyeglasses.schema.contents);
  }
  getColor(): string | null {
    return this.attributes['color'];
  }
  setColor(color: string | null): Eyeglasses {
    this.attributes['color'] = color;
    return this;
  }
  getDefaultX(): number | null {
    return this.attributes['default-x'];
  }
  setDefaultX(defaultX: number | null): Eyeglasses {
    this.attributes['default-x'] = defaultX;
    return this;
  }
  getDefaultY(): number | null {
    return this.attributes['default-y'];
  }
  setDefaultY(defaultY: number | null): Eyeglasses {
    this.attributes['default-y'] = defaultY;
    return this;
  }
  getFontFamily(): string | null {
    return this.attributes['font-family'];
  }
  setFontFamily(fontFamily: string | null): Eyeglasses {
    this.attributes['font-family'] = fontFamily;
    return this;
  }
  getFontSize(): 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null {
    return this.attributes['font-size'];
  }
  setFontSize(
    fontSize: 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null
  ): Eyeglasses {
    this.attributes['font-size'] = fontSize;
    return this;
  }
  getFontStyle(): 'normal' | 'italic' | null {
    return this.attributes['font-style'];
  }
  setFontStyle(fontStyle: 'normal' | 'italic' | null): Eyeglasses {
    this.attributes['font-style'] = fontStyle;
    return this;
  }
  getFontWeight(): 'normal' | 'bold' | null {
    return this.attributes['font-weight'];
  }
  setFontWeight(fontWeight: 'normal' | 'bold' | null): Eyeglasses {
    this.attributes['font-weight'] = fontWeight;
    return this;
  }
  getHalign(): 'left' | 'center' | 'right' | null {
    return this.attributes['halign'];
  }
  setHalign(halign: 'left' | 'center' | 'right' | null): Eyeglasses {
    this.attributes['halign'] = halign;
    return this;
  }
  getId(): string | null {
    return this.attributes['id'];
  }
  setId(id: string | null): Eyeglasses {
    this.attributes['id'] = id;
    return this;
  }
  getRelativeX(): number | null {
    return this.attributes['relative-x'];
  }
  setRelativeX(relativeX: number | null): Eyeglasses {
    this.attributes['relative-x'] = relativeX;
    return this;
  }
  getRelativeY(): number | null {
    return this.attributes['relative-y'];
  }
  setRelativeY(relativeY: number | null): Eyeglasses {
    this.attributes['relative-y'] = relativeY;
    return this;
  }
  getValign(): 'top' | 'middle' | 'bottom' | 'baseline' | null {
    return this.attributes['valign'];
  }
  setValign(valign: 'top' | 'middle' | 'bottom' | 'baseline' | null): Eyeglasses {
    this.attributes['valign'] = valign;
    return this;
  }
}

export type StringMuteAttributes = {
  color: string | null;
  'default-x': number | null;
  'default-y': number | null;
  'font-family': string | null;
  'font-size': 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null;
  'font-style': 'normal' | 'italic' | null;
  'font-weight': 'normal' | 'bold' | null;
  halign: 'left' | 'center' | 'right' | null;
  id: string | null;
  'relative-x': number | null;
  'relative-y': number | null;
  valign: 'top' | 'middle' | 'bottom' | 'baseline' | null;
};

export type StringMuteContents = [];

export class StringMute implements XMLElement<'string-mute', StringMuteAttributes, StringMuteContents> {
  static readonly schema = {
    name: 'string-mute',
    attributes: {
      color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
      'default-x': {
        type: 'label',
        label: 'default-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'default-y': {
        type: 'label',
        label: 'default-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
      'font-size': {
        type: 'optional',
        value: {
          type: 'choices',
          choices: [
            { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
            { type: 'float', min: -Infinity, max: Infinity },
          ],
        },
      },
      'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
      'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
      halign: { type: 'optional', value: { type: 'choices', choices: ['left', 'center', 'right'] } },
      id: { type: 'optional', value: { type: 'regex', pattern: /[A-Za-z_][A-Za-z0-9.-_]*/, zero: '_' } },
      'relative-x': {
        type: 'label',
        label: 'relative-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'relative-y': {
        type: 'label',
        label: 'relative-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      valign: { type: 'optional', value: { type: 'choices', choices: ['top', 'middle', 'bottom', 'baseline'] } },
    },
    contents: [],
  } as const;

  readonly schema = StringMute.schema;

  attributes: StringMuteAttributes;
  contents: StringMuteContents;

  constructor(opts?: { attributes?: Partial<StringMuteAttributes>; contents?: StringMuteContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, StringMute.schema);
    this.contents = opts?.contents ?? operations.zero(StringMute.schema.contents);
  }
  getColor(): string | null {
    return this.attributes['color'];
  }
  setColor(color: string | null): StringMute {
    this.attributes['color'] = color;
    return this;
  }
  getDefaultX(): number | null {
    return this.attributes['default-x'];
  }
  setDefaultX(defaultX: number | null): StringMute {
    this.attributes['default-x'] = defaultX;
    return this;
  }
  getDefaultY(): number | null {
    return this.attributes['default-y'];
  }
  setDefaultY(defaultY: number | null): StringMute {
    this.attributes['default-y'] = defaultY;
    return this;
  }
  getFontFamily(): string | null {
    return this.attributes['font-family'];
  }
  setFontFamily(fontFamily: string | null): StringMute {
    this.attributes['font-family'] = fontFamily;
    return this;
  }
  getFontSize(): 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null {
    return this.attributes['font-size'];
  }
  setFontSize(
    fontSize: 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null
  ): StringMute {
    this.attributes['font-size'] = fontSize;
    return this;
  }
  getFontStyle(): 'normal' | 'italic' | null {
    return this.attributes['font-style'];
  }
  setFontStyle(fontStyle: 'normal' | 'italic' | null): StringMute {
    this.attributes['font-style'] = fontStyle;
    return this;
  }
  getFontWeight(): 'normal' | 'bold' | null {
    return this.attributes['font-weight'];
  }
  setFontWeight(fontWeight: 'normal' | 'bold' | null): StringMute {
    this.attributes['font-weight'] = fontWeight;
    return this;
  }
  getHalign(): 'left' | 'center' | 'right' | null {
    return this.attributes['halign'];
  }
  setHalign(halign: 'left' | 'center' | 'right' | null): StringMute {
    this.attributes['halign'] = halign;
    return this;
  }
  getId(): string | null {
    return this.attributes['id'];
  }
  setId(id: string | null): StringMute {
    this.attributes['id'] = id;
    return this;
  }
  getRelativeX(): number | null {
    return this.attributes['relative-x'];
  }
  setRelativeX(relativeX: number | null): StringMute {
    this.attributes['relative-x'] = relativeX;
    return this;
  }
  getRelativeY(): number | null {
    return this.attributes['relative-y'];
  }
  setRelativeY(relativeY: number | null): StringMute {
    this.attributes['relative-y'] = relativeY;
    return this;
  }
  getValign(): 'top' | 'middle' | 'bottom' | 'baseline' | null {
    return this.attributes['valign'];
  }
  setValign(valign: 'top' | 'middle' | 'bottom' | 'baseline' | null): StringMute {
    this.attributes['valign'] = valign;
    return this;
  }
}

export type TuningStepAttributes = Record<string, unknown>;

export type TuningStepContents = ['A' | 'B' | 'C' | 'D' | 'E' | 'F' | 'G'];

export class TuningStep implements XMLElement<'tuning-step', TuningStepAttributes, TuningStepContents> {
  static readonly schema = {
    name: 'tuning-step',
    attributes: {},
    contents: [
      {
        type: 'required',
        value: {
          type: 'label',
          label: 'step',
          value: { type: 'choices', choices: ['A', 'B', 'C', 'D', 'E', 'F', 'G'] },
        },
      },
    ],
  } as const;

  readonly schema = TuningStep.schema;

  attributes: TuningStepAttributes;
  contents: TuningStepContents;

  constructor(opts?: { attributes?: Partial<TuningStepAttributes>; contents?: TuningStepContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, TuningStep.schema);
    this.contents = opts?.contents ?? operations.zero(TuningStep.schema.contents);
  }

  getStep(): 'A' | 'B' | 'C' | 'D' | 'E' | 'F' | 'G' {
    return this.contents[0];
  }
  setStep(step: 'A' | 'B' | 'C' | 'D' | 'E' | 'F' | 'G'): TuningStep {
    this.contents[0] = step;
    return this;
  }
}

export type TuningAlterAttributes = Record<string, unknown>;

export type TuningAlterContents = [number];

export class TuningAlter implements XMLElement<'tuning-alter', TuningAlterAttributes, TuningAlterContents> {
  static readonly schema = {
    name: 'tuning-alter',
    attributes: {},
    contents: [
      {
        type: 'required',
        value: { type: 'label', label: 'semitones', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
    ],
  } as const;

  readonly schema = TuningAlter.schema;

  attributes: TuningAlterAttributes;
  contents: TuningAlterContents;

  constructor(opts?: { attributes?: Partial<TuningAlterAttributes>; contents?: TuningAlterContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, TuningAlter.schema);
    this.contents = opts?.contents ?? operations.zero(TuningAlter.schema.contents);
  }

  getSemitones(): number {
    return this.contents[0];
  }
  setSemitones(semitones: number): TuningAlter {
    this.contents[0] = semitones;
    return this;
  }
}

export type TuningOctaveAttributes = Record<string, unknown>;

export type TuningOctaveContents = [number];

export class TuningOctave implements XMLElement<'tuning-octave', TuningOctaveAttributes, TuningOctaveContents> {
  static readonly schema = {
    name: 'tuning-octave',
    attributes: {},
    contents: [{ type: 'required', value: { type: 'label', label: 'octave', value: { type: 'int', min: 0, max: 9 } } }],
  } as const;

  readonly schema = TuningOctave.schema;

  attributes: TuningOctaveAttributes;
  contents: TuningOctaveContents;

  constructor(opts?: { attributes?: Partial<TuningOctaveAttributes>; contents?: TuningOctaveContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, TuningOctave.schema);
    this.contents = opts?.contents ?? operations.zero(TuningOctave.schema.contents);
  }

  getOctave(): number {
    return this.contents[0];
  }
  setOctave(octave: number): TuningOctave {
    this.contents[0] = octave;
    return this;
  }
}

export type AccordAttributes = { string: number | null };

export type AccordContents = [TuningStep, TuningAlter | null, TuningOctave];

export class Accord implements XMLElement<'accord', AccordAttributes, AccordContents> {
  static readonly schema = {
    name: 'accord',
    attributes: { string: { type: 'optional', value: { type: 'int', min: 1, max: Infinity } } },
    contents: [
      { type: 'required', value: TuningStep },
      { type: 'optional', value: TuningAlter },
      { type: 'required', value: TuningOctave },
    ],
  } as const;

  readonly schema = Accord.schema;

  attributes: AccordAttributes;
  contents: AccordContents;

  constructor(opts?: { attributes?: Partial<AccordAttributes>; contents?: AccordContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Accord.schema);
    this.contents = opts?.contents ?? operations.zero(Accord.schema.contents);
  }
  getString(): number | null {
    return this.attributes['string'];
  }
  setString(string: number | null): Accord {
    this.attributes['string'] = string;
    return this;
  }
  getTuningStep(): TuningStep {
    return this.contents[0];
  }
  setTuningStep(tuningStep: TuningStep): Accord {
    this.contents[0] = tuningStep;
    return this;
  }
  getTuningAlter(): TuningAlter | null {
    return this.contents[1];
  }
  setTuningAlter(tuningAlter: TuningAlter | null): Accord {
    this.contents[1] = tuningAlter;
    return this;
  }
  getTuningOctave(): TuningOctave {
    return this.contents[2];
  }
  setTuningOctave(tuningOctave: TuningOctave): Accord {
    this.contents[2] = tuningOctave;
    return this;
  }
}

export type ScordaturaAttributes = { id: string | null };

export type ScordaturaContents = [Array<Accord>];

export class Scordatura implements XMLElement<'scordatura', ScordaturaAttributes, ScordaturaContents> {
  static readonly schema = {
    name: 'scordatura',
    attributes: { id: { type: 'optional', value: { type: 'regex', pattern: /[A-Za-z_][A-Za-z0-9.-_]*/, zero: '_' } } },
    contents: [{ type: 'label', label: 'accords', value: { type: 'oneOrMore', value: Accord } }],
  } as const;

  readonly schema = Scordatura.schema;

  attributes: ScordaturaAttributes;
  contents: ScordaturaContents;

  constructor(opts?: { attributes?: Partial<ScordaturaAttributes>; contents?: ScordaturaContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Scordatura.schema);
    this.contents = opts?.contents ?? operations.zero(Scordatura.schema.contents);
  }
  getId(): string | null {
    return this.attributes['id'];
  }
  setId(id: string | null): Scordatura {
    this.attributes['id'] = id;
    return this;
  }
  getAccords(): Array<Accord> {
    return this.contents[0];
  }
  setAccords(accords: Array<Accord>): Scordatura {
    this.contents[0] = accords;
    return this;
  }
}

export type ImageAttributes = {
  source: string;
  type: string;
  'default-x': number | null;
  'default-y': number | null;
  halign: 'left' | 'center' | 'right' | null;
  id: string | null;
  'relative-x': number | null;
  'relative-y': number | null;
  valign: 'top' | 'middle' | 'bottom' | 'baseline' | null;
  width: number | null;
};

export type ImageContents = [];

export class Image implements XMLElement<'image', ImageAttributes, ImageContents> {
  static readonly schema = {
    name: 'image',
    attributes: {
      source: { type: 'required', value: { type: 'string' } },
      type: { type: 'required', value: { type: 'string' } },
      'default-x': {
        type: 'label',
        label: 'default-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'default-y': {
        type: 'label',
        label: 'default-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      halign: { type: 'optional', value: { type: 'choices', choices: ['left', 'center', 'right'] } },
      id: { type: 'optional', value: { type: 'regex', pattern: /[A-Za-z_][A-Za-z0-9.-_]*/, zero: '_' } },
      'relative-x': {
        type: 'label',
        label: 'relative-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'relative-y': {
        type: 'label',
        label: 'relative-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      valign: { type: 'optional', value: { type: 'choices', choices: ['top', 'middle', 'bottom', 'baseline'] } },
      width: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
    },
    contents: [],
  } as const;

  readonly schema = Image.schema;

  attributes: ImageAttributes;
  contents: ImageContents;

  constructor(opts?: { attributes?: Partial<ImageAttributes>; contents?: ImageContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Image.schema);
    this.contents = opts?.contents ?? operations.zero(Image.schema.contents);
  }
  getSource(): string {
    return this.attributes['source'];
  }
  setSource(source: string): Image {
    this.attributes['source'] = source;
    return this;
  }
  getType(): string {
    return this.attributes['type'];
  }
  setType(type: string): Image {
    this.attributes['type'] = type;
    return this;
  }
  getDefaultX(): number | null {
    return this.attributes['default-x'];
  }
  setDefaultX(defaultX: number | null): Image {
    this.attributes['default-x'] = defaultX;
    return this;
  }
  getDefaultY(): number | null {
    return this.attributes['default-y'];
  }
  setDefaultY(defaultY: number | null): Image {
    this.attributes['default-y'] = defaultY;
    return this;
  }
  getHalign(): 'left' | 'center' | 'right' | null {
    return this.attributes['halign'];
  }
  setHalign(halign: 'left' | 'center' | 'right' | null): Image {
    this.attributes['halign'] = halign;
    return this;
  }
  getId(): string | null {
    return this.attributes['id'];
  }
  setId(id: string | null): Image {
    this.attributes['id'] = id;
    return this;
  }
  getRelativeX(): number | null {
    return this.attributes['relative-x'];
  }
  setRelativeX(relativeX: number | null): Image {
    this.attributes['relative-x'] = relativeX;
    return this;
  }
  getRelativeY(): number | null {
    return this.attributes['relative-y'];
  }
  setRelativeY(relativeY: number | null): Image {
    this.attributes['relative-y'] = relativeY;
    return this;
  }
  getValign(): 'top' | 'middle' | 'bottom' | 'baseline' | null {
    return this.attributes['valign'];
  }
  setValign(valign: 'top' | 'middle' | 'bottom' | 'baseline' | null): Image {
    this.attributes['valign'] = valign;
    return this;
  }
  getWidth(): number | null {
    return this.attributes['width'];
  }
  setWidth(width: number | null): Image {
    this.attributes['width'] = width;
    return this;
  }
}

export type PrincipalVoiceAttributes = {
  symbol: 'none' | 'Hauptstimme' | 'Nebenstimme' | 'plain';
  type: 'start' | 'stop';
  color: string | null;
  'default-x': number | null;
  'default-y': number | null;
  'font-family': string | null;
  'font-size': 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null;
  'font-style': 'normal' | 'italic' | null;
  'font-weight': 'normal' | 'bold' | null;
  halign: 'left' | 'center' | 'right' | null;
  id: string | null;
  'relative-x': number | null;
  'relative-y': number | null;
  valign: 'top' | 'middle' | 'bottom' | 'baseline' | null;
};

export type PrincipalVoiceContents = [string];

export class PrincipalVoice implements XMLElement<'principal-voice', PrincipalVoiceAttributes, PrincipalVoiceContents> {
  static readonly schema = {
    name: 'principal-voice',
    attributes: {
      symbol: {
        type: 'required',
        value: { type: 'choices', choices: ['none', 'Hauptstimme', 'Nebenstimme', 'plain'] },
      },
      type: { type: 'required', value: { type: 'choices', choices: ['start', 'stop'] } },
      color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
      'default-x': {
        type: 'label',
        label: 'default-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'default-y': {
        type: 'label',
        label: 'default-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
      'font-size': {
        type: 'optional',
        value: {
          type: 'choices',
          choices: [
            { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
            { type: 'float', min: -Infinity, max: Infinity },
          ],
        },
      },
      'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
      'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
      halign: { type: 'optional', value: { type: 'choices', choices: ['left', 'center', 'right'] } },
      id: { type: 'optional', value: { type: 'regex', pattern: /[A-Za-z_][A-Za-z0-9.-_]*/, zero: '_' } },
      'relative-x': {
        type: 'label',
        label: 'relative-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'relative-y': {
        type: 'label',
        label: 'relative-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      valign: { type: 'optional', value: { type: 'choices', choices: ['top', 'middle', 'bottom', 'baseline'] } },
    },
    contents: [{ type: 'required', value: { type: 'string' } }],
  } as const;

  readonly schema = PrincipalVoice.schema;

  attributes: PrincipalVoiceAttributes;
  contents: PrincipalVoiceContents;

  constructor(opts?: { attributes?: Partial<PrincipalVoiceAttributes>; contents?: PrincipalVoiceContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, PrincipalVoice.schema);
    this.contents = opts?.contents ?? operations.zero(PrincipalVoice.schema.contents);
  }
  getSymbol(): 'none' | 'Hauptstimme' | 'Nebenstimme' | 'plain' {
    return this.attributes['symbol'];
  }
  setSymbol(symbol: 'none' | 'Hauptstimme' | 'Nebenstimme' | 'plain'): PrincipalVoice {
    this.attributes['symbol'] = symbol;
    return this;
  }
  getType(): 'start' | 'stop' {
    return this.attributes['type'];
  }
  setType(type: 'start' | 'stop'): PrincipalVoice {
    this.attributes['type'] = type;
    return this;
  }
  getColor(): string | null {
    return this.attributes['color'];
  }
  setColor(color: string | null): PrincipalVoice {
    this.attributes['color'] = color;
    return this;
  }
  getDefaultX(): number | null {
    return this.attributes['default-x'];
  }
  setDefaultX(defaultX: number | null): PrincipalVoice {
    this.attributes['default-x'] = defaultX;
    return this;
  }
  getDefaultY(): number | null {
    return this.attributes['default-y'];
  }
  setDefaultY(defaultY: number | null): PrincipalVoice {
    this.attributes['default-y'] = defaultY;
    return this;
  }
  getFontFamily(): string | null {
    return this.attributes['font-family'];
  }
  setFontFamily(fontFamily: string | null): PrincipalVoice {
    this.attributes['font-family'] = fontFamily;
    return this;
  }
  getFontSize(): 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null {
    return this.attributes['font-size'];
  }
  setFontSize(
    fontSize: 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null
  ): PrincipalVoice {
    this.attributes['font-size'] = fontSize;
    return this;
  }
  getFontStyle(): 'normal' | 'italic' | null {
    return this.attributes['font-style'];
  }
  setFontStyle(fontStyle: 'normal' | 'italic' | null): PrincipalVoice {
    this.attributes['font-style'] = fontStyle;
    return this;
  }
  getFontWeight(): 'normal' | 'bold' | null {
    return this.attributes['font-weight'];
  }
  setFontWeight(fontWeight: 'normal' | 'bold' | null): PrincipalVoice {
    this.attributes['font-weight'] = fontWeight;
    return this;
  }
  getHalign(): 'left' | 'center' | 'right' | null {
    return this.attributes['halign'];
  }
  setHalign(halign: 'left' | 'center' | 'right' | null): PrincipalVoice {
    this.attributes['halign'] = halign;
    return this;
  }
  getId(): string | null {
    return this.attributes['id'];
  }
  setId(id: string | null): PrincipalVoice {
    this.attributes['id'] = id;
    return this;
  }
  getRelativeX(): number | null {
    return this.attributes['relative-x'];
  }
  setRelativeX(relativeX: number | null): PrincipalVoice {
    this.attributes['relative-x'] = relativeX;
    return this;
  }
  getRelativeY(): number | null {
    return this.attributes['relative-y'];
  }
  setRelativeY(relativeY: number | null): PrincipalVoice {
    this.attributes['relative-y'] = relativeY;
    return this;
  }
  getValign(): 'top' | 'middle' | 'bottom' | 'baseline' | null {
    return this.attributes['valign'];
  }
  setValign(valign: 'top' | 'middle' | 'bottom' | 'baseline' | null): PrincipalVoice {
    this.attributes['valign'] = valign;
    return this;
  }
  getText(): string {
    return this.contents[0];
  }
  setText(text: string): PrincipalVoice {
    this.contents[0] = text;
    return this;
  }
}

export type GlassAttributes = { smufl: string | null };

export type GlassContents = ['glass harmonica' | 'glass harp' | 'wind chimes'];

export class Glass implements XMLElement<'glass', GlassAttributes, GlassContents> {
  static readonly schema = {
    name: 'glass',
    attributes: { smufl: { type: 'optional', value: { type: 'regex', pattern: /pict/, zero: 'pict' } } },
    contents: [
      {
        type: 'required',
        value: {
          type: 'label',
          label: 'glass-value',
          value: { type: 'choices', choices: ['glass harmonica', 'glass harp', 'wind chimes'] },
        },
      },
    ],
  } as const;

  readonly schema = Glass.schema;

  attributes: GlassAttributes;
  contents: GlassContents;

  constructor(opts?: { attributes?: Partial<GlassAttributes>; contents?: GlassContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Glass.schema);
    this.contents = opts?.contents ?? operations.zero(Glass.schema.contents);
  }
  getSmufl(): string | null {
    return this.attributes['smufl'];
  }
  setSmufl(smufl: string | null): Glass {
    this.attributes['smufl'] = smufl;
    return this;
  }
  getGlassValue(): 'glass harmonica' | 'glass harp' | 'wind chimes' {
    return this.contents[0];
  }
  setGlassValue(glassValue: 'glass harmonica' | 'glass harp' | 'wind chimes'): Glass {
    this.contents[0] = glassValue;
    return this;
  }
}

export type MetalAttributes = { smufl: string | null };

export type MetalContents = [
  | 'agogo'
  | 'almglocken'
  | 'bell'
  | 'bell plate'
  | 'bell tree'
  | 'brake drum'
  | 'cencerro'
  | 'chain rattle'
  | 'Chinese cymbal'
  | 'cowbell'
  | 'crash cymbals'
  | 'crotale'
  | 'cymbal tongs'
  | 'domed gong'
  | 'finger cymbals'
  | 'flexatone'
  | 'gong'
  | 'handbell'
  | 'hi-hat'
  | 'high-hat cymbals'
  | 'jaw harp'
  | 'jingle bells'
  | 'musical saw'
  | 'shell bells'
  | 'sistrum'
  | 'sizzle cymbal'
  | 'sleigh bells'
  | 'suspended cymbal'
  | 'tam tam'
  | 'tam tam with beater'
  | 'triangle'
  | 'Vietnamese hat'
];

export class Metal implements XMLElement<'metal', MetalAttributes, MetalContents> {
  static readonly schema = {
    name: 'metal',
    attributes: { smufl: { type: 'optional', value: { type: 'regex', pattern: /pict/, zero: 'pict' } } },
    contents: [
      {
        type: 'required',
        value: {
          type: 'label',
          label: 'metal-value',
          value: {
            type: 'choices',
            choices: [
              'agogo',
              'almglocken',
              'bell',
              'bell plate',
              'bell tree',
              'brake drum',
              'cencerro',
              'chain rattle',
              'Chinese cymbal',
              'cowbell',
              'crash cymbals',
              'crotale',
              'cymbal tongs',
              'domed gong',
              'finger cymbals',
              'flexatone',
              'gong',
              'handbell',
              'hi-hat',
              'high-hat cymbals',
              'jaw harp',
              'jingle bells',
              'musical saw',
              'shell bells',
              'sistrum',
              'sizzle cymbal',
              'sleigh bells',
              'suspended cymbal',
              'tam tam',
              'tam tam with beater',
              'triangle',
              'Vietnamese hat',
            ],
          },
        },
      },
    ],
  } as const;

  readonly schema = Metal.schema;

  attributes: MetalAttributes;
  contents: MetalContents;

  constructor(opts?: { attributes?: Partial<MetalAttributes>; contents?: MetalContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Metal.schema);
    this.contents = opts?.contents ?? operations.zero(Metal.schema.contents);
  }
  getSmufl(): string | null {
    return this.attributes['smufl'];
  }
  setSmufl(smufl: string | null): Metal {
    this.attributes['smufl'] = smufl;
    return this;
  }
  getMetalValue():
    | 'agogo'
    | 'almglocken'
    | 'bell'
    | 'bell plate'
    | 'bell tree'
    | 'brake drum'
    | 'cencerro'
    | 'chain rattle'
    | 'Chinese cymbal'
    | 'cowbell'
    | 'crash cymbals'
    | 'crotale'
    | 'cymbal tongs'
    | 'domed gong'
    | 'finger cymbals'
    | 'flexatone'
    | 'gong'
    | 'handbell'
    | 'hi-hat'
    | 'high-hat cymbals'
    | 'jaw harp'
    | 'jingle bells'
    | 'musical saw'
    | 'shell bells'
    | 'sistrum'
    | 'sizzle cymbal'
    | 'sleigh bells'
    | 'suspended cymbal'
    | 'tam tam'
    | 'tam tam with beater'
    | 'triangle'
    | 'Vietnamese hat' {
    return this.contents[0];
  }
  setMetalValue(
    metalValue:
      | 'agogo'
      | 'almglocken'
      | 'bell'
      | 'bell plate'
      | 'bell tree'
      | 'brake drum'
      | 'cencerro'
      | 'chain rattle'
      | 'Chinese cymbal'
      | 'cowbell'
      | 'crash cymbals'
      | 'crotale'
      | 'cymbal tongs'
      | 'domed gong'
      | 'finger cymbals'
      | 'flexatone'
      | 'gong'
      | 'handbell'
      | 'hi-hat'
      | 'high-hat cymbals'
      | 'jaw harp'
      | 'jingle bells'
      | 'musical saw'
      | 'shell bells'
      | 'sistrum'
      | 'sizzle cymbal'
      | 'sleigh bells'
      | 'suspended cymbal'
      | 'tam tam'
      | 'tam tam with beater'
      | 'triangle'
      | 'Vietnamese hat'
  ): Metal {
    this.contents[0] = metalValue;
    return this;
  }
}

export type WoodAttributes = { smufl: string | null };

export type WoodContents = [
  | 'bamboo scraper'
  | 'board clapper'
  | 'cabasa'
  | 'castanets'
  | 'castanets with handle'
  | 'claves'
  | 'footbal rattle'
  | 'guiro'
  | 'log drum'
  | 'maraca'
  | 'maracas'
  | 'quijada'
  | 'rainstick'
  | 'ratchet'
  | 'reco-reco'
  | 'sandpaper blocks'
  | 'slit drum'
  | 'temple block'
  | 'vibraslap'
  | 'whip'
  | 'wood block'
];

export class Wood implements XMLElement<'wood', WoodAttributes, WoodContents> {
  static readonly schema = {
    name: 'wood',
    attributes: { smufl: { type: 'optional', value: { type: 'regex', pattern: /pict/, zero: 'pict' } } },
    contents: [
      {
        type: 'required',
        value: {
          type: 'label',
          label: 'wood-value',
          value: {
            type: 'choices',
            choices: [
              'bamboo scraper',
              'board clapper',
              'cabasa',
              'castanets',
              'castanets with handle',
              'claves',
              'footbal rattle',
              'guiro',
              'log drum',
              'maraca',
              'maracas',
              'quijada',
              'rainstick',
              'ratchet',
              'reco-reco',
              'sandpaper blocks',
              'slit drum',
              'temple block',
              'vibraslap',
              'whip',
              'wood block',
            ],
          },
        },
      },
    ],
  } as const;

  readonly schema = Wood.schema;

  attributes: WoodAttributes;
  contents: WoodContents;

  constructor(opts?: { attributes?: Partial<WoodAttributes>; contents?: WoodContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Wood.schema);
    this.contents = opts?.contents ?? operations.zero(Wood.schema.contents);
  }
  getSmufl(): string | null {
    return this.attributes['smufl'];
  }
  setSmufl(smufl: string | null): Wood {
    this.attributes['smufl'] = smufl;
    return this;
  }
  getWoodValue():
    | 'bamboo scraper'
    | 'board clapper'
    | 'cabasa'
    | 'castanets'
    | 'castanets with handle'
    | 'claves'
    | 'footbal rattle'
    | 'guiro'
    | 'log drum'
    | 'maraca'
    | 'maracas'
    | 'quijada'
    | 'rainstick'
    | 'ratchet'
    | 'reco-reco'
    | 'sandpaper blocks'
    | 'slit drum'
    | 'temple block'
    | 'vibraslap'
    | 'whip'
    | 'wood block' {
    return this.contents[0];
  }
  setWoodValue(
    woodValue:
      | 'bamboo scraper'
      | 'board clapper'
      | 'cabasa'
      | 'castanets'
      | 'castanets with handle'
      | 'claves'
      | 'footbal rattle'
      | 'guiro'
      | 'log drum'
      | 'maraca'
      | 'maracas'
      | 'quijada'
      | 'rainstick'
      | 'ratchet'
      | 'reco-reco'
      | 'sandpaper blocks'
      | 'slit drum'
      | 'temple block'
      | 'vibraslap'
      | 'whip'
      | 'wood block'
  ): Wood {
    this.contents[0] = woodValue;
    return this;
  }
}

export type PitchedAttributes = { smufl: string | null };

export type PitchedContents = [];

export class Pitched implements XMLElement<'pitched', PitchedAttributes, PitchedContents> {
  static readonly schema = {
    name: 'pitched',
    attributes: { smufl: { type: 'optional', value: { type: 'regex', pattern: /pict/, zero: 'pict' } } },
    contents: [],
  } as const;

  readonly schema = Pitched.schema;

  attributes: PitchedAttributes;
  contents: PitchedContents;

  constructor(opts?: { attributes?: Partial<PitchedAttributes>; contents?: PitchedContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Pitched.schema);
    this.contents = opts?.contents ?? operations.zero(Pitched.schema.contents);
  }
  getSmufl(): string | null {
    return this.attributes['smufl'];
  }
  setSmufl(smufl: string | null): Pitched {
    this.attributes['smufl'] = smufl;
    return this;
  }
}

export type MembraneAttributes = { smufl: string | null };

export type MembraneContents = [
  | 'bass drum'
  | 'bass drum on side'
  | 'bongos'
  | 'Chinese tomtom'
  | 'conga drum'
  | 'cuica'
  | 'goblet drum'
  | 'Indo-American tomtom'
  | 'Japanese tomtom'
  | 'military drum'
  | 'snare drum'
  | 'snare drum snares off'
  | 'tabla'
  | 'tambourine'
  | 'tenor drum'
  | 'timbales'
  | 'tomtom'
];

export class Membrane implements XMLElement<'membrane', MembraneAttributes, MembraneContents> {
  static readonly schema = {
    name: 'membrane',
    attributes: { smufl: { type: 'optional', value: { type: 'regex', pattern: /pict/, zero: 'pict' } } },
    contents: [
      {
        type: 'required',
        value: {
          type: 'label',
          label: 'membrane-value',
          value: {
            type: 'choices',
            choices: [
              'bass drum',
              'bass drum on side',
              'bongos',
              'Chinese tomtom',
              'conga drum',
              'cuica',
              'goblet drum',
              'Indo-American tomtom',
              'Japanese tomtom',
              'military drum',
              'snare drum',
              'snare drum snares off',
              'tabla',
              'tambourine',
              'tenor drum',
              'timbales',
              'tomtom',
            ],
          },
        },
      },
    ],
  } as const;

  readonly schema = Membrane.schema;

  attributes: MembraneAttributes;
  contents: MembraneContents;

  constructor(opts?: { attributes?: Partial<MembraneAttributes>; contents?: MembraneContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Membrane.schema);
    this.contents = opts?.contents ?? operations.zero(Membrane.schema.contents);
  }
  getSmufl(): string | null {
    return this.attributes['smufl'];
  }
  setSmufl(smufl: string | null): Membrane {
    this.attributes['smufl'] = smufl;
    return this;
  }
  getMembraneValue():
    | 'bass drum'
    | 'bass drum on side'
    | 'bongos'
    | 'Chinese tomtom'
    | 'conga drum'
    | 'cuica'
    | 'goblet drum'
    | 'Indo-American tomtom'
    | 'Japanese tomtom'
    | 'military drum'
    | 'snare drum'
    | 'snare drum snares off'
    | 'tabla'
    | 'tambourine'
    | 'tenor drum'
    | 'timbales'
    | 'tomtom' {
    return this.contents[0];
  }
  setMembraneValue(
    membraneValue:
      | 'bass drum'
      | 'bass drum on side'
      | 'bongos'
      | 'Chinese tomtom'
      | 'conga drum'
      | 'cuica'
      | 'goblet drum'
      | 'Indo-American tomtom'
      | 'Japanese tomtom'
      | 'military drum'
      | 'snare drum'
      | 'snare drum snares off'
      | 'tabla'
      | 'tambourine'
      | 'tenor drum'
      | 'timbales'
      | 'tomtom'
  ): Membrane {
    this.contents[0] = membraneValue;
    return this;
  }
}

export type EffectAttributes = { smufl: string | null };

export type EffectContents = [
  | 'anvil'
  | 'auto horn'
  | 'bird whistle'
  | 'cannon'
  | 'duck call'
  | 'gun shot'
  | 'klaxon horn'
  | 'lions roar'
  | 'lotus flute'
  | 'megaphone'
  | 'police whistle'
  | 'siren'
  | 'slide whistle'
  | 'thunder sheet'
  | 'wind machine'
  | 'wind whistle'
];

export class Effect implements XMLElement<'effect', EffectAttributes, EffectContents> {
  static readonly schema = {
    name: 'effect',
    attributes: { smufl: { type: 'optional', value: { type: 'regex', pattern: /pict/, zero: 'pict' } } },
    contents: [
      {
        type: 'required',
        value: {
          type: 'label',
          label: 'effect-value',
          value: {
            type: 'choices',
            choices: [
              'anvil',
              'auto horn',
              'bird whistle',
              'cannon',
              'duck call',
              'gun shot',
              'klaxon horn',
              'lions roar',
              'lotus flute',
              'megaphone',
              'police whistle',
              'siren',
              'slide whistle',
              'thunder sheet',
              'wind machine',
              'wind whistle',
            ],
          },
        },
      },
    ],
  } as const;

  readonly schema = Effect.schema;

  attributes: EffectAttributes;
  contents: EffectContents;

  constructor(opts?: { attributes?: Partial<EffectAttributes>; contents?: EffectContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Effect.schema);
    this.contents = opts?.contents ?? operations.zero(Effect.schema.contents);
  }
  getSmufl(): string | null {
    return this.attributes['smufl'];
  }
  setSmufl(smufl: string | null): Effect {
    this.attributes['smufl'] = smufl;
    return this;
  }
  getEffectValue():
    | 'anvil'
    | 'auto horn'
    | 'bird whistle'
    | 'cannon'
    | 'duck call'
    | 'gun shot'
    | 'klaxon horn'
    | 'lions roar'
    | 'lotus flute'
    | 'megaphone'
    | 'police whistle'
    | 'siren'
    | 'slide whistle'
    | 'thunder sheet'
    | 'wind machine'
    | 'wind whistle' {
    return this.contents[0];
  }
  setEffectValue(
    effectValue:
      | 'anvil'
      | 'auto horn'
      | 'bird whistle'
      | 'cannon'
      | 'duck call'
      | 'gun shot'
      | 'klaxon horn'
      | 'lions roar'
      | 'lotus flute'
      | 'megaphone'
      | 'police whistle'
      | 'siren'
      | 'slide whistle'
      | 'thunder sheet'
      | 'wind machine'
      | 'wind whistle'
  ): Effect {
    this.contents[0] = effectValue;
    return this;
  }
}

export type TimpaniAttributes = { smufl: string | null };

export type TimpaniContents = [];

export class Timpani implements XMLElement<'timpani', TimpaniAttributes, TimpaniContents> {
  static readonly schema = {
    name: 'timpani',
    attributes: { smufl: { type: 'optional', value: { type: 'regex', pattern: /pict/, zero: 'pict' } } },
    contents: [],
  } as const;

  readonly schema = Timpani.schema;

  attributes: TimpaniAttributes;
  contents: TimpaniContents;

  constructor(opts?: { attributes?: Partial<TimpaniAttributes>; contents?: TimpaniContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Timpani.schema);
    this.contents = opts?.contents ?? operations.zero(Timpani.schema.contents);
  }
  getSmufl(): string | null {
    return this.attributes['smufl'];
  }
  setSmufl(smufl: string | null): Timpani {
    this.attributes['smufl'] = smufl;
    return this;
  }
}

export type BeaterAttributes = {
  tip: 'down' | 'left' | 'northeast' | 'northwest' | 'right' | 'southeast' | 'southwest' | 'up' | null;
};

export type BeaterContents = [
  | 'bow'
  | 'chime hammer'
  | 'coin'
  | 'drum stick'
  | 'finger'
  | 'fingernail'
  | 'fist'
  | 'guiro scraper'
  | 'hammer'
  | 'hand'
  | 'jazz stick'
  | 'knitting needle'
  | 'metal hammer'
  | 'slide brush on gong'
  | 'snare stick'
  | 'spoon mallet'
  | 'superball'
  | 'triangle beater'
  | 'triangle beater plain'
  | 'wire brush'
];

export class Beater implements XMLElement<'beater', BeaterAttributes, BeaterContents> {
  static readonly schema = {
    name: 'beater',
    attributes: {
      tip: {
        type: 'optional',
        value: {
          type: 'choices',
          choices: ['down', 'left', 'northeast', 'northwest', 'right', 'southeast', 'southwest', 'up'],
        },
      },
    },
    contents: [
      {
        type: 'required',
        value: {
          type: 'label',
          label: 'beater-value',
          value: {
            type: 'choices',
            choices: [
              'bow',
              'chime hammer',
              'coin',
              'drum stick',
              'finger',
              'fingernail',
              'fist',
              'guiro scraper',
              'hammer',
              'hand',
              'jazz stick',
              'knitting needle',
              'metal hammer',
              'slide brush on gong',
              'snare stick',
              'spoon mallet',
              'superball',
              'triangle beater',
              'triangle beater plain',
              'wire brush',
            ],
          },
        },
      },
    ],
  } as const;

  readonly schema = Beater.schema;

  attributes: BeaterAttributes;
  contents: BeaterContents;

  constructor(opts?: { attributes?: Partial<BeaterAttributes>; contents?: BeaterContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Beater.schema);
    this.contents = opts?.contents ?? operations.zero(Beater.schema.contents);
  }
  getTip(): 'down' | 'left' | 'northeast' | 'northwest' | 'right' | 'southeast' | 'southwest' | 'up' | null {
    return this.attributes['tip'];
  }
  setTip(tip: 'down' | 'left' | 'northeast' | 'northwest' | 'right' | 'southeast' | 'southwest' | 'up' | null): Beater {
    this.attributes['tip'] = tip;
    return this;
  }
  getBeaterValue():
    | 'bow'
    | 'chime hammer'
    | 'coin'
    | 'drum stick'
    | 'finger'
    | 'fingernail'
    | 'fist'
    | 'guiro scraper'
    | 'hammer'
    | 'hand'
    | 'jazz stick'
    | 'knitting needle'
    | 'metal hammer'
    | 'slide brush on gong'
    | 'snare stick'
    | 'spoon mallet'
    | 'superball'
    | 'triangle beater'
    | 'triangle beater plain'
    | 'wire brush' {
    return this.contents[0];
  }
  setBeaterValue(
    beaterValue:
      | 'bow'
      | 'chime hammer'
      | 'coin'
      | 'drum stick'
      | 'finger'
      | 'fingernail'
      | 'fist'
      | 'guiro scraper'
      | 'hammer'
      | 'hand'
      | 'jazz stick'
      | 'knitting needle'
      | 'metal hammer'
      | 'slide brush on gong'
      | 'snare stick'
      | 'spoon mallet'
      | 'superball'
      | 'triangle beater'
      | 'triangle beater plain'
      | 'wire brush'
  ): Beater {
    this.contents[0] = beaterValue;
    return this;
  }
}

export type StickTypeAttributes = Record<string, unknown>;

export type StickTypeContents = [
  | 'bass drum'
  | 'double bass drum'
  | 'glockenspiel'
  | 'gum'
  | 'hammer'
  | 'superball'
  | 'timpani'
  | 'wound'
  | 'xylophone'
  | 'yarn'
];

export class StickType implements XMLElement<'stick-type', StickTypeAttributes, StickTypeContents> {
  static readonly schema = {
    name: 'stick-type',
    attributes: {},
    contents: [
      {
        type: 'required',
        value: {
          type: 'label',
          label: 'stick-type',
          value: {
            type: 'choices',
            choices: [
              'bass drum',
              'double bass drum',
              'glockenspiel',
              'gum',
              'hammer',
              'superball',
              'timpani',
              'wound',
              'xylophone',
              'yarn',
            ],
          },
        },
      },
    ],
  } as const;

  readonly schema = StickType.schema;

  attributes: StickTypeAttributes;
  contents: StickTypeContents;

  constructor(opts?: { attributes?: Partial<StickTypeAttributes>; contents?: StickTypeContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, StickType.schema);
    this.contents = opts?.contents ?? operations.zero(StickType.schema.contents);
  }

  getStickType():
    | 'bass drum'
    | 'double bass drum'
    | 'glockenspiel'
    | 'gum'
    | 'hammer'
    | 'superball'
    | 'timpani'
    | 'wound'
    | 'xylophone'
    | 'yarn' {
    return this.contents[0];
  }
  setStickType(
    stickType:
      | 'bass drum'
      | 'double bass drum'
      | 'glockenspiel'
      | 'gum'
      | 'hammer'
      | 'superball'
      | 'timpani'
      | 'wound'
      | 'xylophone'
      | 'yarn'
  ): StickType {
    this.contents[0] = stickType;
    return this;
  }
}

export type StickMaterialAttributes = Record<string, unknown>;

export type StickMaterialContents = ['x' | 'hard' | 'medium' | 'shaded' | 'soft'];

export class StickMaterial implements XMLElement<'stick-material', StickMaterialAttributes, StickMaterialContents> {
  static readonly schema = {
    name: 'stick-material',
    attributes: {},
    contents: [
      {
        type: 'required',
        value: {
          type: 'label',
          label: 'stick-material',
          value: { type: 'choices', choices: ['x', 'hard', 'medium', 'shaded', 'soft'] },
        },
      },
    ],
  } as const;

  readonly schema = StickMaterial.schema;

  attributes: StickMaterialAttributes;
  contents: StickMaterialContents;

  constructor(opts?: { attributes?: Partial<StickMaterialAttributes>; contents?: StickMaterialContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, StickMaterial.schema);
    this.contents = opts?.contents ?? operations.zero(StickMaterial.schema.contents);
  }

  getStickMaterial(): 'x' | 'hard' | 'medium' | 'shaded' | 'soft' {
    return this.contents[0];
  }
  setStickMaterial(stickMaterial: 'x' | 'hard' | 'medium' | 'shaded' | 'soft'): StickMaterial {
    this.contents[0] = stickMaterial;
    return this;
  }
}

export type StickAttributes = {
  'dashed-circle': 'yes' | 'no' | null;
  parentheses: 'yes' | 'no' | null;
  tip: 'down' | 'left' | 'northeast' | 'northwest' | 'right' | 'southeast' | 'southwest' | 'up' | null;
};

export type StickContents = [StickType, StickMaterial];

export class Stick implements XMLElement<'stick', StickAttributes, StickContents> {
  static readonly schema = {
    name: 'stick',
    attributes: {
      'dashed-circle': { type: 'optional', value: { type: 'choices', choices: ['yes', 'no'] } },
      parentheses: { type: 'optional', value: { type: 'choices', choices: ['yes', 'no'] } },
      tip: {
        type: 'optional',
        value: {
          type: 'choices',
          choices: ['down', 'left', 'northeast', 'northwest', 'right', 'southeast', 'southwest', 'up'],
        },
      },
    },
    contents: [
      { type: 'required', value: StickType },
      { type: 'required', value: StickMaterial },
    ],
  } as const;

  readonly schema = Stick.schema;

  attributes: StickAttributes;
  contents: StickContents;

  constructor(opts?: { attributes?: Partial<StickAttributes>; contents?: StickContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Stick.schema);
    this.contents = opts?.contents ?? operations.zero(Stick.schema.contents);
  }
  getDashedCircle(): 'yes' | 'no' | null {
    return this.attributes['dashed-circle'];
  }
  setDashedCircle(dashedCircle: 'yes' | 'no' | null): Stick {
    this.attributes['dashed-circle'] = dashedCircle;
    return this;
  }
  getParentheses(): 'yes' | 'no' | null {
    return this.attributes['parentheses'];
  }
  setParentheses(parentheses: 'yes' | 'no' | null): Stick {
    this.attributes['parentheses'] = parentheses;
    return this;
  }
  getTip(): 'down' | 'left' | 'northeast' | 'northwest' | 'right' | 'southeast' | 'southwest' | 'up' | null {
    return this.attributes['tip'];
  }
  setTip(tip: 'down' | 'left' | 'northeast' | 'northwest' | 'right' | 'southeast' | 'southwest' | 'up' | null): Stick {
    this.attributes['tip'] = tip;
    return this;
  }
  getStickType(): StickType {
    return this.contents[0];
  }
  setStickType(stickType: StickType): Stick {
    this.contents[0] = stickType;
    return this;
  }
  getStickMaterial(): StickMaterial {
    return this.contents[1];
  }
  setStickMaterial(stickMaterial: StickMaterial): Stick {
    this.contents[1] = stickMaterial;
    return this;
  }
}

export type StickLocationAttributes = Record<string, unknown>;

export type StickLocationContents = ['center' | 'cymbal bell' | 'cymbal edge' | 'rim'];

export class StickLocation implements XMLElement<'stick-location', StickLocationAttributes, StickLocationContents> {
  static readonly schema = {
    name: 'stick-location',
    attributes: {},
    contents: [
      {
        type: 'required',
        value: {
          type: 'label',
          label: 'stick-location',
          value: { type: 'choices', choices: ['center', 'cymbal bell', 'cymbal edge', 'rim'] },
        },
      },
    ],
  } as const;

  readonly schema = StickLocation.schema;

  attributes: StickLocationAttributes;
  contents: StickLocationContents;

  constructor(opts?: { attributes?: Partial<StickLocationAttributes>; contents?: StickLocationContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, StickLocation.schema);
    this.contents = opts?.contents ?? operations.zero(StickLocation.schema.contents);
  }

  getStickLocation(): 'center' | 'cymbal bell' | 'cymbal edge' | 'rim' {
    return this.contents[0];
  }
  setStickLocation(stickLocation: 'center' | 'cymbal bell' | 'cymbal edge' | 'rim'): StickLocation {
    this.contents[0] = stickLocation;
    return this;
  }
}

export type OtherPercussionAttributes = { smufl: string | null };

export type OtherPercussionContents = [string];

export class OtherPercussion
  implements XMLElement<'other-percussion', OtherPercussionAttributes, OtherPercussionContents>
{
  static readonly schema = {
    name: 'other-percussion',
    attributes: { smufl: { type: 'optional', value: { type: 'string' } } },
    contents: [{ type: 'required', value: { type: 'string' } }],
  } as const;

  readonly schema = OtherPercussion.schema;

  attributes: OtherPercussionAttributes;
  contents: OtherPercussionContents;

  constructor(opts?: { attributes?: Partial<OtherPercussionAttributes>; contents?: OtherPercussionContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, OtherPercussion.schema);
    this.contents = opts?.contents ?? operations.zero(OtherPercussion.schema.contents);
  }
  getSmufl(): string | null {
    return this.attributes['smufl'];
  }
  setSmufl(smufl: string | null): OtherPercussion {
    this.attributes['smufl'] = smufl;
    return this;
  }
  getText(): string {
    return this.contents[0];
  }
  setText(text: string): OtherPercussion {
    this.contents[0] = text;
    return this;
  }
}

export type PercussionAttributes = {
  color: string | null;
  'default-x': number | null;
  'default-y': number | null;
  'font-family': string | null;
  'font-size': 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null;
  'font-style': 'normal' | 'italic' | null;
  'font-weight': 'normal' | 'bold' | null;
  halign: 'left' | 'center' | 'right' | null;
  id: string | null;
  'relative-x': number | null;
  'relative-y': number | null;
  valign: 'top' | 'middle' | 'bottom' | 'baseline' | null;
};

export type PercussionContents = [
  Glass | Metal | Wood | Pitched | Membrane | Effect | Timpani | Beater | Stick | StickLocation | OtherPercussion
];

export class Percussion implements XMLElement<'percussion', PercussionAttributes, PercussionContents> {
  static readonly schema = {
    name: 'percussion',
    attributes: {
      color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
      'default-x': {
        type: 'label',
        label: 'default-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'default-y': {
        type: 'label',
        label: 'default-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
      'font-size': {
        type: 'optional',
        value: {
          type: 'choices',
          choices: [
            { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
            { type: 'float', min: -Infinity, max: Infinity },
          ],
        },
      },
      'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
      'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
      halign: { type: 'optional', value: { type: 'choices', choices: ['left', 'center', 'right'] } },
      id: { type: 'optional', value: { type: 'regex', pattern: /[A-Za-z_][A-Za-z0-9.-_]*/, zero: '_' } },
      'relative-x': {
        type: 'label',
        label: 'relative-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'relative-y': {
        type: 'label',
        label: 'relative-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      valign: { type: 'optional', value: { type: 'choices', choices: ['top', 'middle', 'bottom', 'baseline'] } },
    },
    contents: [
      {
        type: 'label',
        label: 'percussion-value',
        value: {
          type: 'choices',
          choices: [
            Glass,
            Metal,
            Wood,
            Pitched,
            Membrane,
            Effect,
            Timpani,
            Beater,
            Stick,
            StickLocation,
            OtherPercussion,
          ],
        },
      },
    ],
  } as const;

  readonly schema = Percussion.schema;

  attributes: PercussionAttributes;
  contents: PercussionContents;

  constructor(opts?: { attributes?: Partial<PercussionAttributes>; contents?: PercussionContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Percussion.schema);
    this.contents = opts?.contents ?? operations.zero(Percussion.schema.contents);
  }
  getColor(): string | null {
    return this.attributes['color'];
  }
  setColor(color: string | null): Percussion {
    this.attributes['color'] = color;
    return this;
  }
  getDefaultX(): number | null {
    return this.attributes['default-x'];
  }
  setDefaultX(defaultX: number | null): Percussion {
    this.attributes['default-x'] = defaultX;
    return this;
  }
  getDefaultY(): number | null {
    return this.attributes['default-y'];
  }
  setDefaultY(defaultY: number | null): Percussion {
    this.attributes['default-y'] = defaultY;
    return this;
  }
  getFontFamily(): string | null {
    return this.attributes['font-family'];
  }
  setFontFamily(fontFamily: string | null): Percussion {
    this.attributes['font-family'] = fontFamily;
    return this;
  }
  getFontSize(): 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null {
    return this.attributes['font-size'];
  }
  setFontSize(
    fontSize: 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null
  ): Percussion {
    this.attributes['font-size'] = fontSize;
    return this;
  }
  getFontStyle(): 'normal' | 'italic' | null {
    return this.attributes['font-style'];
  }
  setFontStyle(fontStyle: 'normal' | 'italic' | null): Percussion {
    this.attributes['font-style'] = fontStyle;
    return this;
  }
  getFontWeight(): 'normal' | 'bold' | null {
    return this.attributes['font-weight'];
  }
  setFontWeight(fontWeight: 'normal' | 'bold' | null): Percussion {
    this.attributes['font-weight'] = fontWeight;
    return this;
  }
  getHalign(): 'left' | 'center' | 'right' | null {
    return this.attributes['halign'];
  }
  setHalign(halign: 'left' | 'center' | 'right' | null): Percussion {
    this.attributes['halign'] = halign;
    return this;
  }
  getId(): string | null {
    return this.attributes['id'];
  }
  setId(id: string | null): Percussion {
    this.attributes['id'] = id;
    return this;
  }
  getRelativeX(): number | null {
    return this.attributes['relative-x'];
  }
  setRelativeX(relativeX: number | null): Percussion {
    this.attributes['relative-x'] = relativeX;
    return this;
  }
  getRelativeY(): number | null {
    return this.attributes['relative-y'];
  }
  setRelativeY(relativeY: number | null): Percussion {
    this.attributes['relative-y'] = relativeY;
    return this;
  }
  getValign(): 'top' | 'middle' | 'bottom' | 'baseline' | null {
    return this.attributes['valign'];
  }
  setValign(valign: 'top' | 'middle' | 'bottom' | 'baseline' | null): Percussion {
    this.attributes['valign'] = valign;
    return this;
  }
  getPercussionValue():
    | Glass
    | Metal
    | Wood
    | Pitched
    | Membrane
    | Effect
    | Timpani
    | Beater
    | Stick
    | StickLocation
    | OtherPercussion {
    return this.contents[0];
  }
  setPercussionValue(
    percussionValue:
      | Glass
      | Metal
      | Wood
      | Pitched
      | Membrane
      | Effect
      | Timpani
      | Beater
      | Stick
      | StickLocation
      | OtherPercussion
  ): Percussion {
    this.contents[0] = percussionValue;
    return this;
  }
}

export type AccordionHighAttributes = Record<string, unknown>;

export type AccordionHighContents = [];

export class AccordionHigh implements XMLElement<'accordion-high', AccordionHighAttributes, AccordionHighContents> {
  static readonly schema = { name: 'accordion-high', attributes: {}, contents: [] } as const;

  readonly schema = AccordionHigh.schema;

  attributes: AccordionHighAttributes;
  contents: AccordionHighContents;

  constructor(opts?: { attributes?: Partial<AccordionHighAttributes>; contents?: AccordionHighContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, AccordionHigh.schema);
    this.contents = opts?.contents ?? operations.zero(AccordionHigh.schema.contents);
  }
}

export type AccordionMiddleAttributes = Record<string, unknown>;

export type AccordionMiddleContents = [number];

export class AccordionMiddle
  implements XMLElement<'accordion-middle', AccordionMiddleAttributes, AccordionMiddleContents>
{
  static readonly schema = {
    name: 'accordion-middle',
    attributes: {},
    contents: [{ type: 'label', label: 'value', value: { type: 'int', min: 1, max: 3 } }],
  } as const;

  readonly schema = AccordionMiddle.schema;

  attributes: AccordionMiddleAttributes;
  contents: AccordionMiddleContents;

  constructor(opts?: { attributes?: Partial<AccordionMiddleAttributes>; contents?: AccordionMiddleContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, AccordionMiddle.schema);
    this.contents = opts?.contents ?? operations.zero(AccordionMiddle.schema.contents);
  }

  getValue(): number {
    return this.contents[0];
  }
  setValue(value: number): AccordionMiddle {
    this.contents[0] = value;
    return this;
  }
}

export type AccordionLowAttributes = Record<string, unknown>;

export type AccordionLowContents = [];

export class AccordionLow implements XMLElement<'accordion-low', AccordionLowAttributes, AccordionLowContents> {
  static readonly schema = { name: 'accordion-low', attributes: {}, contents: [] } as const;

  readonly schema = AccordionLow.schema;

  attributes: AccordionLowAttributes;
  contents: AccordionLowContents;

  constructor(opts?: { attributes?: Partial<AccordionLowAttributes>; contents?: AccordionLowContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, AccordionLow.schema);
    this.contents = opts?.contents ?? operations.zero(AccordionLow.schema.contents);
  }
}

export type AccordionRegistrationAttributes = {
  color: string | null;
  'default-x': number | null;
  'default-y': number | null;
  'font-family': string | null;
  'font-size': 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null;
  'font-style': 'normal' | 'italic' | null;
  'font-weight': 'normal' | 'bold' | null;
  halign: 'left' | 'center' | 'right' | null;
  id: string | null;
  'relative-x': number | null;
  'relative-y': number | null;
  valign: 'top' | 'middle' | 'bottom' | 'baseline' | null;
};

export type AccordionRegistrationContents = [AccordionHigh | null, AccordionMiddle | null, AccordionLow | null];

export class AccordionRegistration
  implements XMLElement<'accordion-registration', AccordionRegistrationAttributes, AccordionRegistrationContents>
{
  static readonly schema = {
    name: 'accordion-registration',
    attributes: {
      color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
      'default-x': {
        type: 'label',
        label: 'default-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'default-y': {
        type: 'label',
        label: 'default-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
      'font-size': {
        type: 'optional',
        value: {
          type: 'choices',
          choices: [
            { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
            { type: 'float', min: -Infinity, max: Infinity },
          ],
        },
      },
      'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
      'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
      halign: { type: 'optional', value: { type: 'choices', choices: ['left', 'center', 'right'] } },
      id: { type: 'optional', value: { type: 'regex', pattern: /[A-Za-z_][A-Za-z0-9.-_]*/, zero: '_' } },
      'relative-x': {
        type: 'label',
        label: 'relative-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'relative-y': {
        type: 'label',
        label: 'relative-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      valign: { type: 'optional', value: { type: 'choices', choices: ['top', 'middle', 'bottom', 'baseline'] } },
    },
    contents: [
      { type: 'optional', value: AccordionHigh },
      { type: 'optional', value: AccordionMiddle },
      { type: 'optional', value: AccordionLow },
    ],
  } as const;

  readonly schema = AccordionRegistration.schema;

  attributes: AccordionRegistrationAttributes;
  contents: AccordionRegistrationContents;

  constructor(opts?: {
    attributes?: Partial<AccordionRegistrationAttributes>;
    contents?: AccordionRegistrationContents;
  }) {
    this.attributes = operations.merge(opts?.attributes || {}, AccordionRegistration.schema);
    this.contents = opts?.contents ?? operations.zero(AccordionRegistration.schema.contents);
  }
  getColor(): string | null {
    return this.attributes['color'];
  }
  setColor(color: string | null): AccordionRegistration {
    this.attributes['color'] = color;
    return this;
  }
  getDefaultX(): number | null {
    return this.attributes['default-x'];
  }
  setDefaultX(defaultX: number | null): AccordionRegistration {
    this.attributes['default-x'] = defaultX;
    return this;
  }
  getDefaultY(): number | null {
    return this.attributes['default-y'];
  }
  setDefaultY(defaultY: number | null): AccordionRegistration {
    this.attributes['default-y'] = defaultY;
    return this;
  }
  getFontFamily(): string | null {
    return this.attributes['font-family'];
  }
  setFontFamily(fontFamily: string | null): AccordionRegistration {
    this.attributes['font-family'] = fontFamily;
    return this;
  }
  getFontSize(): 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null {
    return this.attributes['font-size'];
  }
  setFontSize(
    fontSize: 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null
  ): AccordionRegistration {
    this.attributes['font-size'] = fontSize;
    return this;
  }
  getFontStyle(): 'normal' | 'italic' | null {
    return this.attributes['font-style'];
  }
  setFontStyle(fontStyle: 'normal' | 'italic' | null): AccordionRegistration {
    this.attributes['font-style'] = fontStyle;
    return this;
  }
  getFontWeight(): 'normal' | 'bold' | null {
    return this.attributes['font-weight'];
  }
  setFontWeight(fontWeight: 'normal' | 'bold' | null): AccordionRegistration {
    this.attributes['font-weight'] = fontWeight;
    return this;
  }
  getHalign(): 'left' | 'center' | 'right' | null {
    return this.attributes['halign'];
  }
  setHalign(halign: 'left' | 'center' | 'right' | null): AccordionRegistration {
    this.attributes['halign'] = halign;
    return this;
  }
  getId(): string | null {
    return this.attributes['id'];
  }
  setId(id: string | null): AccordionRegistration {
    this.attributes['id'] = id;
    return this;
  }
  getRelativeX(): number | null {
    return this.attributes['relative-x'];
  }
  setRelativeX(relativeX: number | null): AccordionRegistration {
    this.attributes['relative-x'] = relativeX;
    return this;
  }
  getRelativeY(): number | null {
    return this.attributes['relative-y'];
  }
  setRelativeY(relativeY: number | null): AccordionRegistration {
    this.attributes['relative-y'] = relativeY;
    return this;
  }
  getValign(): 'top' | 'middle' | 'bottom' | 'baseline' | null {
    return this.attributes['valign'];
  }
  setValign(valign: 'top' | 'middle' | 'bottom' | 'baseline' | null): AccordionRegistration {
    this.attributes['valign'] = valign;
    return this;
  }
  getAccordionHigh(): AccordionHigh | null {
    return this.contents[0];
  }
  setAccordionHigh(accordionHigh: AccordionHigh | null): AccordionRegistration {
    this.contents[0] = accordionHigh;
    return this;
  }
  getAccordionMiddle(): AccordionMiddle | null {
    return this.contents[1];
  }
  setAccordionMiddle(accordionMiddle: AccordionMiddle | null): AccordionRegistration {
    this.contents[1] = accordionMiddle;
    return this;
  }
  getAccordionLow(): AccordionLow | null {
    return this.contents[2];
  }
  setAccordionLow(accordionLow: AccordionLow | null): AccordionRegistration {
    this.contents[2] = accordionLow;
    return this;
  }
}

export type StaffDivideAttributes = {
  type: 'down' | 'up' | 'up-down';
  color: string | null;
  'default-x': number | null;
  'default-y': number | null;
  'font-family': string | null;
  'font-size': 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null;
  'font-style': 'normal' | 'italic' | null;
  'font-weight': 'normal' | 'bold' | null;
  halign: 'left' | 'center' | 'right' | null;
  id: string | null;
  'relative-x': number | null;
  'relative-y': number | null;
  valign: 'top' | 'middle' | 'bottom' | 'baseline' | null;
};

export type StaffDivideContents = [];

export class StaffDivide implements XMLElement<'staff-divide', StaffDivideAttributes, StaffDivideContents> {
  static readonly schema = {
    name: 'staff-divide',
    attributes: {
      type: { type: 'required', value: { type: 'choices', choices: ['down', 'up', 'up-down'] } },
      color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
      'default-x': {
        type: 'label',
        label: 'default-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'default-y': {
        type: 'label',
        label: 'default-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
      'font-size': {
        type: 'optional',
        value: {
          type: 'choices',
          choices: [
            { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
            { type: 'float', min: -Infinity, max: Infinity },
          ],
        },
      },
      'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
      'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
      halign: { type: 'optional', value: { type: 'choices', choices: ['left', 'center', 'right'] } },
      id: { type: 'optional', value: { type: 'regex', pattern: /[A-Za-z_][A-Za-z0-9.-_]*/, zero: '_' } },
      'relative-x': {
        type: 'label',
        label: 'relative-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'relative-y': {
        type: 'label',
        label: 'relative-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      valign: { type: 'optional', value: { type: 'choices', choices: ['top', 'middle', 'bottom', 'baseline'] } },
    },
    contents: [],
  } as const;

  readonly schema = StaffDivide.schema;

  attributes: StaffDivideAttributes;
  contents: StaffDivideContents;

  constructor(opts?: { attributes?: Partial<StaffDivideAttributes>; contents?: StaffDivideContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, StaffDivide.schema);
    this.contents = opts?.contents ?? operations.zero(StaffDivide.schema.contents);
  }
  getType(): 'down' | 'up' | 'up-down' {
    return this.attributes['type'];
  }
  setType(type: 'down' | 'up' | 'up-down'): StaffDivide {
    this.attributes['type'] = type;
    return this;
  }
  getColor(): string | null {
    return this.attributes['color'];
  }
  setColor(color: string | null): StaffDivide {
    this.attributes['color'] = color;
    return this;
  }
  getDefaultX(): number | null {
    return this.attributes['default-x'];
  }
  setDefaultX(defaultX: number | null): StaffDivide {
    this.attributes['default-x'] = defaultX;
    return this;
  }
  getDefaultY(): number | null {
    return this.attributes['default-y'];
  }
  setDefaultY(defaultY: number | null): StaffDivide {
    this.attributes['default-y'] = defaultY;
    return this;
  }
  getFontFamily(): string | null {
    return this.attributes['font-family'];
  }
  setFontFamily(fontFamily: string | null): StaffDivide {
    this.attributes['font-family'] = fontFamily;
    return this;
  }
  getFontSize(): 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null {
    return this.attributes['font-size'];
  }
  setFontSize(
    fontSize: 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null
  ): StaffDivide {
    this.attributes['font-size'] = fontSize;
    return this;
  }
  getFontStyle(): 'normal' | 'italic' | null {
    return this.attributes['font-style'];
  }
  setFontStyle(fontStyle: 'normal' | 'italic' | null): StaffDivide {
    this.attributes['font-style'] = fontStyle;
    return this;
  }
  getFontWeight(): 'normal' | 'bold' | null {
    return this.attributes['font-weight'];
  }
  setFontWeight(fontWeight: 'normal' | 'bold' | null): StaffDivide {
    this.attributes['font-weight'] = fontWeight;
    return this;
  }
  getHalign(): 'left' | 'center' | 'right' | null {
    return this.attributes['halign'];
  }
  setHalign(halign: 'left' | 'center' | 'right' | null): StaffDivide {
    this.attributes['halign'] = halign;
    return this;
  }
  getId(): string | null {
    return this.attributes['id'];
  }
  setId(id: string | null): StaffDivide {
    this.attributes['id'] = id;
    return this;
  }
  getRelativeX(): number | null {
    return this.attributes['relative-x'];
  }
  setRelativeX(relativeX: number | null): StaffDivide {
    this.attributes['relative-x'] = relativeX;
    return this;
  }
  getRelativeY(): number | null {
    return this.attributes['relative-y'];
  }
  setRelativeY(relativeY: number | null): StaffDivide {
    this.attributes['relative-y'] = relativeY;
    return this;
  }
  getValign(): 'top' | 'middle' | 'bottom' | 'baseline' | null {
    return this.attributes['valign'];
  }
  setValign(valign: 'top' | 'middle' | 'bottom' | 'baseline' | null): StaffDivide {
    this.attributes['valign'] = valign;
    return this;
  }
}

export type OtherDirectionAttributes = {
  color: string | null;
  'default-x': number | null;
  'default-y': number | null;
  'font-family': string | null;
  'font-size': 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null;
  'font-style': 'normal' | 'italic' | null;
  'font-weight': 'normal' | 'bold' | null;
  halign: 'left' | 'center' | 'right' | null;
  id: string | null;
  'print-object': 'yes' | 'no' | null;
  'relative-x': number | null;
  'relative-y': number | null;
  smufl: string | null;
  valign: 'top' | 'middle' | 'bottom' | 'baseline' | null;
};

export type OtherDirectionContents = [string];

export class OtherDirection implements XMLElement<'other-direction', OtherDirectionAttributes, OtherDirectionContents> {
  static readonly schema = {
    name: 'other-direction',
    attributes: {
      color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
      'default-x': {
        type: 'label',
        label: 'default-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'default-y': {
        type: 'label',
        label: 'default-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
      'font-size': {
        type: 'optional',
        value: {
          type: 'choices',
          choices: [
            { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
            { type: 'float', min: -Infinity, max: Infinity },
          ],
        },
      },
      'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
      'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
      halign: { type: 'optional', value: { type: 'choices', choices: ['left', 'center', 'right'] } },
      id: { type: 'optional', value: { type: 'regex', pattern: /[A-Za-z_][A-Za-z0-9.-_]*/, zero: '_' } },
      'print-object': { type: 'optional', value: { type: 'choices', choices: ['yes', 'no'] } },
      'relative-x': {
        type: 'label',
        label: 'relative-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'relative-y': {
        type: 'label',
        label: 'relative-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      smufl: { type: 'optional', value: { type: 'string' } },
      valign: { type: 'optional', value: { type: 'choices', choices: ['top', 'middle', 'bottom', 'baseline'] } },
    },
    contents: [{ type: 'string' }],
  } as const;

  readonly schema = OtherDirection.schema;

  attributes: OtherDirectionAttributes;
  contents: OtherDirectionContents;

  constructor(opts?: { attributes?: Partial<OtherDirectionAttributes>; contents?: OtherDirectionContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, OtherDirection.schema);
    this.contents = opts?.contents ?? operations.zero(OtherDirection.schema.contents);
  }
  getColor(): string | null {
    return this.attributes['color'];
  }
  setColor(color: string | null): OtherDirection {
    this.attributes['color'] = color;
    return this;
  }
  getDefaultX(): number | null {
    return this.attributes['default-x'];
  }
  setDefaultX(defaultX: number | null): OtherDirection {
    this.attributes['default-x'] = defaultX;
    return this;
  }
  getDefaultY(): number | null {
    return this.attributes['default-y'];
  }
  setDefaultY(defaultY: number | null): OtherDirection {
    this.attributes['default-y'] = defaultY;
    return this;
  }
  getFontFamily(): string | null {
    return this.attributes['font-family'];
  }
  setFontFamily(fontFamily: string | null): OtherDirection {
    this.attributes['font-family'] = fontFamily;
    return this;
  }
  getFontSize(): 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null {
    return this.attributes['font-size'];
  }
  setFontSize(
    fontSize: 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null
  ): OtherDirection {
    this.attributes['font-size'] = fontSize;
    return this;
  }
  getFontStyle(): 'normal' | 'italic' | null {
    return this.attributes['font-style'];
  }
  setFontStyle(fontStyle: 'normal' | 'italic' | null): OtherDirection {
    this.attributes['font-style'] = fontStyle;
    return this;
  }
  getFontWeight(): 'normal' | 'bold' | null {
    return this.attributes['font-weight'];
  }
  setFontWeight(fontWeight: 'normal' | 'bold' | null): OtherDirection {
    this.attributes['font-weight'] = fontWeight;
    return this;
  }
  getHalign(): 'left' | 'center' | 'right' | null {
    return this.attributes['halign'];
  }
  setHalign(halign: 'left' | 'center' | 'right' | null): OtherDirection {
    this.attributes['halign'] = halign;
    return this;
  }
  getId(): string | null {
    return this.attributes['id'];
  }
  setId(id: string | null): OtherDirection {
    this.attributes['id'] = id;
    return this;
  }
  getPrintObject(): 'yes' | 'no' | null {
    return this.attributes['print-object'];
  }
  setPrintObject(printObject: 'yes' | 'no' | null): OtherDirection {
    this.attributes['print-object'] = printObject;
    return this;
  }
  getRelativeX(): number | null {
    return this.attributes['relative-x'];
  }
  setRelativeX(relativeX: number | null): OtherDirection {
    this.attributes['relative-x'] = relativeX;
    return this;
  }
  getRelativeY(): number | null {
    return this.attributes['relative-y'];
  }
  setRelativeY(relativeY: number | null): OtherDirection {
    this.attributes['relative-y'] = relativeY;
    return this;
  }
  getSmufl(): string | null {
    return this.attributes['smufl'];
  }
  setSmufl(smufl: string | null): OtherDirection {
    this.attributes['smufl'] = smufl;
    return this;
  }
  getValign(): 'top' | 'middle' | 'bottom' | 'baseline' | null {
    return this.attributes['valign'];
  }
  setValign(valign: 'top' | 'middle' | 'bottom' | 'baseline' | null): OtherDirection {
    this.attributes['valign'] = valign;
    return this;
  }
  getText(): string {
    return this.contents[0];
  }
  setText(text: string): OtherDirection {
    this.contents[0] = text;
    return this;
  }
}

export type Rehearsals = Array<Rehearsal>;

export type Segnos = Array<Segno>;

export type Codas = Array<Coda>;

export type Tokens = Array<Words | Symbol>;

export type DynamicsList = Array<Dynamics>;

export type Percussions = Array<Percussion>;

export type DirectionTypeAttributes = { id: string | null };

export type DirectionTypeContents = [
  | Rehearsals
  | Segnos
  | Codas
  | Tokens
  | Wedge
  | DynamicsList
  | Dashes
  | Bracket
  | Pedal
  | Metronome
  | OctaveShift
  | HarpPedals
  | Damp
  | DampAll
  | Eyeglasses
  | StringMute
  | Scordatura
  | Image
  | PrincipalVoice
  | Percussions
  | AccordionRegistration
  | StaffDivide
  | OtherDirection
];

export class DirectionType implements XMLElement<'direction-type', DirectionTypeAttributes, DirectionTypeContents> {
  static readonly schema = {
    name: 'direction-type',
    attributes: { id: { type: 'optional', value: { type: 'regex', pattern: /[A-Za-z_][A-Za-z0-9.-_]*/, zero: '_' } } },
    contents: [
      {
        type: 'label',
        label: 'direction-type',
        value: {
          type: 'choices',
          choices: [
            { type: 'label', label: 'rehearsals', value: { type: 'oneOrMore', value: Rehearsal } },
            { type: 'label', label: 'segnos', value: { type: 'oneOrMore', value: Segno } },
            { type: 'label', label: 'codas', value: { type: 'oneOrMore', value: Coda } },
            {
              type: 'label',
              label: 'tokens',
              value: { type: 'oneOrMore', value: { type: 'choices', choices: [Words, Symbol] } },
            },
            Wedge,
            { type: 'label', label: 'dynamics-list', value: { type: 'oneOrMore', value: Dynamics } },
            Dashes,
            Bracket,
            Pedal,
            Metronome,
            OctaveShift,
            HarpPedals,
            Damp,
            DampAll,
            Eyeglasses,
            StringMute,
            Scordatura,
            Image,
            PrincipalVoice,
            { type: 'label', label: 'percussions', value: { type: 'oneOrMore', value: Percussion } },
            AccordionRegistration,
            StaffDivide,
            OtherDirection,
          ],
        },
      },
    ],
  } as const;

  readonly schema = DirectionType.schema;

  attributes: DirectionTypeAttributes;
  contents: DirectionTypeContents;

  constructor(opts?: { attributes?: Partial<DirectionTypeAttributes>; contents?: DirectionTypeContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, DirectionType.schema);
    this.contents = opts?.contents ?? operations.zero(DirectionType.schema.contents);
  }
  getId(): string | null {
    return this.attributes['id'];
  }
  setId(id: string | null): DirectionType {
    this.attributes['id'] = id;
    return this;
  }
  getDirectionType():
    | Rehearsals
    | Segnos
    | Codas
    | Tokens
    | Wedge
    | DynamicsList
    | Dashes
    | Bracket
    | Pedal
    | Metronome
    | OctaveShift
    | HarpPedals
    | Damp
    | DampAll
    | Eyeglasses
    | StringMute
    | Scordatura
    | Image
    | PrincipalVoice
    | Percussions
    | AccordionRegistration
    | StaffDivide
    | OtherDirection {
    return this.contents[0];
  }
  setDirectionType(
    directionType:
      | Rehearsals
      | Segnos
      | Codas
      | Tokens
      | Wedge
      | DynamicsList
      | Dashes
      | Bracket
      | Pedal
      | Metronome
      | OctaveShift
      | HarpPedals
      | Damp
      | DampAll
      | Eyeglasses
      | StringMute
      | Scordatura
      | Image
      | PrincipalVoice
      | Percussions
      | AccordionRegistration
      | StaffDivide
      | OtherDirection
  ): DirectionType {
    this.contents[0] = directionType;
    return this;
  }
}

export type OffsetAttributes = { sound: 'yes' | 'no' | null };

export type OffsetContents = [number];

export class Offset implements XMLElement<'offset', OffsetAttributes, OffsetContents> {
  static readonly schema = {
    name: 'offset',
    attributes: { sound: { type: 'optional', value: { type: 'choices', choices: ['yes', 'no'] } } },
    contents: [
      {
        type: 'label',
        label: 'offset-value',
        value: { type: 'required', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
    ],
  } as const;

  readonly schema = Offset.schema;

  attributes: OffsetAttributes;
  contents: OffsetContents;

  constructor(opts?: { attributes?: Partial<OffsetAttributes>; contents?: OffsetContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Offset.schema);
    this.contents = opts?.contents ?? operations.zero(Offset.schema.contents);
  }
  getSound(): 'yes' | 'no' | null {
    return this.attributes['sound'];
  }
  setSound(sound: 'yes' | 'no' | null): Offset {
    this.attributes['sound'] = sound;
    return this;
  }
  getOffsetValue(): number {
    return this.contents[0];
  }
  setOffsetValue(offsetValue: number): Offset {
    this.contents[0] = offsetValue;
    return this;
  }
}

export type InstrumentChangeAttributes = { id: string };

export type InstrumentChangeContents = [InstrumentSound | null, Array<Solo | Ensemble>, VirtualInstrument | null];

export class InstrumentChange
  implements XMLElement<'instrument-change', InstrumentChangeAttributes, InstrumentChangeContents>
{
  static readonly schema = {
    name: 'instrument-change',
    attributes: { id: { type: 'required', value: { type: 'regex', pattern: /[A-Za-z_][A-Za-z0-9.-_]*/, zero: '_' } } },
    contents: [
      { type: 'optional', value: InstrumentSound },
      {
        type: 'label',
        label: 'instrument-types',
        value: { type: 'zeroOrMore', value: { type: 'choices', choices: [Solo, Ensemble] } },
      },
      { type: 'optional', value: VirtualInstrument },
    ],
  } as const;

  readonly schema = InstrumentChange.schema;

  attributes: InstrumentChangeAttributes;
  contents: InstrumentChangeContents;

  constructor(opts?: { attributes?: Partial<InstrumentChangeAttributes>; contents?: InstrumentChangeContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, InstrumentChange.schema);
    this.contents = opts?.contents ?? operations.zero(InstrumentChange.schema.contents);
  }
  getId(): string {
    return this.attributes['id'];
  }
  setId(id: string): InstrumentChange {
    this.attributes['id'] = id;
    return this;
  }
  getInstrumentSound(): InstrumentSound | null {
    return this.contents[0];
  }
  setInstrumentSound(instrumentSound: InstrumentSound | null): InstrumentChange {
    this.contents[0] = instrumentSound;
    return this;
  }
  getInstrumentTypes(): Array<Solo | Ensemble> {
    return this.contents[1];
  }
  setInstrumentTypes(instrumentTypes: Array<Solo | Ensemble>): InstrumentChange {
    this.contents[1] = instrumentTypes;
    return this;
  }
  getVirtualInstrument(): VirtualInstrument | null {
    return this.contents[2];
  }
  setVirtualInstrument(virtualInstrument: VirtualInstrument | null): InstrumentChange {
    this.contents[2] = virtualInstrument;
    return this;
  }
}

export type StraightAttributes = Record<string, unknown>;

export type StraightContents = [];

export class Straight implements XMLElement<'straight', StraightAttributes, StraightContents> {
  static readonly schema = { name: 'straight', attributes: {}, contents: [] } as const;

  readonly schema = Straight.schema;

  attributes: StraightAttributes;
  contents: StraightContents;

  constructor(opts?: { attributes?: Partial<StraightAttributes>; contents?: StraightContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Straight.schema);
    this.contents = opts?.contents ?? operations.zero(Straight.schema.contents);
  }
}

export type FirstAttributes = Record<string, unknown>;

export type FirstContents = [number];

export class First implements XMLElement<'first', FirstAttributes, FirstContents> {
  static readonly schema = {
    name: 'first',
    attributes: {},
    contents: [
      {
        type: 'label',
        label: 'swing-ratio',
        value: { type: 'required', value: { type: 'int', min: 1, max: Infinity } },
      },
    ],
  } as const;

  readonly schema = First.schema;

  attributes: FirstAttributes;
  contents: FirstContents;

  constructor(opts?: { attributes?: Partial<FirstAttributes>; contents?: FirstContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, First.schema);
    this.contents = opts?.contents ?? operations.zero(First.schema.contents);
  }

  getSwingRatio(): number {
    return this.contents[0];
  }
  setSwingRatio(swingRatio: number): First {
    this.contents[0] = swingRatio;
    return this;
  }
}

export type SecondAttributes = Record<string, unknown>;

export type SecondContents = [number];

export class Second implements XMLElement<'second', SecondAttributes, SecondContents> {
  static readonly schema = {
    name: 'second',
    attributes: {},
    contents: [
      {
        type: 'label',
        label: 'second-value',
        value: { type: 'required', value: { type: 'int', min: 1, max: Infinity } },
      },
    ],
  } as const;

  readonly schema = Second.schema;

  attributes: SecondAttributes;
  contents: SecondContents;

  constructor(opts?: { attributes?: Partial<SecondAttributes>; contents?: SecondContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Second.schema);
    this.contents = opts?.contents ?? operations.zero(Second.schema.contents);
  }

  getSecondValue(): number {
    return this.contents[0];
  }
  setSecondValue(secondValue: number): Second {
    this.contents[0] = secondValue;
    return this;
  }
}

export type SwingTypeAttributes = Record<string, unknown>;

export type SwingTypeContents = ['eighth' | '16th'];

export class SwingType implements XMLElement<'swing-type', SwingTypeAttributes, SwingTypeContents> {
  static readonly schema = {
    name: 'swing-type',
    attributes: {},
    contents: [
      {
        type: 'required',
        value: { type: 'label', label: 'eighth', value: { type: 'choices', choices: ['eighth', '16th'] } },
      },
    ],
  } as const;

  readonly schema = SwingType.schema;

  attributes: SwingTypeAttributes;
  contents: SwingTypeContents;

  constructor(opts?: { attributes?: Partial<SwingTypeAttributes>; contents?: SwingTypeContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, SwingType.schema);
    this.contents = opts?.contents ?? operations.zero(SwingType.schema.contents);
  }

  getEighth(): 'eighth' | '16th' {
    return this.contents[0];
  }
  setEighth(eighth: 'eighth' | '16th'): SwingType {
    this.contents[0] = eighth;
    return this;
  }
}

export type SwingStyleAttributes = Record<string, unknown>;

export type SwingStyleContents = [string];

export class SwingStyle implements XMLElement<'swing-style', SwingStyleAttributes, SwingStyleContents> {
  static readonly schema = {
    name: 'swing-style',
    attributes: {},
    contents: [{ type: 'required', value: { type: 'string' } }],
  } as const;

  readonly schema = SwingStyle.schema;

  attributes: SwingStyleAttributes;
  contents: SwingStyleContents;

  constructor(opts?: { attributes?: Partial<SwingStyleAttributes>; contents?: SwingStyleContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, SwingStyle.schema);
    this.contents = opts?.contents ?? operations.zero(SwingStyle.schema.contents);
  }

  getText(): string {
    return this.contents[0];
  }
  setText(text: string): SwingStyle {
    this.contents[0] = text;
    return this;
  }
}

export type AlternateSwing = [First, Second, SwingType | null];

export type SwingAttributes = Record<string, unknown>;

export type SwingContents = [Straight | AlternateSwing, SwingStyle | null];

export class Swing implements XMLElement<'swing', SwingAttributes, SwingContents> {
  static readonly schema = {
    name: 'swing',
    attributes: {},
    contents: [
      {
        type: 'label',
        label: 'swing-value',
        value: {
          type: 'choices',
          choices: [
            Straight,
            {
              type: 'label',
              label: 'alternate-swing',
              value: [
                { type: 'required', value: First },
                { type: 'required', value: Second },
                { type: 'optional', value: SwingType },
              ],
            },
          ],
        },
      },
      { type: 'optional', value: SwingStyle },
    ],
  } as const;

  readonly schema = Swing.schema;

  attributes: SwingAttributes;
  contents: SwingContents;

  constructor(opts?: { attributes?: Partial<SwingAttributes>; contents?: SwingContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Swing.schema);
    this.contents = opts?.contents ?? operations.zero(Swing.schema.contents);
  }

  getSwingValue(): Straight | AlternateSwing {
    return this.contents[0];
  }
  setSwingValue(swingValue: Straight | AlternateSwing): Swing {
    this.contents[0] = swingValue;
    return this;
  }
  getSwingStyle(): SwingStyle | null {
    return this.contents[1];
  }
  setSwingStyle(swingStyle: SwingStyle | null): Swing {
    this.contents[1] = swingStyle;
    return this;
  }
}

export type SoundAttributes = {
  coda: string | null;
  dacapo: 'yes' | 'no' | null;
  dalsegno: string | null;
  'damper-pedal': 'no' | 'yes' | 0 | 1 | null;
  divisions: number | null;
  dynamics: number | null;
  elevation: number | null;
  fine: string | null;
  'forward-repeat': 'yes' | 'no' | null;
  id: string | null;
  pan: number | null;
  pizzicato: 'yes' | 'no' | null;
  segno: string | null;
  'soft-pedal': 'no' | 'yes' | 0 | 1 | null;
  'sostenuto-pedal': 'no' | 'yes' | 0 | 1 | null;
  tempo: number | null;
  'time-only': string | null;
  tocoda: string | null;
};

export type SoundContents = [
  Array<[InstrumentChange | null, MidiDevice | null, MidiInstrument | null, Play | null]>,
  Swing | null,
  Offset | null
];

export class Sound implements XMLElement<'sound', SoundAttributes, SoundContents> {
  static readonly schema = {
    name: 'sound',
    attributes: {
      coda: { type: 'optional', value: { type: 'string' } },
      dacapo: { type: 'optional', value: { type: 'choices', choices: ['yes', 'no'] } },
      dalsegno: { type: 'optional', value: { type: 'string' } },
      'damper-pedal': { type: 'optional', value: { type: 'choices', choices: ['no', 'yes', 0, 1] } },
      divisions: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      dynamics: { type: 'optional', value: { type: 'float', min: 0, max: Infinity } },
      elevation: { type: 'optional', value: { type: 'float', min: -180, max: 180 } },
      fine: { type: 'optional', value: { type: 'string' } },
      'forward-repeat': { type: 'optional', value: { type: 'choices', choices: ['yes', 'no'] } },
      id: { type: 'optional', value: { type: 'regex', pattern: /[A-Za-z_][A-Za-z0-9.-_]*/, zero: '_' } },
      pan: { type: 'optional', value: { type: 'float', min: -180, max: 180 } },
      pizzicato: { type: 'optional', value: { type: 'choices', choices: ['yes', 'no'] } },
      segno: { type: 'optional', value: { type: 'string' } },
      'soft-pedal': { type: 'optional', value: { type: 'choices', choices: ['no', 'yes', 0, 1] } },
      'sostenuto-pedal': { type: 'optional', value: { type: 'choices', choices: ['no', 'yes', 0, 1] } },
      tempo: { type: 'optional', value: { type: 'float', min: 0, max: Infinity } },
      'time-only': { type: 'optional', value: { type: 'regex', pattern: /[1-9][0-9]*(, ?[1-9][0-9]*)*/, zero: '1' } },
      tocoda: { type: 'optional', value: { type: 'string' } },
    },
    contents: [
      {
        type: 'label',
        label: 'playbacks',
        value: {
          type: 'zeroOrMore',
          value: [
            { type: 'optional', value: InstrumentChange },
            { type: 'optional', value: MidiDevice },
            { type: 'optional', value: MidiInstrument },
            { type: 'optional', value: Play },
          ],
        },
      },
      { type: 'optional', value: Swing },
      { type: 'optional', value: Offset },
    ],
  } as const;

  readonly schema = Sound.schema;

  attributes: SoundAttributes;
  contents: SoundContents;

  constructor(opts?: { attributes?: Partial<SoundAttributes>; contents?: SoundContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Sound.schema);
    this.contents = opts?.contents ?? operations.zero(Sound.schema.contents);
  }
  getCoda(): string | null {
    return this.attributes['coda'];
  }
  setCoda(coda: string | null): Sound {
    this.attributes['coda'] = coda;
    return this;
  }
  getDacapo(): 'yes' | 'no' | null {
    return this.attributes['dacapo'];
  }
  setDacapo(dacapo: 'yes' | 'no' | null): Sound {
    this.attributes['dacapo'] = dacapo;
    return this;
  }
  getDalsegno(): string | null {
    return this.attributes['dalsegno'];
  }
  setDalsegno(dalsegno: string | null): Sound {
    this.attributes['dalsegno'] = dalsegno;
    return this;
  }
  getDamperPedal(): 'no' | 'yes' | 0 | 1 | null {
    return this.attributes['damper-pedal'];
  }
  setDamperPedal(damperPedal: 'no' | 'yes' | 0 | 1 | null): Sound {
    this.attributes['damper-pedal'] = damperPedal;
    return this;
  }
  getDivisions(): number | null {
    return this.attributes['divisions'];
  }
  setDivisions(divisions: number | null): Sound {
    this.attributes['divisions'] = divisions;
    return this;
  }
  getDynamics(): number | null {
    return this.attributes['dynamics'];
  }
  setDynamics(dynamics: number | null): Sound {
    this.attributes['dynamics'] = dynamics;
    return this;
  }
  getElevation(): number | null {
    return this.attributes['elevation'];
  }
  setElevation(elevation: number | null): Sound {
    this.attributes['elevation'] = elevation;
    return this;
  }
  getFine(): string | null {
    return this.attributes['fine'];
  }
  setFine(fine: string | null): Sound {
    this.attributes['fine'] = fine;
    return this;
  }
  getForwardRepeat(): 'yes' | 'no' | null {
    return this.attributes['forward-repeat'];
  }
  setForwardRepeat(forwardRepeat: 'yes' | 'no' | null): Sound {
    this.attributes['forward-repeat'] = forwardRepeat;
    return this;
  }
  getId(): string | null {
    return this.attributes['id'];
  }
  setId(id: string | null): Sound {
    this.attributes['id'] = id;
    return this;
  }
  getPan(): number | null {
    return this.attributes['pan'];
  }
  setPan(pan: number | null): Sound {
    this.attributes['pan'] = pan;
    return this;
  }
  getPizzicato(): 'yes' | 'no' | null {
    return this.attributes['pizzicato'];
  }
  setPizzicato(pizzicato: 'yes' | 'no' | null): Sound {
    this.attributes['pizzicato'] = pizzicato;
    return this;
  }
  getSegno(): string | null {
    return this.attributes['segno'];
  }
  setSegno(segno: string | null): Sound {
    this.attributes['segno'] = segno;
    return this;
  }
  getSoftPedal(): 'no' | 'yes' | 0 | 1 | null {
    return this.attributes['soft-pedal'];
  }
  setSoftPedal(softPedal: 'no' | 'yes' | 0 | 1 | null): Sound {
    this.attributes['soft-pedal'] = softPedal;
    return this;
  }
  getSostenutoPedal(): 'no' | 'yes' | 0 | 1 | null {
    return this.attributes['sostenuto-pedal'];
  }
  setSostenutoPedal(sostenutoPedal: 'no' | 'yes' | 0 | 1 | null): Sound {
    this.attributes['sostenuto-pedal'] = sostenutoPedal;
    return this;
  }
  getTempo(): number | null {
    return this.attributes['tempo'];
  }
  setTempo(tempo: number | null): Sound {
    this.attributes['tempo'] = tempo;
    return this;
  }
  getTimeOnly(): string | null {
    return this.attributes['time-only'];
  }
  setTimeOnly(timeOnly: string | null): Sound {
    this.attributes['time-only'] = timeOnly;
    return this;
  }
  getTocoda(): string | null {
    return this.attributes['tocoda'];
  }
  setTocoda(tocoda: string | null): Sound {
    this.attributes['tocoda'] = tocoda;
    return this;
  }
  getPlaybacks(): Array<[InstrumentChange | null, MidiDevice | null, MidiInstrument | null, Play | null]> {
    return this.contents[0];
  }
  setPlaybacks(
    playbacks: Array<[InstrumentChange | null, MidiDevice | null, MidiInstrument | null, Play | null]>
  ): Sound {
    this.contents[0] = playbacks;
    return this;
  }
  getSwing(): Swing | null {
    return this.contents[1];
  }
  setSwing(swing: Swing | null): Sound {
    this.contents[1] = swing;
    return this;
  }
  getOffset(): Offset | null {
    return this.contents[2];
  }
  setOffset(offset: Offset | null): Sound {
    this.contents[2] = offset;
    return this;
  }
}

export type SyncAttributes = {
  type: 'none' | 'tempo' | 'mostly-tempo' | 'mostly-event' | 'event' | 'always-event';
  latency: number | null;
  player: string | null;
  'time-only': string | null;
};

export type SyncContents = [];

export class Sync implements XMLElement<'sync', SyncAttributes, SyncContents> {
  static readonly schema = {
    name: 'sync',
    attributes: {
      type: {
        type: 'required',
        value: { type: 'choices', choices: ['none', 'tempo', 'mostly-tempo', 'mostly-event', 'event', 'always-event'] },
      },
      latency: { type: 'optional', value: { type: 'int', min: 0, max: Infinity } },
      player: { type: 'optional', value: { type: 'regex', pattern: /[A-Za-z_][A-Za-z0-9.-_]*/, zero: '_' } },
      'time-only': { type: 'optional', value: { type: 'regex', pattern: /[1-9][0-9]*(, ?[1-9][0-9]*)*/, zero: '1' } },
    },
    contents: [],
  } as const;

  readonly schema = Sync.schema;

  attributes: SyncAttributes;
  contents: SyncContents;

  constructor(opts?: { attributes?: Partial<SyncAttributes>; contents?: SyncContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Sync.schema);
    this.contents = opts?.contents ?? operations.zero(Sync.schema.contents);
  }
  getType(): 'none' | 'tempo' | 'mostly-tempo' | 'mostly-event' | 'event' | 'always-event' {
    return this.attributes['type'];
  }
  setType(type: 'none' | 'tempo' | 'mostly-tempo' | 'mostly-event' | 'event' | 'always-event'): Sync {
    this.attributes['type'] = type;
    return this;
  }
  getLatency(): number | null {
    return this.attributes['latency'];
  }
  setLatency(latency: number | null): Sync {
    this.attributes['latency'] = latency;
    return this;
  }
  getPlayer(): string | null {
    return this.attributes['player'];
  }
  setPlayer(player: string | null): Sync {
    this.attributes['player'] = player;
    return this;
  }
  getTimeOnly(): string | null {
    return this.attributes['time-only'];
  }
  setTimeOnly(timeOnly: string | null): Sync {
    this.attributes['time-only'] = timeOnly;
    return this;
  }
}

export type OtherListeningAttributes = { type: string; player: string | null; 'time-only': string | null };

export type OtherListeningContents = [string];

export class OtherListening implements XMLElement<'other-listening', OtherListeningAttributes, OtherListeningContents> {
  static readonly schema = {
    name: 'other-listening',
    attributes: {
      type: { type: 'required', value: { type: 'string' } },
      player: { type: 'optional', value: { type: 'regex', pattern: /[A-Za-z_][A-Za-z0-9.-_]*/, zero: '_' } },
      'time-only': { type: 'optional', value: { type: 'regex', pattern: /[1-9][0-9]*(, ?[1-9][0-9]*)*/, zero: '1' } },
    },
    contents: [{ type: 'required', value: { type: 'string' } }],
  } as const;

  readonly schema = OtherListening.schema;

  attributes: OtherListeningAttributes;
  contents: OtherListeningContents;

  constructor(opts?: { attributes?: Partial<OtherListeningAttributes>; contents?: OtherListeningContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, OtherListening.schema);
    this.contents = opts?.contents ?? operations.zero(OtherListening.schema.contents);
  }
  getType(): string {
    return this.attributes['type'];
  }
  setType(type: string): OtherListening {
    this.attributes['type'] = type;
    return this;
  }
  getPlayer(): string | null {
    return this.attributes['player'];
  }
  setPlayer(player: string | null): OtherListening {
    this.attributes['player'] = player;
    return this;
  }
  getTimeOnly(): string | null {
    return this.attributes['time-only'];
  }
  setTimeOnly(timeOnly: string | null): OtherListening {
    this.attributes['time-only'] = timeOnly;
    return this;
  }
  getText(): string {
    return this.contents[0];
  }
  setText(text: string): OtherListening {
    this.contents[0] = text;
    return this;
  }
}

export type ListeningAttributes = Record<string, unknown>;

export type ListeningContents = [Array<Sync | OtherListening>, Offset | null];

export class Listening implements XMLElement<'listening', ListeningAttributes, ListeningContents> {
  static readonly schema = {
    name: 'listening',
    attributes: {},
    contents: [
      {
        type: 'label',
        label: 'listening',
        value: { type: 'oneOrMore', value: { type: 'choices', choices: [Sync, OtherListening] } },
      },
      { type: 'optional', value: Offset },
    ],
  } as const;

  readonly schema = Listening.schema;

  attributes: ListeningAttributes;
  contents: ListeningContents;

  constructor(opts?: { attributes?: Partial<ListeningAttributes>; contents?: ListeningContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Listening.schema);
    this.contents = opts?.contents ?? operations.zero(Listening.schema.contents);
  }

  getListening(): Array<Sync | OtherListening> {
    return this.contents[0];
  }
  setListening(listening: Array<Sync | OtherListening>): Listening {
    this.contents[0] = listening;
    return this;
  }
  getOffset(): Offset | null {
    return this.contents[1];
  }
  setOffset(offset: Offset | null): Listening {
    this.contents[1] = offset;
    return this;
  }
}

export type DirectionAttributes = {
  directive: 'yes' | 'no' | null;
  id: string | null;
  placement: 'above' | 'below' | null;
  system: 'none' | 'only-top' | 'also-top' | null;
};

export type DirectionContents = [
  Array<DirectionType>,
  Offset | null,
  Footnote | null,
  Level | null,
  Voice | null,
  Staff | null,
  Sound | null,
  Listening | null
];

export class Direction implements XMLElement<'direction', DirectionAttributes, DirectionContents> {
  static readonly schema = {
    name: 'direction',
    attributes: {
      directive: { type: 'optional', value: { type: 'choices', choices: ['yes', 'no'] } },
      id: { type: 'optional', value: { type: 'regex', pattern: /[A-Za-z_][A-Za-z0-9.-_]*/, zero: '_' } },
      placement: { type: 'optional', value: { type: 'choices', choices: ['above', 'below'] } },
      system: { type: 'optional', value: { type: 'choices', choices: ['none', 'only-top', 'also-top'] } },
    },
    contents: [
      { type: 'label', label: 'direction-types', value: { type: 'oneOrMore', value: DirectionType } },
      { type: 'optional', value: Offset },
      { type: 'optional', value: Footnote },
      { type: 'optional', value: Level },
      { type: 'optional', value: Voice },
      { type: 'optional', value: Staff },
      { type: 'optional', value: Sound },
      { type: 'optional', value: Listening },
    ],
  } as const;

  readonly schema = Direction.schema;

  attributes: DirectionAttributes;
  contents: DirectionContents;

  constructor(opts?: { attributes?: Partial<DirectionAttributes>; contents?: DirectionContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Direction.schema);
    this.contents = opts?.contents ?? operations.zero(Direction.schema.contents);
  }
  getDirective(): 'yes' | 'no' | null {
    return this.attributes['directive'];
  }
  setDirective(directive: 'yes' | 'no' | null): Direction {
    this.attributes['directive'] = directive;
    return this;
  }
  getId(): string | null {
    return this.attributes['id'];
  }
  setId(id: string | null): Direction {
    this.attributes['id'] = id;
    return this;
  }
  getPlacement(): 'above' | 'below' | null {
    return this.attributes['placement'];
  }
  setPlacement(placement: 'above' | 'below' | null): Direction {
    this.attributes['placement'] = placement;
    return this;
  }
  getSystem(): 'none' | 'only-top' | 'also-top' | null {
    return this.attributes['system'];
  }
  setSystem(system: 'none' | 'only-top' | 'also-top' | null): Direction {
    this.attributes['system'] = system;
    return this;
  }
  getDirectionTypes(): Array<DirectionType> {
    return this.contents[0];
  }
  setDirectionTypes(directionTypes: Array<DirectionType>): Direction {
    this.contents[0] = directionTypes;
    return this;
  }
  getOffset(): Offset | null {
    return this.contents[1];
  }
  setOffset(offset: Offset | null): Direction {
    this.contents[1] = offset;
    return this;
  }
  getFootnote(): Footnote | null {
    return this.contents[2];
  }
  setFootnote(footnote: Footnote | null): Direction {
    this.contents[2] = footnote;
    return this;
  }
  getLevel(): Level | null {
    return this.contents[3];
  }
  setLevel(level: Level | null): Direction {
    this.contents[3] = level;
    return this;
  }
  getVoice(): Voice | null {
    return this.contents[4];
  }
  setVoice(voice: Voice | null): Direction {
    this.contents[4] = voice;
    return this;
  }
  getStaff(): Staff | null {
    return this.contents[5];
  }
  setStaff(staff: Staff | null): Direction {
    this.contents[5] = staff;
    return this;
  }
  getSound(): Sound | null {
    return this.contents[6];
  }
  setSound(sound: Sound | null): Direction {
    this.contents[6] = sound;
    return this;
  }
  getListening(): Listening | null {
    return this.contents[7];
  }
  setListening(listening: Listening | null): Direction {
    this.contents[7] = listening;
    return this;
  }
}

export type DivisionsAttributes = Record<string, unknown>;

export type DivisionsContents = [number];

export class Divisions implements XMLElement<'divisions', DivisionsAttributes, DivisionsContents> {
  static readonly schema = {
    name: 'divisions',
    attributes: {},
    contents: [
      {
        type: 'required',
        value: { type: 'label', label: 'positive-divisions', value: { type: 'float', min: 1, max: Infinity } },
      },
    ],
  } as const;

  readonly schema = Divisions.schema;

  attributes: DivisionsAttributes;
  contents: DivisionsContents;

  constructor(opts?: { attributes?: Partial<DivisionsAttributes>; contents?: DivisionsContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Divisions.schema);
    this.contents = opts?.contents ?? operations.zero(Divisions.schema.contents);
  }

  getPositiveDivisions(): number {
    return this.contents[0];
  }
  setPositiveDivisions(positiveDivisions: number): Divisions {
    this.contents[0] = positiveDivisions;
    return this;
  }
}

export type CancelAttributes = { location: 'left' | 'right' | 'beforeBarline' | null };

export type CancelContents = [number];

export class Cancel implements XMLElement<'cancel', CancelAttributes, CancelContents> {
  static readonly schema = {
    name: 'cancel',
    attributes: {
      location: { type: 'optional', value: { type: 'choices', choices: ['left', 'right', 'beforeBarline'] } },
    },
    contents: [
      {
        type: 'label',
        label: 'fifths',
        value: { type: 'required', value: { type: 'int', min: -Infinity, max: Infinity } },
      },
    ],
  } as const;

  readonly schema = Cancel.schema;

  attributes: CancelAttributes;
  contents: CancelContents;

  constructor(opts?: { attributes?: Partial<CancelAttributes>; contents?: CancelContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Cancel.schema);
    this.contents = opts?.contents ?? operations.zero(Cancel.schema.contents);
  }
  getLocation(): 'left' | 'right' | 'beforeBarline' | null {
    return this.attributes['location'];
  }
  setLocation(location: 'left' | 'right' | 'beforeBarline' | null): Cancel {
    this.attributes['location'] = location;
    return this;
  }
  getFifths(): number {
    return this.contents[0];
  }
  setFifths(fifths: number): Cancel {
    this.contents[0] = fifths;
    return this;
  }
}

export type FifthsAttributes = Record<string, unknown>;

export type FifthsContents = [number | null];

export class Fifths implements XMLElement<'fifths', FifthsAttributes, FifthsContents> {
  static readonly schema = {
    name: 'fifths',
    attributes: {},
    contents: [
      {
        type: 'label',
        label: 'value',
        value: { type: 'optional', value: { type: 'int', min: -Infinity, max: Infinity } },
      },
    ],
  } as const;

  readonly schema = Fifths.schema;

  attributes: FifthsAttributes;
  contents: FifthsContents;

  constructor(opts?: { attributes?: Partial<FifthsAttributes>; contents?: FifthsContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Fifths.schema);
    this.contents = opts?.contents ?? operations.zero(Fifths.schema.contents);
  }

  getValue(): number | null {
    return this.contents[0];
  }
  setValue(value: number | null): Fifths {
    this.contents[0] = value;
    return this;
  }
}

export type ModeAttributes = Record<string, unknown>;

export type ModeContents = [
  | 'none'
  | 'major'
  | 'minor'
  | 'dorian'
  | 'phrygian'
  | 'lydian'
  | 'mixolydian'
  | 'aeolian'
  | 'ionian'
  | 'locrian'
  | string
];

export class Mode implements XMLElement<'mode', ModeAttributes, ModeContents> {
  static readonly schema = {
    name: 'mode',
    attributes: {},
    contents: [
      {
        type: 'required',
        value: {
          type: 'label',
          label: 'mode',
          value: {
            type: 'choices',
            choices: [
              'none',
              'major',
              'minor',
              'dorian',
              'phrygian',
              'lydian',
              'mixolydian',
              'aeolian',
              'ionian',
              'locrian',
              { type: 'string' },
            ],
          },
        },
      },
    ],
  } as const;

  readonly schema = Mode.schema;

  attributes: ModeAttributes;
  contents: ModeContents;

  constructor(opts?: { attributes?: Partial<ModeAttributes>; contents?: ModeContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Mode.schema);
    this.contents = opts?.contents ?? operations.zero(Mode.schema.contents);
  }

  getMode():
    | 'none'
    | 'major'
    | 'minor'
    | 'dorian'
    | 'phrygian'
    | 'lydian'
    | 'mixolydian'
    | 'aeolian'
    | 'ionian'
    | 'locrian'
    | string {
    return this.contents[0];
  }
  setMode(
    mode:
      | 'none'
      | 'major'
      | 'minor'
      | 'dorian'
      | 'phrygian'
      | 'lydian'
      | 'mixolydian'
      | 'aeolian'
      | 'ionian'
      | 'locrian'
      | string
  ): Mode {
    this.contents[0] = mode;
    return this;
  }
}

export type KeyStepAttributes = Record<string, unknown>;

export type KeyStepContents = ['A' | 'B' | 'C' | 'D' | 'E' | 'F' | 'G'];

export class KeyStep implements XMLElement<'key-step', KeyStepAttributes, KeyStepContents> {
  static readonly schema = {
    name: 'key-step',
    attributes: {},
    contents: [
      {
        type: 'required',
        value: {
          type: 'label',
          label: 'step',
          value: { type: 'choices', choices: ['A', 'B', 'C', 'D', 'E', 'F', 'G'] },
        },
      },
    ],
  } as const;

  readonly schema = KeyStep.schema;

  attributes: KeyStepAttributes;
  contents: KeyStepContents;

  constructor(opts?: { attributes?: Partial<KeyStepAttributes>; contents?: KeyStepContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, KeyStep.schema);
    this.contents = opts?.contents ?? operations.zero(KeyStep.schema.contents);
  }

  getStep(): 'A' | 'B' | 'C' | 'D' | 'E' | 'F' | 'G' {
    return this.contents[0];
  }
  setStep(step: 'A' | 'B' | 'C' | 'D' | 'E' | 'F' | 'G'): KeyStep {
    this.contents[0] = step;
    return this;
  }
}

export type KeyAlterAttributes = Record<string, unknown>;

export type KeyAlterContents = [number];

export class KeyAlter implements XMLElement<'key-alter', KeyAlterAttributes, KeyAlterContents> {
  static readonly schema = {
    name: 'key-alter',
    attributes: {},
    contents: [
      {
        type: 'required',
        value: { type: 'label', label: 'semitones', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
    ],
  } as const;

  readonly schema = KeyAlter.schema;

  attributes: KeyAlterAttributes;
  contents: KeyAlterContents;

  constructor(opts?: { attributes?: Partial<KeyAlterAttributes>; contents?: KeyAlterContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, KeyAlter.schema);
    this.contents = opts?.contents ?? operations.zero(KeyAlter.schema.contents);
  }

  getSemitones(): number {
    return this.contents[0];
  }
  setSemitones(semitones: number): KeyAlter {
    this.contents[0] = semitones;
    return this;
  }
}

export type KeyAccidentalAttributes = { smufl: string | null };

export type KeyAccidentalContents = [
  | 'other'
  | 'sharp'
  | 'natural'
  | 'flat'
  | 'double-sharp'
  | 'sharp-sharp'
  | 'flat-flat'
  | 'natural-sharp'
  | 'natural-flat'
  | 'quarter-flat'
  | 'quarter-sharp'
  | 'three-quarters-flat'
  | 'three-quarters-sharp'
  | 'sharp-down'
  | 'sharp-up'
  | 'natural-down'
  | 'natural-up'
  | 'flat-down'
  | 'flat-up'
  | 'double-sharp-down'
  | 'double-sharp-up'
  | 'flat-flat-down'
  | 'flat-flat-up'
  | 'arrow-down'
  | 'arrow-up'
  | 'triple-sharp'
  | 'triple-flat'
  | 'slash-quarter-sharp'
  | 'slash-sharp'
  | 'slash-flat'
  | 'double-slash-flat'
  | 'sharp-1'
  | 'sharp-2'
  | 'sharp-3'
  | 'sharp-5'
  | 'flat-1'
  | 'flat-2'
  | 'flat-3'
  | 'flat-4'
  | 'sori'
  | 'koron'
];

export class KeyAccidental implements XMLElement<'key-accidental', KeyAccidentalAttributes, KeyAccidentalContents> {
  static readonly schema = {
    name: 'key-accidental',
    attributes: {
      smufl: {
        type: 'optional',
        value: { type: 'regex', pattern: /(acc|medRenFla|medRenNatura|medRenShar|kievanAccidental)/, zero: 'acc' },
      },
    },
    contents: [
      {
        type: 'required',
        value: {
          type: 'label',
          label: 'accidental-value',
          value: {
            type: 'choices',
            choices: [
              'other',
              'sharp',
              'natural',
              'flat',
              'double-sharp',
              'sharp-sharp',
              'flat-flat',
              'natural-sharp',
              'natural-flat',
              'quarter-flat',
              'quarter-sharp',
              'three-quarters-flat',
              'three-quarters-sharp',
              'sharp-down',
              'sharp-up',
              'natural-down',
              'natural-up',
              'flat-down',
              'flat-up',
              'double-sharp-down',
              'double-sharp-up',
              'flat-flat-down',
              'flat-flat-up',
              'arrow-down',
              'arrow-up',
              'triple-sharp',
              'triple-flat',
              'slash-quarter-sharp',
              'slash-sharp',
              'slash-flat',
              'double-slash-flat',
              'sharp-1',
              'sharp-2',
              'sharp-3',
              'sharp-5',
              'flat-1',
              'flat-2',
              'flat-3',
              'flat-4',
              'sori',
              'koron',
            ],
          },
        },
      },
    ],
  } as const;

  readonly schema = KeyAccidental.schema;

  attributes: KeyAccidentalAttributes;
  contents: KeyAccidentalContents;

  constructor(opts?: { attributes?: Partial<KeyAccidentalAttributes>; contents?: KeyAccidentalContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, KeyAccidental.schema);
    this.contents = opts?.contents ?? operations.zero(KeyAccidental.schema.contents);
  }
  getSmufl(): string | null {
    return this.attributes['smufl'];
  }
  setSmufl(smufl: string | null): KeyAccidental {
    this.attributes['smufl'] = smufl;
    return this;
  }
  getAccidentalValue():
    | 'other'
    | 'sharp'
    | 'natural'
    | 'flat'
    | 'double-sharp'
    | 'sharp-sharp'
    | 'flat-flat'
    | 'natural-sharp'
    | 'natural-flat'
    | 'quarter-flat'
    | 'quarter-sharp'
    | 'three-quarters-flat'
    | 'three-quarters-sharp'
    | 'sharp-down'
    | 'sharp-up'
    | 'natural-down'
    | 'natural-up'
    | 'flat-down'
    | 'flat-up'
    | 'double-sharp-down'
    | 'double-sharp-up'
    | 'flat-flat-down'
    | 'flat-flat-up'
    | 'arrow-down'
    | 'arrow-up'
    | 'triple-sharp'
    | 'triple-flat'
    | 'slash-quarter-sharp'
    | 'slash-sharp'
    | 'slash-flat'
    | 'double-slash-flat'
    | 'sharp-1'
    | 'sharp-2'
    | 'sharp-3'
    | 'sharp-5'
    | 'flat-1'
    | 'flat-2'
    | 'flat-3'
    | 'flat-4'
    | 'sori'
    | 'koron' {
    return this.contents[0];
  }
  setAccidentalValue(
    accidentalValue:
      | 'other'
      | 'sharp'
      | 'natural'
      | 'flat'
      | 'double-sharp'
      | 'sharp-sharp'
      | 'flat-flat'
      | 'natural-sharp'
      | 'natural-flat'
      | 'quarter-flat'
      | 'quarter-sharp'
      | 'three-quarters-flat'
      | 'three-quarters-sharp'
      | 'sharp-down'
      | 'sharp-up'
      | 'natural-down'
      | 'natural-up'
      | 'flat-down'
      | 'flat-up'
      | 'double-sharp-down'
      | 'double-sharp-up'
      | 'flat-flat-down'
      | 'flat-flat-up'
      | 'arrow-down'
      | 'arrow-up'
      | 'triple-sharp'
      | 'triple-flat'
      | 'slash-quarter-sharp'
      | 'slash-sharp'
      | 'slash-flat'
      | 'double-slash-flat'
      | 'sharp-1'
      | 'sharp-2'
      | 'sharp-3'
      | 'sharp-5'
      | 'flat-1'
      | 'flat-2'
      | 'flat-3'
      | 'flat-4'
      | 'sori'
      | 'koron'
  ): KeyAccidental {
    this.contents[0] = accidentalValue;
    return this;
  }
}

export type KeyOctaveAttributes = { number: number; cancel: 'yes' | 'no' | null };

export type KeyOctaveContents = [number];

export class KeyOctave implements XMLElement<'key-octave', KeyOctaveAttributes, KeyOctaveContents> {
  static readonly schema = {
    name: 'key-octave',
    attributes: {
      number: { type: 'required', value: { type: 'int', min: 1, max: Infinity } },
      cancel: { type: 'optional', value: { type: 'choices', choices: ['yes', 'no'] } },
    },
    contents: [{ type: 'required', value: { type: 'label', label: 'octave', value: { type: 'int', min: 0, max: 9 } } }],
  } as const;

  readonly schema = KeyOctave.schema;

  attributes: KeyOctaveAttributes;
  contents: KeyOctaveContents;

  constructor(opts?: { attributes?: Partial<KeyOctaveAttributes>; contents?: KeyOctaveContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, KeyOctave.schema);
    this.contents = opts?.contents ?? operations.zero(KeyOctave.schema.contents);
  }
  getNumber(): number {
    return this.attributes['number'];
  }
  setNumber(number: number): KeyOctave {
    this.attributes['number'] = number;
    return this;
  }
  getCancel(): 'yes' | 'no' | null {
    return this.attributes['cancel'];
  }
  setCancel(cancel: 'yes' | 'no' | null): KeyOctave {
    this.attributes['cancel'] = cancel;
    return this;
  }
  getOctave(): number {
    return this.contents[0];
  }
  setOctave(octave: number): KeyOctave {
    this.contents[0] = octave;
    return this;
  }
}

export type TranditionalKey = [Cancel | null, Fifths, Mode | null];

export type AlternateKey = Array<[KeyStep, KeyAlter, KeyAccidental | null]>;

export type KeyAttributes = {
  color: string | null;
  'default-x': number | null;
  'default-y': number | null;
  'font-family': string | null;
  'font-size': 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null;
  'font-style': 'normal' | 'italic' | null;
  'font-weight': 'normal' | 'bold' | null;
  id: string | null;
  number: number | null;
  'print-object': 'yes' | 'no' | null;
  'relative-x': number | null;
  'relative-y': number | null;
};

export type KeyContents = [TranditionalKey | AlternateKey, Array<KeyOctave>];

export class Key implements XMLElement<'key', KeyAttributes, KeyContents> {
  static readonly schema = {
    name: 'key',
    attributes: {
      color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
      'default-x': {
        type: 'label',
        label: 'default-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'default-y': {
        type: 'label',
        label: 'default-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
      'font-size': {
        type: 'optional',
        value: {
          type: 'choices',
          choices: [
            { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
            { type: 'float', min: -Infinity, max: Infinity },
          ],
        },
      },
      'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
      'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
      id: { type: 'optional', value: { type: 'regex', pattern: /[A-Za-z_][A-Za-z0-9.-_]*/, zero: '_' } },
      number: { type: 'optional', value: { type: 'int', min: 1, max: Infinity } },
      'print-object': { type: 'optional', value: { type: 'choices', choices: ['yes', 'no'] } },
      'relative-x': {
        type: 'label',
        label: 'relative-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'relative-y': {
        type: 'label',
        label: 'relative-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
    },
    contents: [
      {
        type: 'label',
        label: 'key-value',
        value: {
          type: 'choices',
          choices: [
            {
              type: 'label',
              label: 'tranditional-key',
              value: [
                { type: 'optional', value: Cancel },
                { type: 'required', value: Fifths },
                { type: 'optional', value: Mode },
              ],
            },
            {
              type: 'label',
              label: 'alternate-key',
              value: {
                type: 'zeroOrMore',
                value: [
                  { type: 'required', value: KeyStep },
                  { type: 'required', value: KeyAlter },
                  { type: 'optional', value: KeyAccidental },
                ],
              },
            },
          ],
        },
      },
      { type: 'label', label: 'key-octaves', value: { type: 'zeroOrMore', value: KeyOctave } },
    ],
  } as const;

  readonly schema = Key.schema;

  attributes: KeyAttributes;
  contents: KeyContents;

  constructor(opts?: { attributes?: Partial<KeyAttributes>; contents?: KeyContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Key.schema);
    this.contents = opts?.contents ?? operations.zero(Key.schema.contents);
  }
  getColor(): string | null {
    return this.attributes['color'];
  }
  setColor(color: string | null): Key {
    this.attributes['color'] = color;
    return this;
  }
  getDefaultX(): number | null {
    return this.attributes['default-x'];
  }
  setDefaultX(defaultX: number | null): Key {
    this.attributes['default-x'] = defaultX;
    return this;
  }
  getDefaultY(): number | null {
    return this.attributes['default-y'];
  }
  setDefaultY(defaultY: number | null): Key {
    this.attributes['default-y'] = defaultY;
    return this;
  }
  getFontFamily(): string | null {
    return this.attributes['font-family'];
  }
  setFontFamily(fontFamily: string | null): Key {
    this.attributes['font-family'] = fontFamily;
    return this;
  }
  getFontSize(): 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null {
    return this.attributes['font-size'];
  }
  setFontSize(
    fontSize: 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null
  ): Key {
    this.attributes['font-size'] = fontSize;
    return this;
  }
  getFontStyle(): 'normal' | 'italic' | null {
    return this.attributes['font-style'];
  }
  setFontStyle(fontStyle: 'normal' | 'italic' | null): Key {
    this.attributes['font-style'] = fontStyle;
    return this;
  }
  getFontWeight(): 'normal' | 'bold' | null {
    return this.attributes['font-weight'];
  }
  setFontWeight(fontWeight: 'normal' | 'bold' | null): Key {
    this.attributes['font-weight'] = fontWeight;
    return this;
  }
  getId(): string | null {
    return this.attributes['id'];
  }
  setId(id: string | null): Key {
    this.attributes['id'] = id;
    return this;
  }
  getNumber(): number | null {
    return this.attributes['number'];
  }
  setNumber(number: number | null): Key {
    this.attributes['number'] = number;
    return this;
  }
  getPrintObject(): 'yes' | 'no' | null {
    return this.attributes['print-object'];
  }
  setPrintObject(printObject: 'yes' | 'no' | null): Key {
    this.attributes['print-object'] = printObject;
    return this;
  }
  getRelativeX(): number | null {
    return this.attributes['relative-x'];
  }
  setRelativeX(relativeX: number | null): Key {
    this.attributes['relative-x'] = relativeX;
    return this;
  }
  getRelativeY(): number | null {
    return this.attributes['relative-y'];
  }
  setRelativeY(relativeY: number | null): Key {
    this.attributes['relative-y'] = relativeY;
    return this;
  }
  getKeyValue(): TranditionalKey | AlternateKey {
    return this.contents[0];
  }
  setKeyValue(keyValue: TranditionalKey | AlternateKey): Key {
    this.contents[0] = keyValue;
    return this;
  }
  getKeyOctaves(): Array<KeyOctave> {
    return this.contents[1];
  }
  setKeyOctaves(keyOctaves: Array<KeyOctave>): Key {
    this.contents[1] = keyOctaves;
    return this;
  }
}

export type BeatsAttributes = Record<string, unknown>;

export type BeatsContents = [string];

export class Beats implements XMLElement<'beats', BeatsAttributes, BeatsContents> {
  static readonly schema = {
    name: 'beats',
    attributes: {},
    contents: [{ type: 'required', value: { type: 'string' } }],
  } as const;

  readonly schema = Beats.schema;

  attributes: BeatsAttributes;
  contents: BeatsContents;

  constructor(opts?: { attributes?: Partial<BeatsAttributes>; contents?: BeatsContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Beats.schema);
    this.contents = opts?.contents ?? operations.zero(Beats.schema.contents);
  }

  getText(): string {
    return this.contents[0];
  }
  setText(text: string): Beats {
    this.contents[0] = text;
    return this;
  }
}

export type BeatTypeAttributes = Record<string, unknown>;

export type BeatTypeContents = [string];

export class BeatType implements XMLElement<'beat-type', BeatTypeAttributes, BeatTypeContents> {
  static readonly schema = {
    name: 'beat-type',
    attributes: {},
    contents: [{ type: 'required', value: { type: 'string' } }],
  } as const;

  readonly schema = BeatType.schema;

  attributes: BeatTypeAttributes;
  contents: BeatTypeContents;

  constructor(opts?: { attributes?: Partial<BeatTypeAttributes>; contents?: BeatTypeContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, BeatType.schema);
    this.contents = opts?.contents ?? operations.zero(BeatType.schema.contents);
  }

  getText(): string {
    return this.contents[0];
  }
  setText(text: string): BeatType {
    this.contents[0] = text;
    return this;
  }
}

export type TimeRelationAttributes = Record<string, unknown>;

export type TimeRelationContents = ['space' | 'bracket' | 'equals' | 'hyphen' | 'parentheses' | 'slash'];

export class TimeRelation implements XMLElement<'time-relation', TimeRelationAttributes, TimeRelationContents> {
  static readonly schema = {
    name: 'time-relation',
    attributes: {},
    contents: [
      {
        type: 'required',
        value: {
          type: 'label',
          label: 'time-relation',
          value: { type: 'choices', choices: ['space', 'bracket', 'equals', 'hyphen', 'parentheses', 'slash'] },
        },
      },
    ],
  } as const;

  readonly schema = TimeRelation.schema;

  attributes: TimeRelationAttributes;
  contents: TimeRelationContents;

  constructor(opts?: { attributes?: Partial<TimeRelationAttributes>; contents?: TimeRelationContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, TimeRelation.schema);
    this.contents = opts?.contents ?? operations.zero(TimeRelation.schema.contents);
  }

  getTimeRelation(): 'space' | 'bracket' | 'equals' | 'hyphen' | 'parentheses' | 'slash' {
    return this.contents[0];
  }
  setTimeRelation(timeRelation: 'space' | 'bracket' | 'equals' | 'hyphen' | 'parentheses' | 'slash'): TimeRelation {
    this.contents[0] = timeRelation;
    return this;
  }
}

export type InterchangeableAttributes = {
  separator: 'none' | 'adjacent' | 'diagonal' | 'horizontal' | 'vertical' | null;
  symbol: 'normal' | 'common' | 'cut' | 'dotted-note' | 'note' | 'single-number' | null;
};

export type InterchangeableContents = [TimeRelation | null, Array<[Beats, BeatType]>];

export class Interchangeable
  implements XMLElement<'interchangeable', InterchangeableAttributes, InterchangeableContents>
{
  static readonly schema = {
    name: 'interchangeable',
    attributes: {
      separator: {
        type: 'optional',
        value: { type: 'choices', choices: ['none', 'adjacent', 'diagonal', 'horizontal', 'vertical'] },
      },
      symbol: {
        type: 'optional',
        value: { type: 'choices', choices: ['normal', 'common', 'cut', 'dotted-note', 'note', 'single-number'] },
      },
    },
    contents: [
      { type: 'optional', value: TimeRelation },
      {
        type: 'label',
        label: 'beats',
        value: {
          type: 'oneOrMore',
          value: [
            { type: 'required', value: Beats },
            { type: 'required', value: BeatType },
          ],
        },
      },
    ],
  } as const;

  readonly schema = Interchangeable.schema;

  attributes: InterchangeableAttributes;
  contents: InterchangeableContents;

  constructor(opts?: { attributes?: Partial<InterchangeableAttributes>; contents?: InterchangeableContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Interchangeable.schema);
    this.contents = opts?.contents ?? operations.zero(Interchangeable.schema.contents);
  }
  getSeparator(): 'none' | 'adjacent' | 'diagonal' | 'horizontal' | 'vertical' | null {
    return this.attributes['separator'];
  }
  setSeparator(separator: 'none' | 'adjacent' | 'diagonal' | 'horizontal' | 'vertical' | null): Interchangeable {
    this.attributes['separator'] = separator;
    return this;
  }
  getSymbol(): 'normal' | 'common' | 'cut' | 'dotted-note' | 'note' | 'single-number' | null {
    return this.attributes['symbol'];
  }
  setSymbol(symbol: 'normal' | 'common' | 'cut' | 'dotted-note' | 'note' | 'single-number' | null): Interchangeable {
    this.attributes['symbol'] = symbol;
    return this;
  }
  getTimeRelation(): TimeRelation | null {
    return this.contents[0];
  }
  setTimeRelation(timeRelation: TimeRelation | null): Interchangeable {
    this.contents[0] = timeRelation;
    return this;
  }
  getBeats(): Array<[Beats, BeatType]> {
    return this.contents[1];
  }
  setBeats(beats: Array<[Beats, BeatType]>): Interchangeable {
    this.contents[1] = beats;
    return this;
  }
}

export type SenzaMisuraAttributes = Record<string, unknown>;

export type SenzaMisuraContents = [string];

export class SenzaMisura implements XMLElement<'senza-misura', SenzaMisuraAttributes, SenzaMisuraContents> {
  static readonly schema = {
    name: 'senza-misura',
    attributes: {},
    contents: [{ type: 'required', value: { type: 'string' } }],
  } as const;

  readonly schema = SenzaMisura.schema;

  attributes: SenzaMisuraAttributes;
  contents: SenzaMisuraContents;

  constructor(opts?: { attributes?: Partial<SenzaMisuraAttributes>; contents?: SenzaMisuraContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, SenzaMisura.schema);
    this.contents = opts?.contents ?? operations.zero(SenzaMisura.schema.contents);
  }

  getText(): string {
    return this.contents[0];
  }
  setText(text: string): SenzaMisura {
    this.contents[0] = text;
    return this;
  }
}

export type TimeSignature = [Array<[Beats, BeatType]>, Interchangeable | null];

export type TimeAttributes = {
  color: string | null;
  'default-x': number | null;
  'default-y': number | null;
  'font-family': string | null;
  'font-size': 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null;
  'font-style': 'normal' | 'italic' | null;
  'font-weight': 'normal' | 'bold' | null;
  halign: 'left' | 'center' | 'right' | null;
  id: string | null;
  number: number | null;
  'print-object': 'yes' | 'no' | null;
  'relative-x': number | null;
  'relative-y': number | null;
  separator: 'none' | 'adjacent' | 'diagonal' | 'horizontal' | 'vertical' | null;
  symbol: 'normal' | 'common' | 'cut' | 'dotted-note' | 'note' | 'single-number' | null;
  valign: 'top' | 'middle' | 'bottom' | 'baseline' | null;
};

export type TimeContents = [TimeSignature | SenzaMisura];

export class Time implements XMLElement<'time', TimeAttributes, TimeContents> {
  static readonly schema = {
    name: 'time',
    attributes: {
      color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
      'default-x': {
        type: 'label',
        label: 'default-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'default-y': {
        type: 'label',
        label: 'default-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
      'font-size': {
        type: 'optional',
        value: {
          type: 'choices',
          choices: [
            { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
            { type: 'float', min: -Infinity, max: Infinity },
          ],
        },
      },
      'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
      'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
      halign: { type: 'optional', value: { type: 'choices', choices: ['left', 'center', 'right'] } },
      id: { type: 'optional', value: { type: 'regex', pattern: /[A-Za-z_][A-Za-z0-9.-_]*/, zero: '_' } },
      number: { type: 'optional', value: { type: 'int', min: 1, max: Infinity } },
      'print-object': { type: 'optional', value: { type: 'choices', choices: ['yes', 'no'] } },
      'relative-x': { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      'relative-y': { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      separator: {
        type: 'optional',
        value: { type: 'choices', choices: ['none', 'adjacent', 'diagonal', 'horizontal', 'vertical'] },
      },
      symbol: {
        type: 'optional',
        value: { type: 'choices', choices: ['normal', 'common', 'cut', 'dotted-note', 'note', 'single-number'] },
      },
      valign: { type: 'optional', value: { type: 'choices', choices: ['top', 'middle', 'bottom', 'baseline'] } },
    },
    contents: [
      {
        type: 'label',
        label: 'time-value',
        value: {
          type: 'choices',
          choices: [
            {
              type: 'label',
              label: 'time-signature',
              value: [
                {
                  type: 'oneOrMore',
                  value: [
                    { type: 'required', value: Beats },
                    { type: 'required', value: BeatType },
                  ],
                },
                { type: 'optional', value: Interchangeable },
              ],
            },
            SenzaMisura,
          ],
        },
      },
    ],
  } as const;

  readonly schema = Time.schema;

  attributes: TimeAttributes;
  contents: TimeContents;

  constructor(opts?: { attributes?: Partial<TimeAttributes>; contents?: TimeContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Time.schema);
    this.contents = opts?.contents ?? operations.zero(Time.schema.contents);
  }
  getColor(): string | null {
    return this.attributes['color'];
  }
  setColor(color: string | null): Time {
    this.attributes['color'] = color;
    return this;
  }
  getDefaultX(): number | null {
    return this.attributes['default-x'];
  }
  setDefaultX(defaultX: number | null): Time {
    this.attributes['default-x'] = defaultX;
    return this;
  }
  getDefaultY(): number | null {
    return this.attributes['default-y'];
  }
  setDefaultY(defaultY: number | null): Time {
    this.attributes['default-y'] = defaultY;
    return this;
  }
  getFontFamily(): string | null {
    return this.attributes['font-family'];
  }
  setFontFamily(fontFamily: string | null): Time {
    this.attributes['font-family'] = fontFamily;
    return this;
  }
  getFontSize(): 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null {
    return this.attributes['font-size'];
  }
  setFontSize(
    fontSize: 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null
  ): Time {
    this.attributes['font-size'] = fontSize;
    return this;
  }
  getFontStyle(): 'normal' | 'italic' | null {
    return this.attributes['font-style'];
  }
  setFontStyle(fontStyle: 'normal' | 'italic' | null): Time {
    this.attributes['font-style'] = fontStyle;
    return this;
  }
  getFontWeight(): 'normal' | 'bold' | null {
    return this.attributes['font-weight'];
  }
  setFontWeight(fontWeight: 'normal' | 'bold' | null): Time {
    this.attributes['font-weight'] = fontWeight;
    return this;
  }
  getHalign(): 'left' | 'center' | 'right' | null {
    return this.attributes['halign'];
  }
  setHalign(halign: 'left' | 'center' | 'right' | null): Time {
    this.attributes['halign'] = halign;
    return this;
  }
  getId(): string | null {
    return this.attributes['id'];
  }
  setId(id: string | null): Time {
    this.attributes['id'] = id;
    return this;
  }
  getNumber(): number | null {
    return this.attributes['number'];
  }
  setNumber(number: number | null): Time {
    this.attributes['number'] = number;
    return this;
  }
  getPrintObject(): 'yes' | 'no' | null {
    return this.attributes['print-object'];
  }
  setPrintObject(printObject: 'yes' | 'no' | null): Time {
    this.attributes['print-object'] = printObject;
    return this;
  }
  getRelativeX(): number | null {
    return this.attributes['relative-x'];
  }
  setRelativeX(relativeX: number | null): Time {
    this.attributes['relative-x'] = relativeX;
    return this;
  }
  getRelativeY(): number | null {
    return this.attributes['relative-y'];
  }
  setRelativeY(relativeY: number | null): Time {
    this.attributes['relative-y'] = relativeY;
    return this;
  }
  getSeparator(): 'none' | 'adjacent' | 'diagonal' | 'horizontal' | 'vertical' | null {
    return this.attributes['separator'];
  }
  setSeparator(separator: 'none' | 'adjacent' | 'diagonal' | 'horizontal' | 'vertical' | null): Time {
    this.attributes['separator'] = separator;
    return this;
  }
  getSymbol(): 'normal' | 'common' | 'cut' | 'dotted-note' | 'note' | 'single-number' | null {
    return this.attributes['symbol'];
  }
  setSymbol(symbol: 'normal' | 'common' | 'cut' | 'dotted-note' | 'note' | 'single-number' | null): Time {
    this.attributes['symbol'] = symbol;
    return this;
  }
  getValign(): 'top' | 'middle' | 'bottom' | 'baseline' | null {
    return this.attributes['valign'];
  }
  setValign(valign: 'top' | 'middle' | 'bottom' | 'baseline' | null): Time {
    this.attributes['valign'] = valign;
    return this;
  }
  getTimeValue(): TimeSignature | SenzaMisura {
    return this.contents[0];
  }
  setTimeValue(timeValue: TimeSignature | SenzaMisura): Time {
    this.contents[0] = timeValue;
    return this;
  }
}

export type StavesAttributes = Record<string, unknown>;

export type StavesContents = [number];

export class Staves implements XMLElement<'staves', StavesAttributes, StavesContents> {
  static readonly schema = {
    name: 'staves',
    attributes: {},
    contents: [
      { type: 'label', label: 'value', value: { type: 'required', value: { type: 'int', min: 0, max: Infinity } } },
    ],
  } as const;

  readonly schema = Staves.schema;

  attributes: StavesAttributes;
  contents: StavesContents;

  constructor(opts?: { attributes?: Partial<StavesAttributes>; contents?: StavesContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Staves.schema);
    this.contents = opts?.contents ?? operations.zero(Staves.schema.contents);
  }

  getValue(): number {
    return this.contents[0];
  }
  setValue(value: number): Staves {
    this.contents[0] = value;
    return this;
  }
}

export type PartSymbolAttributes = {
  'bottom-staff': number | null;
  color: string | null;
  'default-x': number | null;
  'default-y': number | null;
  'font-family': string | null;
  'font-size': 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null;
  'font-style': 'normal' | 'italic' | null;
  'font-weight': 'normal' | 'bold' | null;
  'relative-x': number | null;
  'relative-y': number | null;
  'top-staff': number | null;
};

export type PartSymbolContents = ['none' | 'brace' | 'bracket' | 'line' | 'square'];

export class PartSymbol implements XMLElement<'part-symbol', PartSymbolAttributes, PartSymbolContents> {
  static readonly schema = {
    name: 'part-symbol',
    attributes: {
      'bottom-staff': { type: 'optional', value: { type: 'int', min: 1, max: Infinity } },
      color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
      'default-x': {
        type: 'label',
        label: 'default-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'default-y': {
        type: 'label',
        label: 'default-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
      'font-size': {
        type: 'optional',
        value: {
          type: 'choices',
          choices: [
            { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
            { type: 'float', min: -Infinity, max: Infinity },
          ],
        },
      },
      'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
      'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
      'relative-x': {
        type: 'label',
        label: 'relative-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'relative-y': {
        type: 'label',
        label: 'relative-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'top-staff': { type: 'optional', value: { type: 'int', min: 1, max: Infinity } },
    },
    contents: [
      {
        type: 'required',
        value: {
          type: 'label',
          label: 'group-symbol-value',
          value: { type: 'choices', choices: ['none', 'brace', 'bracket', 'line', 'square'] },
        },
      },
    ],
  } as const;

  readonly schema = PartSymbol.schema;

  attributes: PartSymbolAttributes;
  contents: PartSymbolContents;

  constructor(opts?: { attributes?: Partial<PartSymbolAttributes>; contents?: PartSymbolContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, PartSymbol.schema);
    this.contents = opts?.contents ?? operations.zero(PartSymbol.schema.contents);
  }
  getBottomStaff(): number | null {
    return this.attributes['bottom-staff'];
  }
  setBottomStaff(bottomStaff: number | null): PartSymbol {
    this.attributes['bottom-staff'] = bottomStaff;
    return this;
  }
  getColor(): string | null {
    return this.attributes['color'];
  }
  setColor(color: string | null): PartSymbol {
    this.attributes['color'] = color;
    return this;
  }
  getDefaultX(): number | null {
    return this.attributes['default-x'];
  }
  setDefaultX(defaultX: number | null): PartSymbol {
    this.attributes['default-x'] = defaultX;
    return this;
  }
  getDefaultY(): number | null {
    return this.attributes['default-y'];
  }
  setDefaultY(defaultY: number | null): PartSymbol {
    this.attributes['default-y'] = defaultY;
    return this;
  }
  getFontFamily(): string | null {
    return this.attributes['font-family'];
  }
  setFontFamily(fontFamily: string | null): PartSymbol {
    this.attributes['font-family'] = fontFamily;
    return this;
  }
  getFontSize(): 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null {
    return this.attributes['font-size'];
  }
  setFontSize(
    fontSize: 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null
  ): PartSymbol {
    this.attributes['font-size'] = fontSize;
    return this;
  }
  getFontStyle(): 'normal' | 'italic' | null {
    return this.attributes['font-style'];
  }
  setFontStyle(fontStyle: 'normal' | 'italic' | null): PartSymbol {
    this.attributes['font-style'] = fontStyle;
    return this;
  }
  getFontWeight(): 'normal' | 'bold' | null {
    return this.attributes['font-weight'];
  }
  setFontWeight(fontWeight: 'normal' | 'bold' | null): PartSymbol {
    this.attributes['font-weight'] = fontWeight;
    return this;
  }
  getRelativeX(): number | null {
    return this.attributes['relative-x'];
  }
  setRelativeX(relativeX: number | null): PartSymbol {
    this.attributes['relative-x'] = relativeX;
    return this;
  }
  getRelativeY(): number | null {
    return this.attributes['relative-y'];
  }
  setRelativeY(relativeY: number | null): PartSymbol {
    this.attributes['relative-y'] = relativeY;
    return this;
  }
  getTopStaff(): number | null {
    return this.attributes['top-staff'];
  }
  setTopStaff(topStaff: number | null): PartSymbol {
    this.attributes['top-staff'] = topStaff;
    return this;
  }
  getGroupSymbolValue(): 'none' | 'brace' | 'bracket' | 'line' | 'square' {
    return this.contents[0];
  }
  setGroupSymbolValue(groupSymbolValue: 'none' | 'brace' | 'bracket' | 'line' | 'square'): PartSymbol {
    this.contents[0] = groupSymbolValue;
    return this;
  }
}

export type InstrumentsAttributes = Record<string, unknown>;

export type InstrumentsContents = [number];

export class Instruments implements XMLElement<'instruments', InstrumentsAttributes, InstrumentsContents> {
  static readonly schema = {
    name: 'instruments',
    attributes: {},
    contents: [
      { type: 'label', label: 'value', value: { type: 'required', value: { type: 'int', min: 0, max: Infinity } } },
    ],
  } as const;

  readonly schema = Instruments.schema;

  attributes: InstrumentsAttributes;
  contents: InstrumentsContents;

  constructor(opts?: { attributes?: Partial<InstrumentsAttributes>; contents?: InstrumentsContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Instruments.schema);
    this.contents = opts?.contents ?? operations.zero(Instruments.schema.contents);
  }

  getValue(): number {
    return this.contents[0];
  }
  setValue(value: number): Instruments {
    this.contents[0] = value;
    return this;
  }
}

export type SignAttributes = Record<string, unknown>;

export type SignContents = ['G' | 'F' | 'C' | 'percussion' | 'TAB' | 'jianpu' | 'none'];

export class Sign implements XMLElement<'sign', SignAttributes, SignContents> {
  static readonly schema = {
    name: 'sign',
    attributes: {},
    contents: [
      {
        type: 'required',
        value: {
          type: 'label',
          label: 'clef-sign',
          value: { type: 'choices', choices: ['G', 'F', 'C', 'percussion', 'TAB', 'jianpu', 'none'] },
        },
      },
    ],
  } as const;

  readonly schema = Sign.schema;

  attributes: SignAttributes;
  contents: SignContents;

  constructor(opts?: { attributes?: Partial<SignAttributes>; contents?: SignContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Sign.schema);
    this.contents = opts?.contents ?? operations.zero(Sign.schema.contents);
  }

  getClefSign(): 'G' | 'F' | 'C' | 'percussion' | 'TAB' | 'jianpu' | 'none' {
    return this.contents[0];
  }
  setClefSign(clefSign: 'G' | 'F' | 'C' | 'percussion' | 'TAB' | 'jianpu' | 'none'): Sign {
    this.contents[0] = clefSign;
    return this;
  }
}

export type LineAttributes = Record<string, unknown>;

export type LineContents = [number];

export class Line implements XMLElement<'line', LineAttributes, LineContents> {
  static readonly schema = {
    name: 'line',
    attributes: {},
    contents: [
      {
        type: 'required',
        value: { type: 'label', label: 'staff-line-position', value: { type: 'int', min: -Infinity, max: Infinity } },
      },
    ],
  } as const;

  readonly schema = Line.schema;

  attributes: LineAttributes;
  contents: LineContents;

  constructor(opts?: { attributes?: Partial<LineAttributes>; contents?: LineContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Line.schema);
    this.contents = opts?.contents ?? operations.zero(Line.schema.contents);
  }

  getStaffLinePosition(): number {
    return this.contents[0];
  }
  setStaffLinePosition(staffLinePosition: number): Line {
    this.contents[0] = staffLinePosition;
    return this;
  }
}

export type ClefOctaveChangeAttributes = Record<string, unknown>;

export type ClefOctaveChangeContents = [number];

export class ClefOctaveChange
  implements XMLElement<'clef-octave-change', ClefOctaveChangeAttributes, ClefOctaveChangeContents>
{
  static readonly schema = {
    name: 'clef-octave-change',
    attributes: {},
    contents: [
      {
        type: 'label',
        label: 'clef-octave-change',
        value: { type: 'required', value: { type: 'int', min: -Infinity, max: Infinity } },
      },
    ],
  } as const;

  readonly schema = ClefOctaveChange.schema;

  attributes: ClefOctaveChangeAttributes;
  contents: ClefOctaveChangeContents;

  constructor(opts?: { attributes?: Partial<ClefOctaveChangeAttributes>; contents?: ClefOctaveChangeContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, ClefOctaveChange.schema);
    this.contents = opts?.contents ?? operations.zero(ClefOctaveChange.schema.contents);
  }

  getClefOctaveChange(): number {
    return this.contents[0];
  }
  setClefOctaveChange(clefOctaveChange: number): ClefOctaveChange {
    this.contents[0] = clefOctaveChange;
    return this;
  }
}

export type ClefAttributes = {
  additional: 'yes' | 'no' | null;
  'after-barline': 'yes' | 'no' | null;
  color: string | null;
  'default-x': number | null;
  'default-y': number | null;
  'font-family': string | null;
  'font-size': 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null;
  'font-style': 'normal' | 'italic' | null;
  'font-weight': 'normal' | 'bold' | null;
  id: string | null;
  number: number | null;
  'print-object': 'yes' | 'no' | null;
  'relative-x': number | null;
  'relative-y': number | null;
  size: 'cue' | 'full' | 'grace-cue' | 'large' | null;
};

export type ClefContents = [Sign, Line | null, ClefOctaveChange | null];

export class Clef implements XMLElement<'clef', ClefAttributes, ClefContents> {
  static readonly schema = {
    name: 'clef',
    attributes: {
      additional: { type: 'optional', value: { type: 'choices', choices: ['yes', 'no'] } },
      'after-barline': { type: 'optional', value: { type: 'choices', choices: ['yes', 'no'] } },
      color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
      'default-x': {
        type: 'label',
        label: 'default-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'default-y': {
        type: 'label',
        label: 'default-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
      'font-size': {
        type: 'optional',
        value: {
          type: 'choices',
          choices: [
            { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
            { type: 'float', min: -Infinity, max: Infinity },
          ],
        },
      },
      'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
      'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
      id: { type: 'optional', value: { type: 'regex', pattern: /[A-Za-z_][A-Za-z0-9.-_]*/, zero: '_' } },
      number: { type: 'optional', value: { type: 'int', min: 1, max: Infinity } },
      'print-object': { type: 'optional', value: { type: 'choices', choices: ['yes', 'no'] } },
      'relative-x': {
        type: 'label',
        label: 'relative-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'relative-y': {
        type: 'label',
        label: 'relative-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      size: { type: 'optional', value: { type: 'choices', choices: ['cue', 'full', 'grace-cue', 'large'] } },
    },
    contents: [
      { type: 'required', value: Sign },
      { type: 'optional', value: Line },
      { type: 'optional', value: ClefOctaveChange },
    ],
  } as const;

  readonly schema = Clef.schema;

  attributes: ClefAttributes;
  contents: ClefContents;

  constructor(opts?: { attributes?: Partial<ClefAttributes>; contents?: ClefContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Clef.schema);
    this.contents = opts?.contents ?? operations.zero(Clef.schema.contents);
  }
  getAdditional(): 'yes' | 'no' | null {
    return this.attributes['additional'];
  }
  setAdditional(additional: 'yes' | 'no' | null): Clef {
    this.attributes['additional'] = additional;
    return this;
  }
  getAfterBarline(): 'yes' | 'no' | null {
    return this.attributes['after-barline'];
  }
  setAfterBarline(afterBarline: 'yes' | 'no' | null): Clef {
    this.attributes['after-barline'] = afterBarline;
    return this;
  }
  getColor(): string | null {
    return this.attributes['color'];
  }
  setColor(color: string | null): Clef {
    this.attributes['color'] = color;
    return this;
  }
  getDefaultX(): number | null {
    return this.attributes['default-x'];
  }
  setDefaultX(defaultX: number | null): Clef {
    this.attributes['default-x'] = defaultX;
    return this;
  }
  getDefaultY(): number | null {
    return this.attributes['default-y'];
  }
  setDefaultY(defaultY: number | null): Clef {
    this.attributes['default-y'] = defaultY;
    return this;
  }
  getFontFamily(): string | null {
    return this.attributes['font-family'];
  }
  setFontFamily(fontFamily: string | null): Clef {
    this.attributes['font-family'] = fontFamily;
    return this;
  }
  getFontSize(): 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null {
    return this.attributes['font-size'];
  }
  setFontSize(
    fontSize: 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null
  ): Clef {
    this.attributes['font-size'] = fontSize;
    return this;
  }
  getFontStyle(): 'normal' | 'italic' | null {
    return this.attributes['font-style'];
  }
  setFontStyle(fontStyle: 'normal' | 'italic' | null): Clef {
    this.attributes['font-style'] = fontStyle;
    return this;
  }
  getFontWeight(): 'normal' | 'bold' | null {
    return this.attributes['font-weight'];
  }
  setFontWeight(fontWeight: 'normal' | 'bold' | null): Clef {
    this.attributes['font-weight'] = fontWeight;
    return this;
  }
  getId(): string | null {
    return this.attributes['id'];
  }
  setId(id: string | null): Clef {
    this.attributes['id'] = id;
    return this;
  }
  getNumber(): number | null {
    return this.attributes['number'];
  }
  setNumber(number: number | null): Clef {
    this.attributes['number'] = number;
    return this;
  }
  getPrintObject(): 'yes' | 'no' | null {
    return this.attributes['print-object'];
  }
  setPrintObject(printObject: 'yes' | 'no' | null): Clef {
    this.attributes['print-object'] = printObject;
    return this;
  }
  getRelativeX(): number | null {
    return this.attributes['relative-x'];
  }
  setRelativeX(relativeX: number | null): Clef {
    this.attributes['relative-x'] = relativeX;
    return this;
  }
  getRelativeY(): number | null {
    return this.attributes['relative-y'];
  }
  setRelativeY(relativeY: number | null): Clef {
    this.attributes['relative-y'] = relativeY;
    return this;
  }
  getSize(): 'cue' | 'full' | 'grace-cue' | 'large' | null {
    return this.attributes['size'];
  }
  setSize(size: 'cue' | 'full' | 'grace-cue' | 'large' | null): Clef {
    this.attributes['size'] = size;
    return this;
  }
  getSign(): Sign {
    return this.contents[0];
  }
  setSign(sign: Sign): Clef {
    this.contents[0] = sign;
    return this;
  }
  getLine(): Line | null {
    return this.contents[1];
  }
  setLine(line: Line | null): Clef {
    this.contents[1] = line;
    return this;
  }
  getClefOctaveChange(): ClefOctaveChange | null {
    return this.contents[2];
  }
  setClefOctaveChange(clefOctaveChange: ClefOctaveChange | null): Clef {
    this.contents[2] = clefOctaveChange;
    return this;
  }
}

export type StaffTypeAttributes = Record<string, unknown>;

export type StaffTypeContents = ['regular' | 'alternate' | 'cue' | 'editorial' | 'ossia'];

export class StaffType implements XMLElement<'staff-type', StaffTypeAttributes, StaffTypeContents> {
  static readonly schema = {
    name: 'staff-type',
    attributes: {},
    contents: [
      {
        type: 'required',
        value: {
          type: 'label',
          label: 'staff-type',
          value: { type: 'choices', choices: ['regular', 'alternate', 'cue', 'editorial', 'ossia'] },
        },
      },
    ],
  } as const;

  readonly schema = StaffType.schema;

  attributes: StaffTypeAttributes;
  contents: StaffTypeContents;

  constructor(opts?: { attributes?: Partial<StaffTypeAttributes>; contents?: StaffTypeContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, StaffType.schema);
    this.contents = opts?.contents ?? operations.zero(StaffType.schema.contents);
  }

  getStaffType(): 'regular' | 'alternate' | 'cue' | 'editorial' | 'ossia' {
    return this.contents[0];
  }
  setStaffType(staffType: 'regular' | 'alternate' | 'cue' | 'editorial' | 'ossia'): StaffType {
    this.contents[0] = staffType;
    return this;
  }
}

export type StaffLinesAttributes = Record<string, unknown>;

export type StaffLinesContents = [number];

export class StaffLines implements XMLElement<'staff-lines', StaffLinesAttributes, StaffLinesContents> {
  static readonly schema = {
    name: 'staff-lines',
    attributes: {},
    contents: [
      { type: 'label', label: 'value', value: { type: 'required', value: { type: 'int', min: 0, max: Infinity } } },
    ],
  } as const;

  readonly schema = StaffLines.schema;

  attributes: StaffLinesAttributes;
  contents: StaffLinesContents;

  constructor(opts?: { attributes?: Partial<StaffLinesAttributes>; contents?: StaffLinesContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, StaffLines.schema);
    this.contents = opts?.contents ?? operations.zero(StaffLines.schema.contents);
  }

  getValue(): number {
    return this.contents[0];
  }
  setValue(value: number): StaffLines {
    this.contents[0] = value;
    return this;
  }
}

export type LineDetailAttributes = {
  line: number;
  color: string | null;
  'line-type': 'dashed' | 'dotted' | 'solid' | 'wavy' | null;
  'print-object': 'yes' | 'no' | null;
  width: number | null;
};

export type LineDetailContents = [];

export class LineDetail implements XMLElement<'line-detail', LineDetailAttributes, LineDetailContents> {
  static readonly schema = {
    name: 'line-detail',
    attributes: {
      line: { type: 'required', value: { type: 'int', min: 1, max: Infinity } },
      color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
      'line-type': { type: 'optional', value: { type: 'choices', choices: ['dashed', 'dotted', 'solid', 'wavy'] } },
      'print-object': { type: 'optional', value: { type: 'choices', choices: ['yes', 'no'] } },
      width: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
    },
    contents: [],
  } as const;

  readonly schema = LineDetail.schema;

  attributes: LineDetailAttributes;
  contents: LineDetailContents;

  constructor(opts?: { attributes?: Partial<LineDetailAttributes>; contents?: LineDetailContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, LineDetail.schema);
    this.contents = opts?.contents ?? operations.zero(LineDetail.schema.contents);
  }
  getLine(): number {
    return this.attributes['line'];
  }
  setLine(line: number): LineDetail {
    this.attributes['line'] = line;
    return this;
  }
  getColor(): string | null {
    return this.attributes['color'];
  }
  setColor(color: string | null): LineDetail {
    this.attributes['color'] = color;
    return this;
  }
  getLineType(): 'dashed' | 'dotted' | 'solid' | 'wavy' | null {
    return this.attributes['line-type'];
  }
  setLineType(lineType: 'dashed' | 'dotted' | 'solid' | 'wavy' | null): LineDetail {
    this.attributes['line-type'] = lineType;
    return this;
  }
  getPrintObject(): 'yes' | 'no' | null {
    return this.attributes['print-object'];
  }
  setPrintObject(printObject: 'yes' | 'no' | null): LineDetail {
    this.attributes['print-object'] = printObject;
    return this;
  }
  getWidth(): number | null {
    return this.attributes['width'];
  }
  setWidth(width: number | null): LineDetail {
    this.attributes['width'] = width;
    return this;
  }
}

export type StaffTuningAttributes = { line: number };

export type StaffTuningContents = [TuningStep, TuningAlter | null, TuningOctave];

export class StaffTuning implements XMLElement<'staff-tuning', StaffTuningAttributes, StaffTuningContents> {
  static readonly schema = {
    name: 'staff-tuning',
    attributes: { line: { type: 'required', value: { type: 'int', min: 1, max: Infinity } } },
    contents: [
      { type: 'required', value: TuningStep },
      { type: 'optional', value: TuningAlter },
      { type: 'required', value: TuningOctave },
    ],
  } as const;

  readonly schema = StaffTuning.schema;

  attributes: StaffTuningAttributes;
  contents: StaffTuningContents;

  constructor(opts?: { attributes?: Partial<StaffTuningAttributes>; contents?: StaffTuningContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, StaffTuning.schema);
    this.contents = opts?.contents ?? operations.zero(StaffTuning.schema.contents);
  }
  getLine(): number {
    return this.attributes['line'];
  }
  setLine(line: number): StaffTuning {
    this.attributes['line'] = line;
    return this;
  }
  getTuningStep(): TuningStep {
    return this.contents[0];
  }
  setTuningStep(tuningStep: TuningStep): StaffTuning {
    this.contents[0] = tuningStep;
    return this;
  }
  getTuningAlter(): TuningAlter | null {
    return this.contents[1];
  }
  setTuningAlter(tuningAlter: TuningAlter | null): StaffTuning {
    this.contents[1] = tuningAlter;
    return this;
  }
  getTuningOctave(): TuningOctave {
    return this.contents[2];
  }
  setTuningOctave(tuningOctave: TuningOctave): StaffTuning {
    this.contents[2] = tuningOctave;
    return this;
  }
}

export type CapoAttributes = Record<string, unknown>;

export type CapoContents = [number];

export class Capo implements XMLElement<'capo', CapoAttributes, CapoContents> {
  static readonly schema = {
    name: 'capo',
    attributes: {},
    contents: [
      { type: 'label', label: 'value', value: { type: 'required', value: { type: 'int', min: 0, max: Infinity } } },
    ],
  } as const;

  readonly schema = Capo.schema;

  attributes: CapoAttributes;
  contents: CapoContents;

  constructor(opts?: { attributes?: Partial<CapoAttributes>; contents?: CapoContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Capo.schema);
    this.contents = opts?.contents ?? operations.zero(Capo.schema.contents);
  }

  getValue(): number {
    return this.contents[0];
  }
  setValue(value: number): Capo {
    this.contents[0] = value;
    return this;
  }
}

export type StaffSizeAttributes = { scaling: number | null };

export type StaffSizeContents = [number];

export class StaffSize implements XMLElement<'staff-size', StaffSizeAttributes, StaffSizeContents> {
  static readonly schema = {
    name: 'staff-size',
    attributes: { scaling: { type: 'optional', value: { type: 'float', min: 0, max: Infinity } } },
    contents: [
      {
        type: 'label',
        label: 'staff-size-value',
        value: { type: 'required', value: { type: 'float', min: 0, max: Infinity } },
      },
    ],
  } as const;

  readonly schema = StaffSize.schema;

  attributes: StaffSizeAttributes;
  contents: StaffSizeContents;

  constructor(opts?: { attributes?: Partial<StaffSizeAttributes>; contents?: StaffSizeContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, StaffSize.schema);
    this.contents = opts?.contents ?? operations.zero(StaffSize.schema.contents);
  }
  getScaling(): number | null {
    return this.attributes['scaling'];
  }
  setScaling(scaling: number | null): StaffSize {
    this.attributes['scaling'] = scaling;
    return this;
  }
  getStaffSizeValue(): number {
    return this.contents[0];
  }
  setStaffSizeValue(staffSizeValue: number): StaffSize {
    this.contents[0] = staffSizeValue;
    return this;
  }
}

export type StaffDetailsAttributes = {
  number: number | null;
  'print-object': 'yes' | 'no' | null;
  'print-spacing': 'yes' | 'no' | null;
  'show-frets': 'letters' | 'numbers' | null;
};

export type StaffDetailsContents = [
  StaffType | null,
  [StaffLines, Array<LineDetail>] | null,
  Array<StaffTuning>,
  Capo | null,
  StaffSize | null
];

export class StaffDetails implements XMLElement<'staff-details', StaffDetailsAttributes, StaffDetailsContents> {
  static readonly schema = {
    name: 'staff-details',
    attributes: {
      number: { type: 'optional', value: { type: 'int', min: 1, max: Infinity } },
      'print-object': { type: 'optional', value: { type: 'choices', choices: ['yes', 'no'] } },
      'print-spacing': { type: 'optional', value: { type: 'choices', choices: ['yes', 'no'] } },
      'show-frets': { type: 'optional', value: { type: 'choices', choices: ['letters', 'numbers'] } },
    },
    contents: [
      { type: 'optional', value: StaffType },
      {
        type: 'label',
        label: 'lines',
        value: {
          type: 'optional',
          value: [
            { type: 'required', value: StaffLines },
            { type: 'zeroOrMore', value: LineDetail },
          ],
        },
      },
      { type: 'label', label: 'staff-tunings', value: { type: 'zeroOrMore', value: StaffTuning } },
      { type: 'optional', value: Capo },
      { type: 'optional', value: StaffSize },
    ],
  } as const;

  readonly schema = StaffDetails.schema;

  attributes: StaffDetailsAttributes;
  contents: StaffDetailsContents;

  constructor(opts?: { attributes?: Partial<StaffDetailsAttributes>; contents?: StaffDetailsContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, StaffDetails.schema);
    this.contents = opts?.contents ?? operations.zero(StaffDetails.schema.contents);
  }
  getNumber(): number | null {
    return this.attributes['number'];
  }
  setNumber(number: number | null): StaffDetails {
    this.attributes['number'] = number;
    return this;
  }
  getPrintObject(): 'yes' | 'no' | null {
    return this.attributes['print-object'];
  }
  setPrintObject(printObject: 'yes' | 'no' | null): StaffDetails {
    this.attributes['print-object'] = printObject;
    return this;
  }
  getPrintSpacing(): 'yes' | 'no' | null {
    return this.attributes['print-spacing'];
  }
  setPrintSpacing(printSpacing: 'yes' | 'no' | null): StaffDetails {
    this.attributes['print-spacing'] = printSpacing;
    return this;
  }
  getShowFrets(): 'letters' | 'numbers' | null {
    return this.attributes['show-frets'];
  }
  setShowFrets(showFrets: 'letters' | 'numbers' | null): StaffDetails {
    this.attributes['show-frets'] = showFrets;
    return this;
  }
  getStaffType(): StaffType | null {
    return this.contents[0];
  }
  setStaffType(staffType: StaffType | null): StaffDetails {
    this.contents[0] = staffType;
    return this;
  }
  getLines(): [StaffLines, Array<LineDetail>] | null {
    return this.contents[1];
  }
  setLines(lines: [StaffLines, Array<LineDetail>] | null): StaffDetails {
    this.contents[1] = lines;
    return this;
  }
  getStaffTunings(): Array<StaffTuning> {
    return this.contents[2];
  }
  setStaffTunings(staffTunings: Array<StaffTuning>): StaffDetails {
    this.contents[2] = staffTunings;
    return this;
  }
  getCapo(): Capo | null {
    return this.contents[3];
  }
  setCapo(capo: Capo | null): StaffDetails {
    this.contents[3] = capo;
    return this;
  }
  getStaffSize(): StaffSize | null {
    return this.contents[4];
  }
  setStaffSize(staffSize: StaffSize | null): StaffDetails {
    this.contents[4] = staffSize;
    return this;
  }
}

export type DiatonicAttributes = Record<string, unknown>;

export type DiatonicContents = [number];

export class Diatonic implements XMLElement<'diatonic', DiatonicAttributes, DiatonicContents> {
  static readonly schema = {
    name: 'diatonic',
    attributes: {},
    contents: [
      {
        type: 'label',
        label: 'diatonic',
        value: { type: 'required', value: { type: 'int', min: -Infinity, max: Infinity } },
      },
    ],
  } as const;

  readonly schema = Diatonic.schema;

  attributes: DiatonicAttributes;
  contents: DiatonicContents;

  constructor(opts?: { attributes?: Partial<DiatonicAttributes>; contents?: DiatonicContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Diatonic.schema);
    this.contents = opts?.contents ?? operations.zero(Diatonic.schema.contents);
  }

  getDiatonic(): number {
    return this.contents[0];
  }
  setDiatonic(diatonic: number): Diatonic {
    this.contents[0] = diatonic;
    return this;
  }
}

export type ChromaticAttributes = Record<string, unknown>;

export type ChromaticContents = [number];

export class Chromatic implements XMLElement<'chromatic', ChromaticAttributes, ChromaticContents> {
  static readonly schema = {
    name: 'chromatic',
    attributes: {},
    contents: [
      {
        type: 'required',
        value: { type: 'label', label: 'semitones', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
    ],
  } as const;

  readonly schema = Chromatic.schema;

  attributes: ChromaticAttributes;
  contents: ChromaticContents;

  constructor(opts?: { attributes?: Partial<ChromaticAttributes>; contents?: ChromaticContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Chromatic.schema);
    this.contents = opts?.contents ?? operations.zero(Chromatic.schema.contents);
  }

  getSemitones(): number {
    return this.contents[0];
  }
  setSemitones(semitones: number): Chromatic {
    this.contents[0] = semitones;
    return this;
  }
}

export type OctaveChangeAttributes = Record<string, unknown>;

export type OctaveChangeContents = [number];

export class OctaveChange implements XMLElement<'octave-change', OctaveChangeAttributes, OctaveChangeContents> {
  static readonly schema = {
    name: 'octave-change',
    attributes: {},
    contents: [
      {
        type: 'label',
        label: 'octave-change-value',
        value: { type: 'required', value: { type: 'int', min: -Infinity, max: Infinity } },
      },
    ],
  } as const;

  readonly schema = OctaveChange.schema;

  attributes: OctaveChangeAttributes;
  contents: OctaveChangeContents;

  constructor(opts?: { attributes?: Partial<OctaveChangeAttributes>; contents?: OctaveChangeContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, OctaveChange.schema);
    this.contents = opts?.contents ?? operations.zero(OctaveChange.schema.contents);
  }

  getOctaveChangeValue(): number {
    return this.contents[0];
  }
  setOctaveChangeValue(octaveChangeValue: number): OctaveChange {
    this.contents[0] = octaveChangeValue;
    return this;
  }
}

export type DoubleAttributes = { above: 'yes' | 'no' | null };

export type DoubleContents = [];

export class Double implements XMLElement<'double', DoubleAttributes, DoubleContents> {
  static readonly schema = {
    name: 'double',
    attributes: { above: { type: 'optional', value: { type: 'choices', choices: ['yes', 'no'] } } },
    contents: [],
  } as const;

  readonly schema = Double.schema;

  attributes: DoubleAttributes;
  contents: DoubleContents;

  constructor(opts?: { attributes?: Partial<DoubleAttributes>; contents?: DoubleContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Double.schema);
    this.contents = opts?.contents ?? operations.zero(Double.schema.contents);
  }
  getAbove(): 'yes' | 'no' | null {
    return this.attributes['above'];
  }
  setAbove(above: 'yes' | 'no' | null): Double {
    this.attributes['above'] = above;
    return this;
  }
}

export type TransposeAttributes = { id: string | null; number: number | null };

export type TransposeContents = [Diatonic | null, Chromatic, OctaveChange | null, Double | null];

export class Transpose implements XMLElement<'transpose', TransposeAttributes, TransposeContents> {
  static readonly schema = {
    name: 'transpose',
    attributes: {
      id: { type: 'optional', value: { type: 'regex', pattern: /[A-Za-z_][A-Za-z0-9.-_]*/, zero: '_' } },
      number: { type: 'optional', value: { type: 'int', min: 1, max: Infinity } },
    },
    contents: [
      { type: 'optional', value: Diatonic },
      { type: 'required', value: Chromatic },
      { type: 'optional', value: OctaveChange },
      { type: 'optional', value: Double },
    ],
  } as const;

  readonly schema = Transpose.schema;

  attributes: TransposeAttributes;
  contents: TransposeContents;

  constructor(opts?: { attributes?: Partial<TransposeAttributes>; contents?: TransposeContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Transpose.schema);
    this.contents = opts?.contents ?? operations.zero(Transpose.schema.contents);
  }
  getId(): string | null {
    return this.attributes['id'];
  }
  setId(id: string | null): Transpose {
    this.attributes['id'] = id;
    return this;
  }
  getNumber(): number | null {
    return this.attributes['number'];
  }
  setNumber(number: number | null): Transpose {
    this.attributes['number'] = number;
    return this;
  }
  getDiatonic(): Diatonic | null {
    return this.contents[0];
  }
  setDiatonic(diatonic: Diatonic | null): Transpose {
    this.contents[0] = diatonic;
    return this;
  }
  getChromatic(): Chromatic {
    return this.contents[1];
  }
  setChromatic(chromatic: Chromatic): Transpose {
    this.contents[1] = chromatic;
    return this;
  }
  getOctaveChange(): OctaveChange | null {
    return this.contents[2];
  }
  setOctaveChange(octaveChange: OctaveChange | null): Transpose {
    this.contents[2] = octaveChange;
    return this;
  }
  getDouble(): Double | null {
    return this.contents[3];
  }
  setDouble(double: Double | null): Transpose {
    this.contents[3] = double;
    return this;
  }
}

export type PartClefAttributes = Record<string, unknown>;

export type PartClefContents = [Sign, Line | null, ClefOctaveChange | null];

export class PartClef implements XMLElement<'part-clef', PartClefAttributes, PartClefContents> {
  static readonly schema = {
    name: 'part-clef',
    attributes: {},
    contents: [
      { type: 'required', value: Sign },
      { type: 'optional', value: Line },
      { type: 'optional', value: ClefOctaveChange },
    ],
  } as const;

  readonly schema = PartClef.schema;

  attributes: PartClefAttributes;
  contents: PartClefContents;

  constructor(opts?: { attributes?: Partial<PartClefAttributes>; contents?: PartClefContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, PartClef.schema);
    this.contents = opts?.contents ?? operations.zero(PartClef.schema.contents);
  }

  getSign(): Sign {
    return this.contents[0];
  }
  setSign(sign: Sign): PartClef {
    this.contents[0] = sign;
    return this;
  }
  getLine(): Line | null {
    return this.contents[1];
  }
  setLine(line: Line | null): PartClef {
    this.contents[1] = line;
    return this;
  }
  getClefOctaveChange(): ClefOctaveChange | null {
    return this.contents[2];
  }
  setClefOctaveChange(clefOctaveChange: ClefOctaveChange | null): PartClef {
    this.contents[2] = clefOctaveChange;
    return this;
  }
}

export type PartTransposeAttributes = Record<string, unknown>;

export type PartTransposeContents = [Diatonic | null, Chromatic, OctaveChange | null, Double | null];

export class PartTranspose implements XMLElement<'part-transpose', PartTransposeAttributes, PartTransposeContents> {
  static readonly schema = {
    name: 'part-transpose',
    attributes: {},
    contents: [
      { type: 'optional', value: Diatonic },
      { type: 'required', value: Chromatic },
      { type: 'optional', value: OctaveChange },
      { type: 'optional', value: Double },
    ],
  } as const;

  readonly schema = PartTranspose.schema;

  attributes: PartTransposeAttributes;
  contents: PartTransposeContents;

  constructor(opts?: { attributes?: Partial<PartTransposeAttributes>; contents?: PartTransposeContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, PartTranspose.schema);
    this.contents = opts?.contents ?? operations.zero(PartTranspose.schema.contents);
  }

  getDiatonic(): Diatonic | null {
    return this.contents[0];
  }
  setDiatonic(diatonic: Diatonic | null): PartTranspose {
    this.contents[0] = diatonic;
    return this;
  }
  getChromatic(): Chromatic {
    return this.contents[1];
  }
  setChromatic(chromatic: Chromatic): PartTranspose {
    this.contents[1] = chromatic;
    return this;
  }
  getOctaveChange(): OctaveChange | null {
    return this.contents[2];
  }
  setOctaveChange(octaveChange: OctaveChange | null): PartTranspose {
    this.contents[2] = octaveChange;
    return this;
  }
  getDouble(): Double | null {
    return this.contents[3];
  }
  setDouble(double: Double | null): PartTranspose {
    this.contents[3] = double;
    return this;
  }
}

export type ForPartAttributes = { id: string | null; number: number | null };

export type ForPartContents = [PartClef | null, PartTranspose];

export class ForPart implements XMLElement<'for-part', ForPartAttributes, ForPartContents> {
  static readonly schema = {
    name: 'for-part',
    attributes: {
      id: { type: 'optional', value: { type: 'regex', pattern: /[A-Za-z_][A-Za-z0-9.-_]*/, zero: '_' } },
      number: { type: 'optional', value: { type: 'int', min: 1, max: Infinity } },
    },
    contents: [
      { type: 'optional', value: PartClef },
      { type: 'required', value: PartTranspose },
    ],
  } as const;

  readonly schema = ForPart.schema;

  attributes: ForPartAttributes;
  contents: ForPartContents;

  constructor(opts?: { attributes?: Partial<ForPartAttributes>; contents?: ForPartContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, ForPart.schema);
    this.contents = opts?.contents ?? operations.zero(ForPart.schema.contents);
  }
  getId(): string | null {
    return this.attributes['id'];
  }
  setId(id: string | null): ForPart {
    this.attributes['id'] = id;
    return this;
  }
  getNumber(): number | null {
    return this.attributes['number'];
  }
  setNumber(number: number | null): ForPart {
    this.attributes['number'] = number;
    return this;
  }
  getPartClef(): PartClef | null {
    return this.contents[0];
  }
  setPartClef(partClef: PartClef | null): ForPart {
    this.contents[0] = partClef;
    return this;
  }
  getPartTranspose(): PartTranspose {
    return this.contents[1];
  }
  setPartTranspose(partTranspose: PartTranspose): ForPart {
    this.contents[1] = partTranspose;
    return this;
  }
}

export type DirectiveAttributes = {
  color: string | null;
  'default-x': number | null;
  'default-y': number | null;
  'font-family': string | null;
  'font-size': 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null;
  'font-style': 'normal' | 'italic' | null;
  'font-weight': 'normal' | 'bold' | null;
  'relative-x': number | null;
  'relative-y': number | null;
  'xml:lang': string | null;
};

export type DirectiveContents = [string];

export class Directive implements XMLElement<'directive', DirectiveAttributes, DirectiveContents> {
  static readonly schema = {
    name: 'directive',
    attributes: {
      color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
      'default-x': {
        type: 'label',
        label: 'default-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'default-y': {
        type: 'label',
        label: 'default-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
      'font-size': {
        type: 'optional',
        value: {
          type: 'choices',
          choices: [
            { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
            { type: 'float', min: -Infinity, max: Infinity },
          ],
        },
      },
      'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
      'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
      'relative-x': {
        type: 'label',
        label: 'relative-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'relative-y': {
        type: 'label',
        label: 'relative-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'xml:lang': { type: 'optional', value: { type: 'string' } },
    },
    contents: [{ type: 'required', value: { type: 'string' } }],
  } as const;

  readonly schema = Directive.schema;

  attributes: DirectiveAttributes;
  contents: DirectiveContents;

  constructor(opts?: { attributes?: Partial<DirectiveAttributes>; contents?: DirectiveContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Directive.schema);
    this.contents = opts?.contents ?? operations.zero(Directive.schema.contents);
  }
  getColor(): string | null {
    return this.attributes['color'];
  }
  setColor(color: string | null): Directive {
    this.attributes['color'] = color;
    return this;
  }
  getDefaultX(): number | null {
    return this.attributes['default-x'];
  }
  setDefaultX(defaultX: number | null): Directive {
    this.attributes['default-x'] = defaultX;
    return this;
  }
  getDefaultY(): number | null {
    return this.attributes['default-y'];
  }
  setDefaultY(defaultY: number | null): Directive {
    this.attributes['default-y'] = defaultY;
    return this;
  }
  getFontFamily(): string | null {
    return this.attributes['font-family'];
  }
  setFontFamily(fontFamily: string | null): Directive {
    this.attributes['font-family'] = fontFamily;
    return this;
  }
  getFontSize(): 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null {
    return this.attributes['font-size'];
  }
  setFontSize(
    fontSize: 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null
  ): Directive {
    this.attributes['font-size'] = fontSize;
    return this;
  }
  getFontStyle(): 'normal' | 'italic' | null {
    return this.attributes['font-style'];
  }
  setFontStyle(fontStyle: 'normal' | 'italic' | null): Directive {
    this.attributes['font-style'] = fontStyle;
    return this;
  }
  getFontWeight(): 'normal' | 'bold' | null {
    return this.attributes['font-weight'];
  }
  setFontWeight(fontWeight: 'normal' | 'bold' | null): Directive {
    this.attributes['font-weight'] = fontWeight;
    return this;
  }
  getRelativeX(): number | null {
    return this.attributes['relative-x'];
  }
  setRelativeX(relativeX: number | null): Directive {
    this.attributes['relative-x'] = relativeX;
    return this;
  }
  getRelativeY(): number | null {
    return this.attributes['relative-y'];
  }
  setRelativeY(relativeY: number | null): Directive {
    this.attributes['relative-y'] = relativeY;
    return this;
  }
  getXmlLang(): string | null {
    return this.attributes['xml:lang'];
  }
  setXmlLang(xmlLang: string | null): Directive {
    this.attributes['xml:lang'] = xmlLang;
    return this;
  }
  getText(): string {
    return this.contents[0];
  }
  setText(text: string): Directive {
    this.contents[0] = text;
    return this;
  }
}

export type MultipleRestAttributes = { 'use-symbols': 'yes' | 'no' | null };

export type MultipleRestContents = [number];

export class MultipleRest implements XMLElement<'multiple-rest', MultipleRestAttributes, MultipleRestContents> {
  static readonly schema = {
    name: 'multiple-rest',
    attributes: { 'use-symbols': { type: 'optional', value: { type: 'choices', choices: ['yes', 'no'] } } },
    contents: [
      {
        type: 'label',
        label: 'multiple-rest',
        value: { type: 'required', value: { type: 'int', min: 1, max: Infinity } },
      },
    ],
  } as const;

  readonly schema = MultipleRest.schema;

  attributes: MultipleRestAttributes;
  contents: MultipleRestContents;

  constructor(opts?: { attributes?: Partial<MultipleRestAttributes>; contents?: MultipleRestContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, MultipleRest.schema);
    this.contents = opts?.contents ?? operations.zero(MultipleRest.schema.contents);
  }
  getUseSymbols(): 'yes' | 'no' | null {
    return this.attributes['use-symbols'];
  }
  setUseSymbols(useSymbols: 'yes' | 'no' | null): MultipleRest {
    this.attributes['use-symbols'] = useSymbols;
    return this;
  }
  getMultipleRest(): number {
    return this.contents[0];
  }
  setMultipleRest(multipleRest: number): MultipleRest {
    this.contents[0] = multipleRest;
    return this;
  }
}

export type MeasureRepeatAttributes = { type: 'start' | 'stop'; slashes: number | null };

export type MeasureRepeatContents = ['' | number];

export class MeasureRepeat implements XMLElement<'measure-repeat', MeasureRepeatAttributes, MeasureRepeatContents> {
  static readonly schema = {
    name: 'measure-repeat',
    attributes: {
      type: { type: 'required', value: { type: 'choices', choices: ['start', 'stop'] } },
      slashes: { type: 'optional', value: { type: 'int', min: 1, max: Infinity } },
    },
    contents: [
      {
        type: 'label',
        label: 'measure-repeat-value',
        value: { type: 'required', value: { type: 'choices', choices: ['', { type: 'int', min: 1, max: Infinity }] } },
      },
    ],
  } as const;

  readonly schema = MeasureRepeat.schema;

  attributes: MeasureRepeatAttributes;
  contents: MeasureRepeatContents;

  constructor(opts?: { attributes?: Partial<MeasureRepeatAttributes>; contents?: MeasureRepeatContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, MeasureRepeat.schema);
    this.contents = opts?.contents ?? operations.zero(MeasureRepeat.schema.contents);
  }
  getType(): 'start' | 'stop' {
    return this.attributes['type'];
  }
  setType(type: 'start' | 'stop'): MeasureRepeat {
    this.attributes['type'] = type;
    return this;
  }
  getSlashes(): number | null {
    return this.attributes['slashes'];
  }
  setSlashes(slashes: number | null): MeasureRepeat {
    this.attributes['slashes'] = slashes;
    return this;
  }
  getMeasureRepeatValue(): '' | number {
    return this.contents[0];
  }
  setMeasureRepeatValue(measureRepeatValue: '' | number): MeasureRepeat {
    this.contents[0] = measureRepeatValue;
    return this;
  }
}

export type SlashTypeAttributes = Record<string, unknown>;

export type SlashTypeContents = [
  | 'whole'
  | '1024th'
  | '512th'
  | '256th'
  | '128th'
  | '64th'
  | '32nd'
  | '16th'
  | 'eighth'
  | 'half'
  | 'quarter'
  | 'whole'
  | 'breve'
  | 'long'
  | 'maxima'
];

export class SlashType implements XMLElement<'slash-type', SlashTypeAttributes, SlashTypeContents> {
  static readonly schema = {
    name: 'slash-type',
    attributes: {},
    contents: [
      {
        type: 'required',
        value: {
          type: 'label',
          label: 'note-type-value',
          value: {
            type: 'choices',
            choices: [
              'whole',
              '1024th',
              '512th',
              '256th',
              '128th',
              '64th',
              '32nd',
              '16th',
              'eighth',
              'half',
              'quarter',
              'whole',
              'breve',
              'long',
              'maxima',
            ],
          },
        },
      },
    ],
  } as const;

  readonly schema = SlashType.schema;

  attributes: SlashTypeAttributes;
  contents: SlashTypeContents;

  constructor(opts?: { attributes?: Partial<SlashTypeAttributes>; contents?: SlashTypeContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, SlashType.schema);
    this.contents = opts?.contents ?? operations.zero(SlashType.schema.contents);
  }

  getNoteTypeValue():
    | 'whole'
    | '1024th'
    | '512th'
    | '256th'
    | '128th'
    | '64th'
    | '32nd'
    | '16th'
    | 'eighth'
    | 'half'
    | 'quarter'
    | 'whole'
    | 'breve'
    | 'long'
    | 'maxima' {
    return this.contents[0];
  }
  setNoteTypeValue(
    noteTypeValue:
      | 'whole'
      | '1024th'
      | '512th'
      | '256th'
      | '128th'
      | '64th'
      | '32nd'
      | '16th'
      | 'eighth'
      | 'half'
      | 'quarter'
      | 'whole'
      | 'breve'
      | 'long'
      | 'maxima'
  ): SlashType {
    this.contents[0] = noteTypeValue;
    return this;
  }
}

export type SlashDotAttributes = Record<string, unknown>;

export type SlashDotContents = [];

export class SlashDot implements XMLElement<'slash-dot', SlashDotAttributes, SlashDotContents> {
  static readonly schema = { name: 'slash-dot', attributes: {}, contents: [] } as const;

  readonly schema = SlashDot.schema;

  attributes: SlashDotAttributes;
  contents: SlashDotContents;

  constructor(opts?: { attributes?: Partial<SlashDotAttributes>; contents?: SlashDotContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, SlashDot.schema);
    this.contents = opts?.contents ?? operations.zero(SlashDot.schema.contents);
  }
}

export type ExceptVoiceAttributes = Record<string, unknown>;

export type ExceptVoiceContents = [string];

export class ExceptVoice implements XMLElement<'except-voice', ExceptVoiceAttributes, ExceptVoiceContents> {
  static readonly schema = {
    name: 'except-voice',
    attributes: {},
    contents: [{ type: 'required', value: { type: 'string' } }],
  } as const;

  readonly schema = ExceptVoice.schema;

  attributes: ExceptVoiceAttributes;
  contents: ExceptVoiceContents;

  constructor(opts?: { attributes?: Partial<ExceptVoiceAttributes>; contents?: ExceptVoiceContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, ExceptVoice.schema);
    this.contents = opts?.contents ?? operations.zero(ExceptVoice.schema.contents);
  }

  getText(): string {
    return this.contents[0];
  }
  setText(text: string): ExceptVoice {
    this.contents[0] = text;
    return this;
  }
}

export type BeatRepeatAttributes = { type: 'start' | 'stop'; slashes: number | null; 'use-dots': 'yes' | 'no' | null };

export type BeatRepeatContents = [[[SlashType, Array<SlashDot>] | null, Array<ExceptVoice>] | null];

export class BeatRepeat implements XMLElement<'beat-repeat', BeatRepeatAttributes, BeatRepeatContents> {
  static readonly schema = {
    name: 'beat-repeat',
    attributes: {
      type: { type: 'required', value: { type: 'choices', choices: ['start', 'stop'] } },
      slashes: { type: 'optional', value: { type: 'int', min: 1, max: Infinity } },
      'use-dots': { type: 'optional', value: { type: 'choices', choices: ['yes', 'no'] } },
    },
    contents: [
      {
        type: 'label',
        label: 'beat-repeat',
        value: {
          type: 'optional',
          value: [
            {
              type: 'optional',
              value: [
                { type: 'required', value: SlashType },
                { type: 'zeroOrMore', value: SlashDot },
              ],
            },
            { type: 'zeroOrMore', value: ExceptVoice },
          ],
        },
      },
    ],
  } as const;

  readonly schema = BeatRepeat.schema;

  attributes: BeatRepeatAttributes;
  contents: BeatRepeatContents;

  constructor(opts?: { attributes?: Partial<BeatRepeatAttributes>; contents?: BeatRepeatContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, BeatRepeat.schema);
    this.contents = opts?.contents ?? operations.zero(BeatRepeat.schema.contents);
  }
  getType(): 'start' | 'stop' {
    return this.attributes['type'];
  }
  setType(type: 'start' | 'stop'): BeatRepeat {
    this.attributes['type'] = type;
    return this;
  }
  getSlashes(): number | null {
    return this.attributes['slashes'];
  }
  setSlashes(slashes: number | null): BeatRepeat {
    this.attributes['slashes'] = slashes;
    return this;
  }
  getUseDots(): 'yes' | 'no' | null {
    return this.attributes['use-dots'];
  }
  setUseDots(useDots: 'yes' | 'no' | null): BeatRepeat {
    this.attributes['use-dots'] = useDots;
    return this;
  }
  getBeatRepeat(): [[SlashType, Array<SlashDot>] | null, Array<ExceptVoice>] | null {
    return this.contents[0];
  }
  setBeatRepeat(beatRepeat: [[SlashType, Array<SlashDot>] | null, Array<ExceptVoice>] | null): BeatRepeat {
    this.contents[0] = beatRepeat;
    return this;
  }
}

export type SlashAttributes = {
  type: 'start' | 'stop';
  'use-dots': 'yes' | 'no' | null;
  'use-stems': 'yes' | 'no' | null;
};

export type SlashContents = [[[SlashType, Array<SlashDot>] | null, Array<ExceptVoice>] | null];

export class Slash implements XMLElement<'slash', SlashAttributes, SlashContents> {
  static readonly schema = {
    name: 'slash',
    attributes: {
      type: { type: 'required', value: { type: 'choices', choices: ['start', 'stop'] } },
      'use-dots': { type: 'optional', value: { type: 'choices', choices: ['yes', 'no'] } },
      'use-stems': { type: 'optional', value: { type: 'choices', choices: ['yes', 'no'] } },
    },
    contents: [
      {
        type: 'label',
        label: 'slash-value',
        value: {
          type: 'optional',
          value: [
            {
              type: 'optional',
              value: [
                { type: 'required', value: SlashType },
                { type: 'zeroOrMore', value: SlashDot },
              ],
            },
            { type: 'zeroOrMore', value: ExceptVoice },
          ],
        },
      },
    ],
  } as const;

  readonly schema = Slash.schema;

  attributes: SlashAttributes;
  contents: SlashContents;

  constructor(opts?: { attributes?: Partial<SlashAttributes>; contents?: SlashContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Slash.schema);
    this.contents = opts?.contents ?? operations.zero(Slash.schema.contents);
  }
  getType(): 'start' | 'stop' {
    return this.attributes['type'];
  }
  setType(type: 'start' | 'stop'): Slash {
    this.attributes['type'] = type;
    return this;
  }
  getUseDots(): 'yes' | 'no' | null {
    return this.attributes['use-dots'];
  }
  setUseDots(useDots: 'yes' | 'no' | null): Slash {
    this.attributes['use-dots'] = useDots;
    return this;
  }
  getUseStems(): 'yes' | 'no' | null {
    return this.attributes['use-stems'];
  }
  setUseStems(useStems: 'yes' | 'no' | null): Slash {
    this.attributes['use-stems'] = useStems;
    return this;
  }
  getSlashValue(): [[SlashType, Array<SlashDot>] | null, Array<ExceptVoice>] | null {
    return this.contents[0];
  }
  setSlashValue(slashValue: [[SlashType, Array<SlashDot>] | null, Array<ExceptVoice>] | null): Slash {
    this.contents[0] = slashValue;
    return this;
  }
}

export type MeasureStyleAttributes = {
  color: string | null;
  'font-family': string | null;
  'font-size': 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null;
  'font-style': 'normal' | 'italic' | null;
  'font-weight': 'normal' | 'bold' | null;
  id: string | null;
  number: number | null;
};

export type MeasureStyleContents = [MultipleRest | MeasureRepeat | BeatRepeat | Slash];

export class MeasureStyle implements XMLElement<'measure-style', MeasureStyleAttributes, MeasureStyleContents> {
  static readonly schema = {
    name: 'measure-style',
    attributes: {
      color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
      'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
      'font-size': {
        type: 'optional',
        value: {
          type: 'choices',
          choices: [
            { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
            { type: 'float', min: -Infinity, max: Infinity },
          ],
        },
      },
      'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
      'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
      id: { type: 'optional', value: { type: 'regex', pattern: /[A-Za-z_][A-Za-z0-9.-_]*/, zero: '_' } },
      number: { type: 'optional', value: { type: 'int', min: 1, max: Infinity } },
    },
    contents: [
      {
        type: 'label',
        label: 'measure-style-value',
        value: { type: 'choices', choices: [MultipleRest, MeasureRepeat, BeatRepeat, Slash] },
      },
    ],
  } as const;

  readonly schema = MeasureStyle.schema;

  attributes: MeasureStyleAttributes;
  contents: MeasureStyleContents;

  constructor(opts?: { attributes?: Partial<MeasureStyleAttributes>; contents?: MeasureStyleContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, MeasureStyle.schema);
    this.contents = opts?.contents ?? operations.zero(MeasureStyle.schema.contents);
  }
  getColor(): string | null {
    return this.attributes['color'];
  }
  setColor(color: string | null): MeasureStyle {
    this.attributes['color'] = color;
    return this;
  }
  getFontFamily(): string | null {
    return this.attributes['font-family'];
  }
  setFontFamily(fontFamily: string | null): MeasureStyle {
    this.attributes['font-family'] = fontFamily;
    return this;
  }
  getFontSize(): 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null {
    return this.attributes['font-size'];
  }
  setFontSize(
    fontSize: 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null
  ): MeasureStyle {
    this.attributes['font-size'] = fontSize;
    return this;
  }
  getFontStyle(): 'normal' | 'italic' | null {
    return this.attributes['font-style'];
  }
  setFontStyle(fontStyle: 'normal' | 'italic' | null): MeasureStyle {
    this.attributes['font-style'] = fontStyle;
    return this;
  }
  getFontWeight(): 'normal' | 'bold' | null {
    return this.attributes['font-weight'];
  }
  setFontWeight(fontWeight: 'normal' | 'bold' | null): MeasureStyle {
    this.attributes['font-weight'] = fontWeight;
    return this;
  }
  getId(): string | null {
    return this.attributes['id'];
  }
  setId(id: string | null): MeasureStyle {
    this.attributes['id'] = id;
    return this;
  }
  getNumber(): number | null {
    return this.attributes['number'];
  }
  setNumber(number: number | null): MeasureStyle {
    this.attributes['number'] = number;
    return this;
  }
  getMeasureStyleValue(): MultipleRest | MeasureRepeat | BeatRepeat | Slash {
    return this.contents[0];
  }
  setMeasureStyleValue(measureStyleValue: MultipleRest | MeasureRepeat | BeatRepeat | Slash): MeasureStyle {
    this.contents[0] = measureStyleValue;
    return this;
  }
}

export type Transposes = Array<Transpose>;

export type ForParts = Array<ForPart>;

export type AttributesAttributes = Record<string, unknown>;

export type AttributesContents = [
  Footnote | null,
  Level | null,
  Divisions | null,
  Array<Key>,
  Array<Time>,
  Staves | null,
  PartSymbol | null,
  Instruments | null,
  Array<Clef>,
  Array<StaffDetails>,
  Transposes | ForParts,
  Array<Directive>,
  Array<MeasureStyle>
];

export class Attributes implements XMLElement<'attributes', AttributesAttributes, AttributesContents> {
  static readonly schema = {
    name: 'attributes',
    attributes: {},
    contents: [
      { type: 'optional', value: Footnote },
      { type: 'optional', value: Level },
      { type: 'optional', value: Divisions },
      { type: 'label', label: 'keys', value: { type: 'zeroOrMore', value: Key } },
      { type: 'label', label: 'times', value: { type: 'zeroOrMore', value: Time } },
      { type: 'optional', value: Staves },
      { type: 'optional', value: PartSymbol },
      { type: 'optional', value: Instruments },
      { type: 'label', label: 'clefs', value: { type: 'zeroOrMore', value: Clef } },
      { type: 'label', label: 'staff-details', value: { type: 'zeroOrMore', value: StaffDetails } },
      {
        type: 'label',
        label: 'transpositions',
        value: {
          type: 'choices',
          choices: [
            { type: 'label', label: 'transposes', value: { type: 'zeroOrMore', value: Transpose } },
            { type: 'label', label: 'for-parts', value: { type: 'zeroOrMore', value: ForPart } },
          ],
        },
      },
      { type: 'label', label: 'directives', value: { type: 'zeroOrMore', value: Directive } },
      { type: 'label', label: 'measure-styles', value: { type: 'zeroOrMore', value: MeasureStyle } },
    ],
  } as const;

  readonly schema = Attributes.schema;

  attributes: AttributesAttributes;
  contents: AttributesContents;

  constructor(opts?: { attributes?: Partial<AttributesAttributes>; contents?: AttributesContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Attributes.schema);
    this.contents = opts?.contents ?? operations.zero(Attributes.schema.contents);
  }

  getFootnote(): Footnote | null {
    return this.contents[0];
  }
  setFootnote(footnote: Footnote | null): Attributes {
    this.contents[0] = footnote;
    return this;
  }
  getLevel(): Level | null {
    return this.contents[1];
  }
  setLevel(level: Level | null): Attributes {
    this.contents[1] = level;
    return this;
  }
  getDivisions(): Divisions | null {
    return this.contents[2];
  }
  setDivisions(divisions: Divisions | null): Attributes {
    this.contents[2] = divisions;
    return this;
  }
  getKeys(): Array<Key> {
    return this.contents[3];
  }
  setKeys(keys: Array<Key>): Attributes {
    this.contents[3] = keys;
    return this;
  }
  getTimes(): Array<Time> {
    return this.contents[4];
  }
  setTimes(times: Array<Time>): Attributes {
    this.contents[4] = times;
    return this;
  }
  getStaves(): Staves | null {
    return this.contents[5];
  }
  setStaves(staves: Staves | null): Attributes {
    this.contents[5] = staves;
    return this;
  }
  getPartSymbol(): PartSymbol | null {
    return this.contents[6];
  }
  setPartSymbol(partSymbol: PartSymbol | null): Attributes {
    this.contents[6] = partSymbol;
    return this;
  }
  getInstruments(): Instruments | null {
    return this.contents[7];
  }
  setInstruments(instruments: Instruments | null): Attributes {
    this.contents[7] = instruments;
    return this;
  }
  getClefs(): Array<Clef> {
    return this.contents[8];
  }
  setClefs(clefs: Array<Clef>): Attributes {
    this.contents[8] = clefs;
    return this;
  }
  getStaffDetails(): Array<StaffDetails> {
    return this.contents[9];
  }
  setStaffDetails(staffDetails: Array<StaffDetails>): Attributes {
    this.contents[9] = staffDetails;
    return this;
  }
  getTranspositions(): Transposes | ForParts {
    return this.contents[10];
  }
  setTranspositions(transpositions: Transposes | ForParts): Attributes {
    this.contents[10] = transpositions;
    return this;
  }
  getDirectives(): Array<Directive> {
    return this.contents[11];
  }
  setDirectives(directives: Array<Directive>): Attributes {
    this.contents[11] = directives;
    return this;
  }
  getMeasureStyles(): Array<MeasureStyle> {
    return this.contents[12];
  }
  setMeasureStyles(measureStyles: Array<MeasureStyle>): Attributes {
    this.contents[12] = measureStyles;
    return this;
  }
}

export type RootStepAttributes = {
  color: string | null;
  'default-x': number | null;
  'default-y': number | null;
  'font-family': string | null;
  'font-size': 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null;
  'font-style': 'normal' | 'italic' | null;
  'font-weight': 'normal' | 'bold' | null;
  'relative-x': number | null;
  'relative-y': number | null;
  text: string | null;
};

export type RootStepContents = ['A' | 'B' | 'C' | 'D' | 'E' | 'F' | 'G'];

export class RootStep implements XMLElement<'root-step', RootStepAttributes, RootStepContents> {
  static readonly schema = {
    name: 'root-step',
    attributes: {
      color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
      'default-x': {
        type: 'label',
        label: 'default-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'default-y': {
        type: 'label',
        label: 'default-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
      'font-size': {
        type: 'optional',
        value: {
          type: 'choices',
          choices: [
            { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
            { type: 'float', min: -Infinity, max: Infinity },
          ],
        },
      },
      'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
      'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
      'relative-x': {
        type: 'label',
        label: 'relative-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'relative-y': {
        type: 'label',
        label: 'relative-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      text: { type: 'optional', value: { type: 'string' } },
    },
    contents: [
      { type: 'label', label: 'step', value: { type: 'choices', choices: ['A', 'B', 'C', 'D', 'E', 'F', 'G'] } },
    ],
  } as const;

  readonly schema = RootStep.schema;

  attributes: RootStepAttributes;
  contents: RootStepContents;

  constructor(opts?: { attributes?: Partial<RootStepAttributes>; contents?: RootStepContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, RootStep.schema);
    this.contents = opts?.contents ?? operations.zero(RootStep.schema.contents);
  }
  getColor(): string | null {
    return this.attributes['color'];
  }
  setColor(color: string | null): RootStep {
    this.attributes['color'] = color;
    return this;
  }
  getDefaultX(): number | null {
    return this.attributes['default-x'];
  }
  setDefaultX(defaultX: number | null): RootStep {
    this.attributes['default-x'] = defaultX;
    return this;
  }
  getDefaultY(): number | null {
    return this.attributes['default-y'];
  }
  setDefaultY(defaultY: number | null): RootStep {
    this.attributes['default-y'] = defaultY;
    return this;
  }
  getFontFamily(): string | null {
    return this.attributes['font-family'];
  }
  setFontFamily(fontFamily: string | null): RootStep {
    this.attributes['font-family'] = fontFamily;
    return this;
  }
  getFontSize(): 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null {
    return this.attributes['font-size'];
  }
  setFontSize(
    fontSize: 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null
  ): RootStep {
    this.attributes['font-size'] = fontSize;
    return this;
  }
  getFontStyle(): 'normal' | 'italic' | null {
    return this.attributes['font-style'];
  }
  setFontStyle(fontStyle: 'normal' | 'italic' | null): RootStep {
    this.attributes['font-style'] = fontStyle;
    return this;
  }
  getFontWeight(): 'normal' | 'bold' | null {
    return this.attributes['font-weight'];
  }
  setFontWeight(fontWeight: 'normal' | 'bold' | null): RootStep {
    this.attributes['font-weight'] = fontWeight;
    return this;
  }
  getRelativeX(): number | null {
    return this.attributes['relative-x'];
  }
  setRelativeX(relativeX: number | null): RootStep {
    this.attributes['relative-x'] = relativeX;
    return this;
  }
  getRelativeY(): number | null {
    return this.attributes['relative-y'];
  }
  setRelativeY(relativeY: number | null): RootStep {
    this.attributes['relative-y'] = relativeY;
    return this;
  }
  getText(): string | null {
    return this.attributes['text'];
  }
  setText(text: string | null): RootStep {
    this.attributes['text'] = text;
    return this;
  }
  getStep(): 'A' | 'B' | 'C' | 'D' | 'E' | 'F' | 'G' {
    return this.contents[0];
  }
  setStep(step: 'A' | 'B' | 'C' | 'D' | 'E' | 'F' | 'G'): RootStep {
    this.contents[0] = step;
    return this;
  }
}

export type RootAlterAttributes = {
  color: string | null;
  'default-x': number | null;
  'default-y': number | null;
  'font-family': string | null;
  'font-size': 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null;
  'font-style': 'normal' | 'italic' | null;
  'font-weight': 'normal' | 'bold' | null;
  location: 'left' | 'right' | null;
  'print-object': 'yes' | 'no' | null;
  'relative-x': number | null;
  'relative-y': number | null;
};

export type RootAlterContents = [number];

export class RootAlter implements XMLElement<'root-alter', RootAlterAttributes, RootAlterContents> {
  static readonly schema = {
    name: 'root-alter',
    attributes: {
      color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
      'default-x': {
        type: 'label',
        label: 'default-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'default-y': {
        type: 'label',
        label: 'default-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
      'font-size': {
        type: 'optional',
        value: {
          type: 'choices',
          choices: [
            { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
            { type: 'float', min: -Infinity, max: Infinity },
          ],
        },
      },
      'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
      'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
      location: { type: 'optional', value: { type: 'choices', choices: ['left', 'right'] } },
      'print-object': { type: 'optional', value: { type: 'choices', choices: ['yes', 'no'] } },
      'relative-x': {
        type: 'label',
        label: 'relative-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'relative-y': {
        type: 'label',
        label: 'relative-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
    },
    contents: [
      {
        type: 'required',
        value: { type: 'label', label: 'semitones', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
    ],
  } as const;

  readonly schema = RootAlter.schema;

  attributes: RootAlterAttributes;
  contents: RootAlterContents;

  constructor(opts?: { attributes?: Partial<RootAlterAttributes>; contents?: RootAlterContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, RootAlter.schema);
    this.contents = opts?.contents ?? operations.zero(RootAlter.schema.contents);
  }
  getColor(): string | null {
    return this.attributes['color'];
  }
  setColor(color: string | null): RootAlter {
    this.attributes['color'] = color;
    return this;
  }
  getDefaultX(): number | null {
    return this.attributes['default-x'];
  }
  setDefaultX(defaultX: number | null): RootAlter {
    this.attributes['default-x'] = defaultX;
    return this;
  }
  getDefaultY(): number | null {
    return this.attributes['default-y'];
  }
  setDefaultY(defaultY: number | null): RootAlter {
    this.attributes['default-y'] = defaultY;
    return this;
  }
  getFontFamily(): string | null {
    return this.attributes['font-family'];
  }
  setFontFamily(fontFamily: string | null): RootAlter {
    this.attributes['font-family'] = fontFamily;
    return this;
  }
  getFontSize(): 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null {
    return this.attributes['font-size'];
  }
  setFontSize(
    fontSize: 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null
  ): RootAlter {
    this.attributes['font-size'] = fontSize;
    return this;
  }
  getFontStyle(): 'normal' | 'italic' | null {
    return this.attributes['font-style'];
  }
  setFontStyle(fontStyle: 'normal' | 'italic' | null): RootAlter {
    this.attributes['font-style'] = fontStyle;
    return this;
  }
  getFontWeight(): 'normal' | 'bold' | null {
    return this.attributes['font-weight'];
  }
  setFontWeight(fontWeight: 'normal' | 'bold' | null): RootAlter {
    this.attributes['font-weight'] = fontWeight;
    return this;
  }
  getLocation(): 'left' | 'right' | null {
    return this.attributes['location'];
  }
  setLocation(location: 'left' | 'right' | null): RootAlter {
    this.attributes['location'] = location;
    return this;
  }
  getPrintObject(): 'yes' | 'no' | null {
    return this.attributes['print-object'];
  }
  setPrintObject(printObject: 'yes' | 'no' | null): RootAlter {
    this.attributes['print-object'] = printObject;
    return this;
  }
  getRelativeX(): number | null {
    return this.attributes['relative-x'];
  }
  setRelativeX(relativeX: number | null): RootAlter {
    this.attributes['relative-x'] = relativeX;
    return this;
  }
  getRelativeY(): number | null {
    return this.attributes['relative-y'];
  }
  setRelativeY(relativeY: number | null): RootAlter {
    this.attributes['relative-y'] = relativeY;
    return this;
  }
  getSemitones(): number {
    return this.contents[0];
  }
  setSemitones(semitones: number): RootAlter {
    this.contents[0] = semitones;
    return this;
  }
}

export type RootAttributes = Record<string, unknown>;

export type RootContents = [RootStep, RootAlter | null];

export class Root implements XMLElement<'root', RootAttributes, RootContents> {
  static readonly schema = {
    name: 'root',
    attributes: {},
    contents: [
      { type: 'required', value: RootStep },
      { type: 'optional', value: RootAlter },
    ],
  } as const;

  readonly schema = Root.schema;

  attributes: RootAttributes;
  contents: RootContents;

  constructor(opts?: { attributes?: Partial<RootAttributes>; contents?: RootContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Root.schema);
    this.contents = opts?.contents ?? operations.zero(Root.schema.contents);
  }

  getRootStep(): RootStep {
    return this.contents[0];
  }
  setRootStep(rootStep: RootStep): Root {
    this.contents[0] = rootStep;
    return this;
  }
  getRootAlter(): RootAlter | null {
    return this.contents[1];
  }
  setRootAlter(rootAlter: RootAlter | null): Root {
    this.contents[1] = rootAlter;
    return this;
  }
}

export type NumeralRootAttributes = {
  color: string | null;
  'default-x': number | null;
  'default-y': number | null;
  'font-family': string | null;
  'font-size': 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null;
  'font-style': 'normal' | 'italic' | null;
  'font-weight': 'normal' | 'bold' | null;
  'relative-x': number | null;
  'relative-y': number | null;
  text: string | null;
};

export type NumeralRootContents = [number];

export class NumeralRoot implements XMLElement<'numeral-root', NumeralRootAttributes, NumeralRootContents> {
  static readonly schema = {
    name: 'numeral-root',
    attributes: {
      color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
      'default-x': {
        type: 'label',
        label: 'default-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'default-y': {
        type: 'label',
        label: 'default-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
      'font-size': {
        type: 'optional',
        value: {
          type: 'choices',
          choices: [
            { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
            { type: 'float', min: -Infinity, max: Infinity },
          ],
        },
      },
      'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
      'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
      'relative-x': {
        type: 'label',
        label: 'relative-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'relative-y': {
        type: 'label',
        label: 'relative-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      text: { type: 'optional', value: { type: 'string' } },
    },
    contents: [
      { type: 'required', value: { type: 'label', label: 'numeral-value', value: { type: 'int', min: 1, max: 7 } } },
    ],
  } as const;

  readonly schema = NumeralRoot.schema;

  attributes: NumeralRootAttributes;
  contents: NumeralRootContents;

  constructor(opts?: { attributes?: Partial<NumeralRootAttributes>; contents?: NumeralRootContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, NumeralRoot.schema);
    this.contents = opts?.contents ?? operations.zero(NumeralRoot.schema.contents);
  }
  getColor(): string | null {
    return this.attributes['color'];
  }
  setColor(color: string | null): NumeralRoot {
    this.attributes['color'] = color;
    return this;
  }
  getDefaultX(): number | null {
    return this.attributes['default-x'];
  }
  setDefaultX(defaultX: number | null): NumeralRoot {
    this.attributes['default-x'] = defaultX;
    return this;
  }
  getDefaultY(): number | null {
    return this.attributes['default-y'];
  }
  setDefaultY(defaultY: number | null): NumeralRoot {
    this.attributes['default-y'] = defaultY;
    return this;
  }
  getFontFamily(): string | null {
    return this.attributes['font-family'];
  }
  setFontFamily(fontFamily: string | null): NumeralRoot {
    this.attributes['font-family'] = fontFamily;
    return this;
  }
  getFontSize(): 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null {
    return this.attributes['font-size'];
  }
  setFontSize(
    fontSize: 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null
  ): NumeralRoot {
    this.attributes['font-size'] = fontSize;
    return this;
  }
  getFontStyle(): 'normal' | 'italic' | null {
    return this.attributes['font-style'];
  }
  setFontStyle(fontStyle: 'normal' | 'italic' | null): NumeralRoot {
    this.attributes['font-style'] = fontStyle;
    return this;
  }
  getFontWeight(): 'normal' | 'bold' | null {
    return this.attributes['font-weight'];
  }
  setFontWeight(fontWeight: 'normal' | 'bold' | null): NumeralRoot {
    this.attributes['font-weight'] = fontWeight;
    return this;
  }
  getRelativeX(): number | null {
    return this.attributes['relative-x'];
  }
  setRelativeX(relativeX: number | null): NumeralRoot {
    this.attributes['relative-x'] = relativeX;
    return this;
  }
  getRelativeY(): number | null {
    return this.attributes['relative-y'];
  }
  setRelativeY(relativeY: number | null): NumeralRoot {
    this.attributes['relative-y'] = relativeY;
    return this;
  }
  getText(): string | null {
    return this.attributes['text'];
  }
  setText(text: string | null): NumeralRoot {
    this.attributes['text'] = text;
    return this;
  }
  getNumeralValue(): number {
    return this.contents[0];
  }
  setNumeralValue(numeralValue: number): NumeralRoot {
    this.contents[0] = numeralValue;
    return this;
  }
}

export type NumeralAlterAttributes = {
  color: string | null;
  'default-x': number | null;
  'default-y': number | null;
  'font-family': string | null;
  'font-size': 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null;
  'font-style': 'normal' | 'italic' | null;
  'font-weight': 'normal' | 'bold' | null;
  location: 'left' | 'right' | null;
  'print-object': 'yes' | 'no' | null;
  'relative-x': number | null;
  'relative-y': number | null;
  text: string | null;
};

export type NumeralAlterContents = [number];

export class NumeralAlter implements XMLElement<'numeral-alter', NumeralAlterAttributes, NumeralAlterContents> {
  static readonly schema = {
    name: 'numeral-alter',
    attributes: {
      color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
      'default-x': {
        type: 'label',
        label: 'default-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'default-y': {
        type: 'label',
        label: 'default-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
      'font-size': {
        type: 'optional',
        value: {
          type: 'choices',
          choices: [
            { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
            { type: 'float', min: -Infinity, max: Infinity },
          ],
        },
      },
      'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
      'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
      location: { type: 'optional', value: { type: 'choices', choices: ['left', 'right'] } },
      'print-object': { type: 'optional', value: { type: 'choices', choices: ['yes', 'no'] } },
      'relative-x': {
        type: 'label',
        label: 'relative-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'relative-y': {
        type: 'label',
        label: 'relative-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      text: { type: 'optional', value: { type: 'string' } },
    },
    contents: [
      {
        type: 'required',
        value: { type: 'label', label: 'semitones', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
    ],
  } as const;

  readonly schema = NumeralAlter.schema;

  attributes: NumeralAlterAttributes;
  contents: NumeralAlterContents;

  constructor(opts?: { attributes?: Partial<NumeralAlterAttributes>; contents?: NumeralAlterContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, NumeralAlter.schema);
    this.contents = opts?.contents ?? operations.zero(NumeralAlter.schema.contents);
  }
  getColor(): string | null {
    return this.attributes['color'];
  }
  setColor(color: string | null): NumeralAlter {
    this.attributes['color'] = color;
    return this;
  }
  getDefaultX(): number | null {
    return this.attributes['default-x'];
  }
  setDefaultX(defaultX: number | null): NumeralAlter {
    this.attributes['default-x'] = defaultX;
    return this;
  }
  getDefaultY(): number | null {
    return this.attributes['default-y'];
  }
  setDefaultY(defaultY: number | null): NumeralAlter {
    this.attributes['default-y'] = defaultY;
    return this;
  }
  getFontFamily(): string | null {
    return this.attributes['font-family'];
  }
  setFontFamily(fontFamily: string | null): NumeralAlter {
    this.attributes['font-family'] = fontFamily;
    return this;
  }
  getFontSize(): 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null {
    return this.attributes['font-size'];
  }
  setFontSize(
    fontSize: 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null
  ): NumeralAlter {
    this.attributes['font-size'] = fontSize;
    return this;
  }
  getFontStyle(): 'normal' | 'italic' | null {
    return this.attributes['font-style'];
  }
  setFontStyle(fontStyle: 'normal' | 'italic' | null): NumeralAlter {
    this.attributes['font-style'] = fontStyle;
    return this;
  }
  getFontWeight(): 'normal' | 'bold' | null {
    return this.attributes['font-weight'];
  }
  setFontWeight(fontWeight: 'normal' | 'bold' | null): NumeralAlter {
    this.attributes['font-weight'] = fontWeight;
    return this;
  }
  getLocation(): 'left' | 'right' | null {
    return this.attributes['location'];
  }
  setLocation(location: 'left' | 'right' | null): NumeralAlter {
    this.attributes['location'] = location;
    return this;
  }
  getPrintObject(): 'yes' | 'no' | null {
    return this.attributes['print-object'];
  }
  setPrintObject(printObject: 'yes' | 'no' | null): NumeralAlter {
    this.attributes['print-object'] = printObject;
    return this;
  }
  getRelativeX(): number | null {
    return this.attributes['relative-x'];
  }
  setRelativeX(relativeX: number | null): NumeralAlter {
    this.attributes['relative-x'] = relativeX;
    return this;
  }
  getRelativeY(): number | null {
    return this.attributes['relative-y'];
  }
  setRelativeY(relativeY: number | null): NumeralAlter {
    this.attributes['relative-y'] = relativeY;
    return this;
  }
  getText(): string | null {
    return this.attributes['text'];
  }
  setText(text: string | null): NumeralAlter {
    this.attributes['text'] = text;
    return this;
  }
  getSemitones(): number {
    return this.contents[0];
  }
  setSemitones(semitones: number): NumeralAlter {
    this.contents[0] = semitones;
    return this;
  }
}

export type NumeralFifthsAttributes = Record<string, unknown>;

export type NumeralFifthsContents = [number];

export class NumeralFifths implements XMLElement<'numeral-fifths', NumeralFifthsAttributes, NumeralFifthsContents> {
  static readonly schema = {
    name: 'numeral-fifths',
    attributes: {},
    contents: [
      {
        type: 'label',
        label: 'numeral-fifths-value',
        value: { type: 'required', value: { type: 'int', min: -Infinity, max: Infinity } },
      },
    ],
  } as const;

  readonly schema = NumeralFifths.schema;

  attributes: NumeralFifthsAttributes;
  contents: NumeralFifthsContents;

  constructor(opts?: { attributes?: Partial<NumeralFifthsAttributes>; contents?: NumeralFifthsContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, NumeralFifths.schema);
    this.contents = opts?.contents ?? operations.zero(NumeralFifths.schema.contents);
  }

  getNumeralFifthsValue(): number {
    return this.contents[0];
  }
  setNumeralFifthsValue(numeralFifthsValue: number): NumeralFifths {
    this.contents[0] = numeralFifthsValue;
    return this;
  }
}

export type NumeralModeAttributes = Record<string, unknown>;

export type NumeralModeContents = ['major' | 'harmonic minor' | 'melodic minor' | 'minor' | 'natural minor'];

export class NumeralMode implements XMLElement<'numeral-mode', NumeralModeAttributes, NumeralModeContents> {
  static readonly schema = {
    name: 'numeral-mode',
    attributes: {},
    contents: [
      {
        type: 'required',
        value: {
          type: 'label',
          label: 'numeral-mode',
          value: { type: 'choices', choices: ['major', 'harmonic minor', 'melodic minor', 'minor', 'natural minor'] },
        },
      },
    ],
  } as const;

  readonly schema = NumeralMode.schema;

  attributes: NumeralModeAttributes;
  contents: NumeralModeContents;

  constructor(opts?: { attributes?: Partial<NumeralModeAttributes>; contents?: NumeralModeContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, NumeralMode.schema);
    this.contents = opts?.contents ?? operations.zero(NumeralMode.schema.contents);
  }

  getNumeralMode(): 'major' | 'harmonic minor' | 'melodic minor' | 'minor' | 'natural minor' {
    return this.contents[0];
  }
  setNumeralMode(numeralMode: 'major' | 'harmonic minor' | 'melodic minor' | 'minor' | 'natural minor'): NumeralMode {
    this.contents[0] = numeralMode;
    return this;
  }
}

export type NumeralKeyAttributes = { 'print-object': 'yes' | 'no' | null };

export type NumeralKeyContents = [NumeralFifths, NumeralMode];

export class NumeralKey implements XMLElement<'numeral-key', NumeralKeyAttributes, NumeralKeyContents> {
  static readonly schema = {
    name: 'numeral-key',
    attributes: { 'print-object': { type: 'optional', value: { type: 'choices', choices: ['yes', 'no'] } } },
    contents: [
      { type: 'required', value: NumeralFifths },
      { type: 'required', value: NumeralMode },
    ],
  } as const;

  readonly schema = NumeralKey.schema;

  attributes: NumeralKeyAttributes;
  contents: NumeralKeyContents;

  constructor(opts?: { attributes?: Partial<NumeralKeyAttributes>; contents?: NumeralKeyContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, NumeralKey.schema);
    this.contents = opts?.contents ?? operations.zero(NumeralKey.schema.contents);
  }
  getPrintObject(): 'yes' | 'no' | null {
    return this.attributes['print-object'];
  }
  setPrintObject(printObject: 'yes' | 'no' | null): NumeralKey {
    this.attributes['print-object'] = printObject;
    return this;
  }
  getNumeralFifths(): NumeralFifths {
    return this.contents[0];
  }
  setNumeralFifths(numeralFifths: NumeralFifths): NumeralKey {
    this.contents[0] = numeralFifths;
    return this;
  }
  getNumeralMode(): NumeralMode {
    return this.contents[1];
  }
  setNumeralMode(numeralMode: NumeralMode): NumeralKey {
    this.contents[1] = numeralMode;
    return this;
  }
}

export type NumeralAttributes = Record<string, unknown>;

export type NumeralContents = [NumeralRoot, NumeralAlter | null, NumeralKey | null];

export class Numeral implements XMLElement<'numeral', NumeralAttributes, NumeralContents> {
  static readonly schema = {
    name: 'numeral',
    attributes: {},
    contents: [
      { type: 'required', value: NumeralRoot },
      { type: 'optional', value: NumeralAlter },
      { type: 'optional', value: NumeralKey },
    ],
  } as const;

  readonly schema = Numeral.schema;

  attributes: NumeralAttributes;
  contents: NumeralContents;

  constructor(opts?: { attributes?: Partial<NumeralAttributes>; contents?: NumeralContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Numeral.schema);
    this.contents = opts?.contents ?? operations.zero(Numeral.schema.contents);
  }

  getNumeralRoot(): NumeralRoot {
    return this.contents[0];
  }
  setNumeralRoot(numeralRoot: NumeralRoot): Numeral {
    this.contents[0] = numeralRoot;
    return this;
  }
  getNumeralAlter(): NumeralAlter | null {
    return this.contents[1];
  }
  setNumeralAlter(numeralAlter: NumeralAlter | null): Numeral {
    this.contents[1] = numeralAlter;
    return this;
  }
  getNumeralKey(): NumeralKey | null {
    return this.contents[2];
  }
  setNumeralKey(numeralKey: NumeralKey | null): Numeral {
    this.contents[2] = numeralKey;
    return this;
  }
}

export type FunctionAttributes = {
  color: string | null;
  'default-x': number | null;
  'default-y': number | null;
  'font-family': string | null;
  'font-size': 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null;
  'font-style': 'normal' | 'italic' | null;
  'font-weight': 'normal' | 'bold' | null;
  'relative-x': number | null;
  'relative-y': number | null;
};

export type FunctionContents = [string];

export class Function implements XMLElement<'function', FunctionAttributes, FunctionContents> {
  static readonly schema = {
    name: 'function',
    attributes: {
      color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
      'default-x': {
        type: 'label',
        label: 'default-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'default-y': {
        type: 'label',
        label: 'default-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
      'font-size': {
        type: 'optional',
        value: {
          type: 'choices',
          choices: [
            { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
            { type: 'float', min: -Infinity, max: Infinity },
          ],
        },
      },
      'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
      'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
      'relative-x': {
        type: 'label',
        label: 'relative-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'relative-y': {
        type: 'label',
        label: 'relative-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
    },
    contents: [{ type: 'required', value: { type: 'string' } }],
  } as const;

  readonly schema = Function.schema;

  attributes: FunctionAttributes;
  contents: FunctionContents;

  constructor(opts?: { attributes?: Partial<FunctionAttributes>; contents?: FunctionContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Function.schema);
    this.contents = opts?.contents ?? operations.zero(Function.schema.contents);
  }
  getColor(): string | null {
    return this.attributes['color'];
  }
  setColor(color: string | null): Function {
    this.attributes['color'] = color;
    return this;
  }
  getDefaultX(): number | null {
    return this.attributes['default-x'];
  }
  setDefaultX(defaultX: number | null): Function {
    this.attributes['default-x'] = defaultX;
    return this;
  }
  getDefaultY(): number | null {
    return this.attributes['default-y'];
  }
  setDefaultY(defaultY: number | null): Function {
    this.attributes['default-y'] = defaultY;
    return this;
  }
  getFontFamily(): string | null {
    return this.attributes['font-family'];
  }
  setFontFamily(fontFamily: string | null): Function {
    this.attributes['font-family'] = fontFamily;
    return this;
  }
  getFontSize(): 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null {
    return this.attributes['font-size'];
  }
  setFontSize(
    fontSize: 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null
  ): Function {
    this.attributes['font-size'] = fontSize;
    return this;
  }
  getFontStyle(): 'normal' | 'italic' | null {
    return this.attributes['font-style'];
  }
  setFontStyle(fontStyle: 'normal' | 'italic' | null): Function {
    this.attributes['font-style'] = fontStyle;
    return this;
  }
  getFontWeight(): 'normal' | 'bold' | null {
    return this.attributes['font-weight'];
  }
  setFontWeight(fontWeight: 'normal' | 'bold' | null): Function {
    this.attributes['font-weight'] = fontWeight;
    return this;
  }
  getRelativeX(): number | null {
    return this.attributes['relative-x'];
  }
  setRelativeX(relativeX: number | null): Function {
    this.attributes['relative-x'] = relativeX;
    return this;
  }
  getRelativeY(): number | null {
    return this.attributes['relative-y'];
  }
  setRelativeY(relativeY: number | null): Function {
    this.attributes['relative-y'] = relativeY;
    return this;
  }
  getText(): string {
    return this.contents[0];
  }
  setText(text: string): Function {
    this.contents[0] = text;
    return this;
  }
}

export type KindAttributes = {
  'bracket-degrees': 'yes' | 'no' | null;
  color: string | null;
  'default-x': number | null;
  'default-y': number | null;
  'font-family': string | null;
  'font-size': 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null;
  'font-style': 'normal' | 'italic' | null;
  'font-weight': 'normal' | 'bold' | null;
  halign: 'left' | 'center' | 'right' | null;
  'parentheses-degrees': 'yes' | 'no' | null;
  'relative-x': number | null;
  'relative-y': number | null;
  'stack-degrees': 'yes' | 'no' | null;
  text: string | null;
  'use-symbols': 'yes' | 'no' | null;
  valign: 'top' | 'middle' | 'bottom' | 'baseline' | null;
};

export type KindContents = [
  | 'none'
  | 'augmented'
  | 'augmented-seventh'
  | 'diminished'
  | 'diminished-seventh'
  | 'dominant'
  | 'dominant-11th'
  | 'dominant-13th'
  | 'dominant-ninth'
  | 'French'
  | 'German'
  | 'half-diminished'
  | 'Italian'
  | 'major'
  | 'major-11th'
  | 'major-13th'
  | 'major-minor'
  | 'major-ninth'
  | 'major-seventh'
  | 'major-sixth'
  | 'minor'
  | 'minor-11th'
  | 'minor-13th'
  | 'minor-ninth'
  | 'minor-seventh'
  | 'minor-sixth'
  | 'Neapolitan'
  | 'other'
  | 'pedal'
  | 'power'
  | 'suspended-fourth'
  | 'suspended-second'
  | 'Tristan'
];

export class Kind implements XMLElement<'kind', KindAttributes, KindContents> {
  static readonly schema = {
    name: 'kind',
    attributes: {
      'bracket-degrees': { type: 'optional', value: { type: 'choices', choices: ['yes', 'no'] } },
      color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
      'default-x': {
        type: 'label',
        label: 'default-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'default-y': {
        type: 'label',
        label: 'default-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
      'font-size': {
        type: 'optional',
        value: {
          type: 'choices',
          choices: [
            { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
            { type: 'float', min: -Infinity, max: Infinity },
          ],
        },
      },
      'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
      'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
      halign: { type: 'optional', value: { type: 'choices', choices: ['left', 'center', 'right'] } },
      'parentheses-degrees': { type: 'optional', value: { type: 'choices', choices: ['yes', 'no'] } },
      'relative-x': {
        type: 'label',
        label: 'relative-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'relative-y': {
        type: 'label',
        label: 'relative-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'stack-degrees': { type: 'optional', value: { type: 'choices', choices: ['yes', 'no'] } },
      text: { type: 'optional', value: { type: 'string' } },
      'use-symbols': { type: 'optional', value: { type: 'choices', choices: ['yes', 'no'] } },
      valign: { type: 'optional', value: { type: 'choices', choices: ['top', 'middle', 'bottom', 'baseline'] } },
    },
    contents: [
      {
        type: 'required',
        value: {
          type: 'label',
          label: 'kind-value',
          value: {
            type: 'choices',
            choices: [
              'none',
              'augmented',
              'augmented-seventh',
              'diminished',
              'diminished-seventh',
              'dominant',
              'dominant-11th',
              'dominant-13th',
              'dominant-ninth',
              'French',
              'German',
              'half-diminished',
              'Italian',
              'major',
              'major-11th',
              'major-13th',
              'major-minor',
              'major-ninth',
              'major-seventh',
              'major-sixth',
              'minor',
              'minor-11th',
              'minor-13th',
              'minor-ninth',
              'minor-seventh',
              'minor-sixth',
              'Neapolitan',
              'other',
              'pedal',
              'power',
              'suspended-fourth',
              'suspended-second',
              'Tristan',
            ],
          },
        },
      },
    ],
  } as const;

  readonly schema = Kind.schema;

  attributes: KindAttributes;
  contents: KindContents;

  constructor(opts?: { attributes?: Partial<KindAttributes>; contents?: KindContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Kind.schema);
    this.contents = opts?.contents ?? operations.zero(Kind.schema.contents);
  }
  getBracketDegrees(): 'yes' | 'no' | null {
    return this.attributes['bracket-degrees'];
  }
  setBracketDegrees(bracketDegrees: 'yes' | 'no' | null): Kind {
    this.attributes['bracket-degrees'] = bracketDegrees;
    return this;
  }
  getColor(): string | null {
    return this.attributes['color'];
  }
  setColor(color: string | null): Kind {
    this.attributes['color'] = color;
    return this;
  }
  getDefaultX(): number | null {
    return this.attributes['default-x'];
  }
  setDefaultX(defaultX: number | null): Kind {
    this.attributes['default-x'] = defaultX;
    return this;
  }
  getDefaultY(): number | null {
    return this.attributes['default-y'];
  }
  setDefaultY(defaultY: number | null): Kind {
    this.attributes['default-y'] = defaultY;
    return this;
  }
  getFontFamily(): string | null {
    return this.attributes['font-family'];
  }
  setFontFamily(fontFamily: string | null): Kind {
    this.attributes['font-family'] = fontFamily;
    return this;
  }
  getFontSize(): 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null {
    return this.attributes['font-size'];
  }
  setFontSize(
    fontSize: 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null
  ): Kind {
    this.attributes['font-size'] = fontSize;
    return this;
  }
  getFontStyle(): 'normal' | 'italic' | null {
    return this.attributes['font-style'];
  }
  setFontStyle(fontStyle: 'normal' | 'italic' | null): Kind {
    this.attributes['font-style'] = fontStyle;
    return this;
  }
  getFontWeight(): 'normal' | 'bold' | null {
    return this.attributes['font-weight'];
  }
  setFontWeight(fontWeight: 'normal' | 'bold' | null): Kind {
    this.attributes['font-weight'] = fontWeight;
    return this;
  }
  getHalign(): 'left' | 'center' | 'right' | null {
    return this.attributes['halign'];
  }
  setHalign(halign: 'left' | 'center' | 'right' | null): Kind {
    this.attributes['halign'] = halign;
    return this;
  }
  getParenthesesDegrees(): 'yes' | 'no' | null {
    return this.attributes['parentheses-degrees'];
  }
  setParenthesesDegrees(parenthesesDegrees: 'yes' | 'no' | null): Kind {
    this.attributes['parentheses-degrees'] = parenthesesDegrees;
    return this;
  }
  getRelativeX(): number | null {
    return this.attributes['relative-x'];
  }
  setRelativeX(relativeX: number | null): Kind {
    this.attributes['relative-x'] = relativeX;
    return this;
  }
  getRelativeY(): number | null {
    return this.attributes['relative-y'];
  }
  setRelativeY(relativeY: number | null): Kind {
    this.attributes['relative-y'] = relativeY;
    return this;
  }
  getStackDegrees(): 'yes' | 'no' | null {
    return this.attributes['stack-degrees'];
  }
  setStackDegrees(stackDegrees: 'yes' | 'no' | null): Kind {
    this.attributes['stack-degrees'] = stackDegrees;
    return this;
  }
  getText(): string | null {
    return this.attributes['text'];
  }
  setText(text: string | null): Kind {
    this.attributes['text'] = text;
    return this;
  }
  getUseSymbols(): 'yes' | 'no' | null {
    return this.attributes['use-symbols'];
  }
  setUseSymbols(useSymbols: 'yes' | 'no' | null): Kind {
    this.attributes['use-symbols'] = useSymbols;
    return this;
  }
  getValign(): 'top' | 'middle' | 'bottom' | 'baseline' | null {
    return this.attributes['valign'];
  }
  setValign(valign: 'top' | 'middle' | 'bottom' | 'baseline' | null): Kind {
    this.attributes['valign'] = valign;
    return this;
  }
  getKindValue():
    | 'none'
    | 'augmented'
    | 'augmented-seventh'
    | 'diminished'
    | 'diminished-seventh'
    | 'dominant'
    | 'dominant-11th'
    | 'dominant-13th'
    | 'dominant-ninth'
    | 'French'
    | 'German'
    | 'half-diminished'
    | 'Italian'
    | 'major'
    | 'major-11th'
    | 'major-13th'
    | 'major-minor'
    | 'major-ninth'
    | 'major-seventh'
    | 'major-sixth'
    | 'minor'
    | 'minor-11th'
    | 'minor-13th'
    | 'minor-ninth'
    | 'minor-seventh'
    | 'minor-sixth'
    | 'Neapolitan'
    | 'other'
    | 'pedal'
    | 'power'
    | 'suspended-fourth'
    | 'suspended-second'
    | 'Tristan' {
    return this.contents[0];
  }
  setKindValue(
    kindValue:
      | 'none'
      | 'augmented'
      | 'augmented-seventh'
      | 'diminished'
      | 'diminished-seventh'
      | 'dominant'
      | 'dominant-11th'
      | 'dominant-13th'
      | 'dominant-ninth'
      | 'French'
      | 'German'
      | 'half-diminished'
      | 'Italian'
      | 'major'
      | 'major-11th'
      | 'major-13th'
      | 'major-minor'
      | 'major-ninth'
      | 'major-seventh'
      | 'major-sixth'
      | 'minor'
      | 'minor-11th'
      | 'minor-13th'
      | 'minor-ninth'
      | 'minor-seventh'
      | 'minor-sixth'
      | 'Neapolitan'
      | 'other'
      | 'pedal'
      | 'power'
      | 'suspended-fourth'
      | 'suspended-second'
      | 'Tristan'
  ): Kind {
    this.contents[0] = kindValue;
    return this;
  }
}

export type InversionAttributes = {
  color: string | null;
  'default-x': number | null;
  'default-y': number | null;
  'font-family': string | null;
  'font-size': 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null;
  'font-style': 'normal' | 'italic' | null;
  'font-weight': 'normal' | 'bold' | null;
  'relative-x': number | null;
  'relative-y': number | null;
  text: string | null;
};

export type InversionContents = [number];

export class Inversion implements XMLElement<'inversion', InversionAttributes, InversionContents> {
  static readonly schema = {
    name: 'inversion',
    attributes: {
      color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
      'default-x': {
        type: 'label',
        label: 'default-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'default-y': {
        type: 'label',
        label: 'default-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
      'font-size': {
        type: 'optional',
        value: {
          type: 'choices',
          choices: [
            { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
            { type: 'float', min: -Infinity, max: Infinity },
          ],
        },
      },
      'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
      'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
      'relative-x': {
        type: 'label',
        label: 'relative-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'relative-y': {
        type: 'label',
        label: 'relative-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      text: { type: 'optional', value: { type: 'string' } },
    },
    contents: [
      { type: 'label', label: 'inversion', value: { type: 'required', value: { type: 'int', min: 0, max: Infinity } } },
    ],
  } as const;

  readonly schema = Inversion.schema;

  attributes: InversionAttributes;
  contents: InversionContents;

  constructor(opts?: { attributes?: Partial<InversionAttributes>; contents?: InversionContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Inversion.schema);
    this.contents = opts?.contents ?? operations.zero(Inversion.schema.contents);
  }
  getColor(): string | null {
    return this.attributes['color'];
  }
  setColor(color: string | null): Inversion {
    this.attributes['color'] = color;
    return this;
  }
  getDefaultX(): number | null {
    return this.attributes['default-x'];
  }
  setDefaultX(defaultX: number | null): Inversion {
    this.attributes['default-x'] = defaultX;
    return this;
  }
  getDefaultY(): number | null {
    return this.attributes['default-y'];
  }
  setDefaultY(defaultY: number | null): Inversion {
    this.attributes['default-y'] = defaultY;
    return this;
  }
  getFontFamily(): string | null {
    return this.attributes['font-family'];
  }
  setFontFamily(fontFamily: string | null): Inversion {
    this.attributes['font-family'] = fontFamily;
    return this;
  }
  getFontSize(): 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null {
    return this.attributes['font-size'];
  }
  setFontSize(
    fontSize: 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null
  ): Inversion {
    this.attributes['font-size'] = fontSize;
    return this;
  }
  getFontStyle(): 'normal' | 'italic' | null {
    return this.attributes['font-style'];
  }
  setFontStyle(fontStyle: 'normal' | 'italic' | null): Inversion {
    this.attributes['font-style'] = fontStyle;
    return this;
  }
  getFontWeight(): 'normal' | 'bold' | null {
    return this.attributes['font-weight'];
  }
  setFontWeight(fontWeight: 'normal' | 'bold' | null): Inversion {
    this.attributes['font-weight'] = fontWeight;
    return this;
  }
  getRelativeX(): number | null {
    return this.attributes['relative-x'];
  }
  setRelativeX(relativeX: number | null): Inversion {
    this.attributes['relative-x'] = relativeX;
    return this;
  }
  getRelativeY(): number | null {
    return this.attributes['relative-y'];
  }
  setRelativeY(relativeY: number | null): Inversion {
    this.attributes['relative-y'] = relativeY;
    return this;
  }
  getText(): string | null {
    return this.attributes['text'];
  }
  setText(text: string | null): Inversion {
    this.attributes['text'] = text;
    return this;
  }
  getInversion(): number {
    return this.contents[0];
  }
  setInversion(inversion: number): Inversion {
    this.contents[0] = inversion;
    return this;
  }
}

export type BassSeparatorAttributes = {
  color: string | null;
  'default-x': number | null;
  'default-y': number | null;
  'font-family': string | null;
  'font-size': 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null;
  'font-style': 'normal' | 'italic' | null;
  'font-weight': 'normal' | 'bold' | null;
  'relative-x': number | null;
  'relative-y': number | null;
};

export type BassSeparatorContents = [string];

export class BassSeparator implements XMLElement<'bass-separator', BassSeparatorAttributes, BassSeparatorContents> {
  static readonly schema = {
    name: 'bass-separator',
    attributes: {
      color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
      'default-x': {
        type: 'label',
        label: 'default-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'default-y': {
        type: 'label',
        label: 'default-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
      'font-size': {
        type: 'optional',
        value: {
          type: 'choices',
          choices: [
            { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
            { type: 'float', min: -Infinity, max: Infinity },
          ],
        },
      },
      'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
      'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
      'relative-x': {
        type: 'label',
        label: 'relative-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'relative-y': {
        type: 'label',
        label: 'relative-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
    },
    contents: [{ type: 'required', value: { type: 'string' } }],
  } as const;

  readonly schema = BassSeparator.schema;

  attributes: BassSeparatorAttributes;
  contents: BassSeparatorContents;

  constructor(opts?: { attributes?: Partial<BassSeparatorAttributes>; contents?: BassSeparatorContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, BassSeparator.schema);
    this.contents = opts?.contents ?? operations.zero(BassSeparator.schema.contents);
  }
  getColor(): string | null {
    return this.attributes['color'];
  }
  setColor(color: string | null): BassSeparator {
    this.attributes['color'] = color;
    return this;
  }
  getDefaultX(): number | null {
    return this.attributes['default-x'];
  }
  setDefaultX(defaultX: number | null): BassSeparator {
    this.attributes['default-x'] = defaultX;
    return this;
  }
  getDefaultY(): number | null {
    return this.attributes['default-y'];
  }
  setDefaultY(defaultY: number | null): BassSeparator {
    this.attributes['default-y'] = defaultY;
    return this;
  }
  getFontFamily(): string | null {
    return this.attributes['font-family'];
  }
  setFontFamily(fontFamily: string | null): BassSeparator {
    this.attributes['font-family'] = fontFamily;
    return this;
  }
  getFontSize(): 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null {
    return this.attributes['font-size'];
  }
  setFontSize(
    fontSize: 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null
  ): BassSeparator {
    this.attributes['font-size'] = fontSize;
    return this;
  }
  getFontStyle(): 'normal' | 'italic' | null {
    return this.attributes['font-style'];
  }
  setFontStyle(fontStyle: 'normal' | 'italic' | null): BassSeparator {
    this.attributes['font-style'] = fontStyle;
    return this;
  }
  getFontWeight(): 'normal' | 'bold' | null {
    return this.attributes['font-weight'];
  }
  setFontWeight(fontWeight: 'normal' | 'bold' | null): BassSeparator {
    this.attributes['font-weight'] = fontWeight;
    return this;
  }
  getRelativeX(): number | null {
    return this.attributes['relative-x'];
  }
  setRelativeX(relativeX: number | null): BassSeparator {
    this.attributes['relative-x'] = relativeX;
    return this;
  }
  getRelativeY(): number | null {
    return this.attributes['relative-y'];
  }
  setRelativeY(relativeY: number | null): BassSeparator {
    this.attributes['relative-y'] = relativeY;
    return this;
  }
  getText(): string {
    return this.contents[0];
  }
  setText(text: string): BassSeparator {
    this.contents[0] = text;
    return this;
  }
}

export type BassStepAttributes = {
  color: string | null;
  'default-x': number | null;
  'default-y': number | null;
  'font-family': string | null;
  'font-size': 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null;
  'font-style': 'normal' | 'italic' | null;
  'font-weight': 'normal' | 'bold' | null;
  'relative-x': number | null;
  'relative-y': number | null;
  text: string | null;
};

export type BassStepContents = ['A' | 'B' | 'C' | 'D' | 'E' | 'F' | 'G'];

export class BassStep implements XMLElement<'bass-step', BassStepAttributes, BassStepContents> {
  static readonly schema = {
    name: 'bass-step',
    attributes: {
      color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
      'default-x': {
        type: 'label',
        label: 'default-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'default-y': {
        type: 'label',
        label: 'default-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
      'font-size': {
        type: 'optional',
        value: {
          type: 'choices',
          choices: [
            { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
            { type: 'float', min: -Infinity, max: Infinity },
          ],
        },
      },
      'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
      'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
      'relative-x': {
        type: 'label',
        label: 'relative-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'relative-y': {
        type: 'label',
        label: 'relative-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      text: { type: 'optional', value: { type: 'string' } },
    },
    contents: [
      {
        type: 'required',
        value: {
          type: 'label',
          label: 'step',
          value: { type: 'choices', choices: ['A', 'B', 'C', 'D', 'E', 'F', 'G'] },
        },
      },
    ],
  } as const;

  readonly schema = BassStep.schema;

  attributes: BassStepAttributes;
  contents: BassStepContents;

  constructor(opts?: { attributes?: Partial<BassStepAttributes>; contents?: BassStepContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, BassStep.schema);
    this.contents = opts?.contents ?? operations.zero(BassStep.schema.contents);
  }
  getColor(): string | null {
    return this.attributes['color'];
  }
  setColor(color: string | null): BassStep {
    this.attributes['color'] = color;
    return this;
  }
  getDefaultX(): number | null {
    return this.attributes['default-x'];
  }
  setDefaultX(defaultX: number | null): BassStep {
    this.attributes['default-x'] = defaultX;
    return this;
  }
  getDefaultY(): number | null {
    return this.attributes['default-y'];
  }
  setDefaultY(defaultY: number | null): BassStep {
    this.attributes['default-y'] = defaultY;
    return this;
  }
  getFontFamily(): string | null {
    return this.attributes['font-family'];
  }
  setFontFamily(fontFamily: string | null): BassStep {
    this.attributes['font-family'] = fontFamily;
    return this;
  }
  getFontSize(): 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null {
    return this.attributes['font-size'];
  }
  setFontSize(
    fontSize: 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null
  ): BassStep {
    this.attributes['font-size'] = fontSize;
    return this;
  }
  getFontStyle(): 'normal' | 'italic' | null {
    return this.attributes['font-style'];
  }
  setFontStyle(fontStyle: 'normal' | 'italic' | null): BassStep {
    this.attributes['font-style'] = fontStyle;
    return this;
  }
  getFontWeight(): 'normal' | 'bold' | null {
    return this.attributes['font-weight'];
  }
  setFontWeight(fontWeight: 'normal' | 'bold' | null): BassStep {
    this.attributes['font-weight'] = fontWeight;
    return this;
  }
  getRelativeX(): number | null {
    return this.attributes['relative-x'];
  }
  setRelativeX(relativeX: number | null): BassStep {
    this.attributes['relative-x'] = relativeX;
    return this;
  }
  getRelativeY(): number | null {
    return this.attributes['relative-y'];
  }
  setRelativeY(relativeY: number | null): BassStep {
    this.attributes['relative-y'] = relativeY;
    return this;
  }
  getText(): string | null {
    return this.attributes['text'];
  }
  setText(text: string | null): BassStep {
    this.attributes['text'] = text;
    return this;
  }
  getStep(): 'A' | 'B' | 'C' | 'D' | 'E' | 'F' | 'G' {
    return this.contents[0];
  }
  setStep(step: 'A' | 'B' | 'C' | 'D' | 'E' | 'F' | 'G'): BassStep {
    this.contents[0] = step;
    return this;
  }
}

export type BassAlterAttributes = {
  color: string | null;
  'default-x': number | null;
  'default-y': number | null;
  'font-family': string | null;
  'font-size': 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null;
  'font-style': 'normal' | 'italic' | null;
  'font-weight': 'normal' | 'bold' | null;
  location: 'left' | 'right' | null;
  'print-object': 'yes' | 'no' | null;
  'relative-x': number | null;
  'relative-y': number | null;
};

export type BassAlterContents = [number];

export class BassAlter implements XMLElement<'bass-alter', BassAlterAttributes, BassAlterContents> {
  static readonly schema = {
    name: 'bass-alter',
    attributes: {
      color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
      'default-x': {
        type: 'label',
        label: 'default-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'default-y': {
        type: 'label',
        label: 'default-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
      'font-size': {
        type: 'optional',
        value: {
          type: 'choices',
          choices: [
            { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
            { type: 'float', min: -Infinity, max: Infinity },
          ],
        },
      },
      'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
      'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
      location: { type: 'optional', value: { type: 'choices', choices: ['left', 'right'] } },
      'print-object': { type: 'optional', value: { type: 'choices', choices: ['yes', 'no'] } },
      'relative-x': {
        type: 'label',
        label: 'relative-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'relative-y': {
        type: 'label',
        label: 'relative-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
    },
    contents: [
      {
        type: 'required',
        value: { type: 'label', label: 'semitones', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
    ],
  } as const;

  readonly schema = BassAlter.schema;

  attributes: BassAlterAttributes;
  contents: BassAlterContents;

  constructor(opts?: { attributes?: Partial<BassAlterAttributes>; contents?: BassAlterContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, BassAlter.schema);
    this.contents = opts?.contents ?? operations.zero(BassAlter.schema.contents);
  }
  getColor(): string | null {
    return this.attributes['color'];
  }
  setColor(color: string | null): BassAlter {
    this.attributes['color'] = color;
    return this;
  }
  getDefaultX(): number | null {
    return this.attributes['default-x'];
  }
  setDefaultX(defaultX: number | null): BassAlter {
    this.attributes['default-x'] = defaultX;
    return this;
  }
  getDefaultY(): number | null {
    return this.attributes['default-y'];
  }
  setDefaultY(defaultY: number | null): BassAlter {
    this.attributes['default-y'] = defaultY;
    return this;
  }
  getFontFamily(): string | null {
    return this.attributes['font-family'];
  }
  setFontFamily(fontFamily: string | null): BassAlter {
    this.attributes['font-family'] = fontFamily;
    return this;
  }
  getFontSize(): 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null {
    return this.attributes['font-size'];
  }
  setFontSize(
    fontSize: 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null
  ): BassAlter {
    this.attributes['font-size'] = fontSize;
    return this;
  }
  getFontStyle(): 'normal' | 'italic' | null {
    return this.attributes['font-style'];
  }
  setFontStyle(fontStyle: 'normal' | 'italic' | null): BassAlter {
    this.attributes['font-style'] = fontStyle;
    return this;
  }
  getFontWeight(): 'normal' | 'bold' | null {
    return this.attributes['font-weight'];
  }
  setFontWeight(fontWeight: 'normal' | 'bold' | null): BassAlter {
    this.attributes['font-weight'] = fontWeight;
    return this;
  }
  getLocation(): 'left' | 'right' | null {
    return this.attributes['location'];
  }
  setLocation(location: 'left' | 'right' | null): BassAlter {
    this.attributes['location'] = location;
    return this;
  }
  getPrintObject(): 'yes' | 'no' | null {
    return this.attributes['print-object'];
  }
  setPrintObject(printObject: 'yes' | 'no' | null): BassAlter {
    this.attributes['print-object'] = printObject;
    return this;
  }
  getRelativeX(): number | null {
    return this.attributes['relative-x'];
  }
  setRelativeX(relativeX: number | null): BassAlter {
    this.attributes['relative-x'] = relativeX;
    return this;
  }
  getRelativeY(): number | null {
    return this.attributes['relative-y'];
  }
  setRelativeY(relativeY: number | null): BassAlter {
    this.attributes['relative-y'] = relativeY;
    return this;
  }
  getSemitones(): number {
    return this.contents[0];
  }
  setSemitones(semitones: number): BassAlter {
    this.contents[0] = semitones;
    return this;
  }
}

export type BassAttributes = { arrangement: 'horizontal' | 'vertical' | 'diagonal' | null };

export type BassContents = [BassSeparator | null, BassStep, BassAlter | null];

export class Bass implements XMLElement<'bass', BassAttributes, BassContents> {
  static readonly schema = {
    name: 'bass',
    attributes: {
      arrangement: { type: 'optional', value: { type: 'choices', choices: ['horizontal', 'vertical', 'diagonal'] } },
    },
    contents: [
      { type: 'optional', value: BassSeparator },
      { type: 'required', value: BassStep },
      { type: 'optional', value: BassAlter },
    ],
  } as const;

  readonly schema = Bass.schema;

  attributes: BassAttributes;
  contents: BassContents;

  constructor(opts?: { attributes?: Partial<BassAttributes>; contents?: BassContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Bass.schema);
    this.contents = opts?.contents ?? operations.zero(Bass.schema.contents);
  }
  getArrangement(): 'horizontal' | 'vertical' | 'diagonal' | null {
    return this.attributes['arrangement'];
  }
  setArrangement(arrangement: 'horizontal' | 'vertical' | 'diagonal' | null): Bass {
    this.attributes['arrangement'] = arrangement;
    return this;
  }
  getBassSeparator(): BassSeparator | null {
    return this.contents[0];
  }
  setBassSeparator(bassSeparator: BassSeparator | null): Bass {
    this.contents[0] = bassSeparator;
    return this;
  }
  getBassStep(): BassStep {
    return this.contents[1];
  }
  setBassStep(bassStep: BassStep): Bass {
    this.contents[1] = bassStep;
    return this;
  }
  getBassAlter(): BassAlter | null {
    return this.contents[2];
  }
  setBassAlter(bassAlter: BassAlter | null): Bass {
    this.contents[2] = bassAlter;
    return this;
  }
}

export type DegreeValueAttributes = {
  color: string | null;
  'default-x': number | null;
  'default-y': number | null;
  'font-family': string | null;
  'font-size': 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null;
  'font-style': 'normal' | 'italic' | null;
  'font-weight': 'normal' | 'bold' | null;
  'relative-x': number | null;
  'relative-y': number | null;
  symbol: 'major' | 'minor' | 'augmented' | 'diminished' | 'half-diminished' | null;
  text: string | null;
};

export type DegreeValueContents = [number];

export class DegreeValue implements XMLElement<'degree-value', DegreeValueAttributes, DegreeValueContents> {
  static readonly schema = {
    name: 'degree-value',
    attributes: {
      color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
      'default-x': {
        type: 'label',
        label: 'default-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'default-y': {
        type: 'label',
        label: 'default-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
      'font-size': {
        type: 'optional',
        value: {
          type: 'choices',
          choices: [
            { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
            { type: 'float', min: -Infinity, max: Infinity },
          ],
        },
      },
      'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
      'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
      'relative-x': {
        type: 'label',
        label: 'relative-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'relative-y': {
        type: 'label',
        label: 'relative-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      symbol: {
        type: 'optional',
        value: { type: 'choices', choices: ['major', 'minor', 'augmented', 'diminished', 'half-diminished'] },
      },
      text: { type: 'optional', value: { type: 'string' } },
    },
    contents: [
      {
        type: 'label',
        label: 'degree-value',
        value: { type: 'required', value: { type: 'int', min: 1, max: Infinity } },
      },
    ],
  } as const;

  readonly schema = DegreeValue.schema;

  attributes: DegreeValueAttributes;
  contents: DegreeValueContents;

  constructor(opts?: { attributes?: Partial<DegreeValueAttributes>; contents?: DegreeValueContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, DegreeValue.schema);
    this.contents = opts?.contents ?? operations.zero(DegreeValue.schema.contents);
  }
  getColor(): string | null {
    return this.attributes['color'];
  }
  setColor(color: string | null): DegreeValue {
    this.attributes['color'] = color;
    return this;
  }
  getDefaultX(): number | null {
    return this.attributes['default-x'];
  }
  setDefaultX(defaultX: number | null): DegreeValue {
    this.attributes['default-x'] = defaultX;
    return this;
  }
  getDefaultY(): number | null {
    return this.attributes['default-y'];
  }
  setDefaultY(defaultY: number | null): DegreeValue {
    this.attributes['default-y'] = defaultY;
    return this;
  }
  getFontFamily(): string | null {
    return this.attributes['font-family'];
  }
  setFontFamily(fontFamily: string | null): DegreeValue {
    this.attributes['font-family'] = fontFamily;
    return this;
  }
  getFontSize(): 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null {
    return this.attributes['font-size'];
  }
  setFontSize(
    fontSize: 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null
  ): DegreeValue {
    this.attributes['font-size'] = fontSize;
    return this;
  }
  getFontStyle(): 'normal' | 'italic' | null {
    return this.attributes['font-style'];
  }
  setFontStyle(fontStyle: 'normal' | 'italic' | null): DegreeValue {
    this.attributes['font-style'] = fontStyle;
    return this;
  }
  getFontWeight(): 'normal' | 'bold' | null {
    return this.attributes['font-weight'];
  }
  setFontWeight(fontWeight: 'normal' | 'bold' | null): DegreeValue {
    this.attributes['font-weight'] = fontWeight;
    return this;
  }
  getRelativeX(): number | null {
    return this.attributes['relative-x'];
  }
  setRelativeX(relativeX: number | null): DegreeValue {
    this.attributes['relative-x'] = relativeX;
    return this;
  }
  getRelativeY(): number | null {
    return this.attributes['relative-y'];
  }
  setRelativeY(relativeY: number | null): DegreeValue {
    this.attributes['relative-y'] = relativeY;
    return this;
  }
  getSymbol(): 'major' | 'minor' | 'augmented' | 'diminished' | 'half-diminished' | null {
    return this.attributes['symbol'];
  }
  setSymbol(symbol: 'major' | 'minor' | 'augmented' | 'diminished' | 'half-diminished' | null): DegreeValue {
    this.attributes['symbol'] = symbol;
    return this;
  }
  getText(): string | null {
    return this.attributes['text'];
  }
  setText(text: string | null): DegreeValue {
    this.attributes['text'] = text;
    return this;
  }
  getDegreeValue(): number {
    return this.contents[0];
  }
  setDegreeValue(degreeValue: number): DegreeValue {
    this.contents[0] = degreeValue;
    return this;
  }
}

export type DegreeAlterAttributes = {
  color: string | null;
  'default-x': number | null;
  'default-y': number | null;
  'font-family': string | null;
  'font-size': 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null;
  'font-style': 'normal' | 'italic' | null;
  'font-weight': 'normal' | 'bold' | null;
  'plus-minus': 'yes' | 'no' | null;
  'relative-x': number | null;
  'relative-y': number | null;
};

export type DegreeAlterContents = [number];

export class DegreeAlter implements XMLElement<'degree-alter', DegreeAlterAttributes, DegreeAlterContents> {
  static readonly schema = {
    name: 'degree-alter',
    attributes: {
      color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
      'default-x': {
        type: 'label',
        label: 'default-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'default-y': {
        type: 'label',
        label: 'default-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
      'font-size': {
        type: 'optional',
        value: {
          type: 'choices',
          choices: [
            { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
            { type: 'float', min: -Infinity, max: Infinity },
          ],
        },
      },
      'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
      'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
      'plus-minus': { type: 'optional', value: { type: 'choices', choices: ['yes', 'no'] } },
      'relative-x': {
        type: 'label',
        label: 'relative-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'relative-y': {
        type: 'label',
        label: 'relative-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
    },
    contents: [{ type: 'label', label: 'semitones', value: { type: 'float', min: -Infinity, max: Infinity } }],
  } as const;

  readonly schema = DegreeAlter.schema;

  attributes: DegreeAlterAttributes;
  contents: DegreeAlterContents;

  constructor(opts?: { attributes?: Partial<DegreeAlterAttributes>; contents?: DegreeAlterContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, DegreeAlter.schema);
    this.contents = opts?.contents ?? operations.zero(DegreeAlter.schema.contents);
  }
  getColor(): string | null {
    return this.attributes['color'];
  }
  setColor(color: string | null): DegreeAlter {
    this.attributes['color'] = color;
    return this;
  }
  getDefaultX(): number | null {
    return this.attributes['default-x'];
  }
  setDefaultX(defaultX: number | null): DegreeAlter {
    this.attributes['default-x'] = defaultX;
    return this;
  }
  getDefaultY(): number | null {
    return this.attributes['default-y'];
  }
  setDefaultY(defaultY: number | null): DegreeAlter {
    this.attributes['default-y'] = defaultY;
    return this;
  }
  getFontFamily(): string | null {
    return this.attributes['font-family'];
  }
  setFontFamily(fontFamily: string | null): DegreeAlter {
    this.attributes['font-family'] = fontFamily;
    return this;
  }
  getFontSize(): 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null {
    return this.attributes['font-size'];
  }
  setFontSize(
    fontSize: 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null
  ): DegreeAlter {
    this.attributes['font-size'] = fontSize;
    return this;
  }
  getFontStyle(): 'normal' | 'italic' | null {
    return this.attributes['font-style'];
  }
  setFontStyle(fontStyle: 'normal' | 'italic' | null): DegreeAlter {
    this.attributes['font-style'] = fontStyle;
    return this;
  }
  getFontWeight(): 'normal' | 'bold' | null {
    return this.attributes['font-weight'];
  }
  setFontWeight(fontWeight: 'normal' | 'bold' | null): DegreeAlter {
    this.attributes['font-weight'] = fontWeight;
    return this;
  }
  getPlusMinus(): 'yes' | 'no' | null {
    return this.attributes['plus-minus'];
  }
  setPlusMinus(plusMinus: 'yes' | 'no' | null): DegreeAlter {
    this.attributes['plus-minus'] = plusMinus;
    return this;
  }
  getRelativeX(): number | null {
    return this.attributes['relative-x'];
  }
  setRelativeX(relativeX: number | null): DegreeAlter {
    this.attributes['relative-x'] = relativeX;
    return this;
  }
  getRelativeY(): number | null {
    return this.attributes['relative-y'];
  }
  setRelativeY(relativeY: number | null): DegreeAlter {
    this.attributes['relative-y'] = relativeY;
    return this;
  }
  getSemitones(): number {
    return this.contents[0];
  }
  setSemitones(semitones: number): DegreeAlter {
    this.contents[0] = semitones;
    return this;
  }
}

export type DegreeTypeAttributes = {
  color: string | null;
  'default-x': number | null;
  'default-y': number | null;
  'font-family': string | null;
  'font-size': 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null;
  'font-style': 'normal' | 'italic' | null;
  'font-weight': 'normal' | 'bold' | null;
  'relative-x': number | null;
  'relative-y': number | null;
  text: string | null;
};

export type DegreeTypeContents = ['add' | 'alter' | 'subtract'];

export class DegreeType implements XMLElement<'degree-type', DegreeTypeAttributes, DegreeTypeContents> {
  static readonly schema = {
    name: 'degree-type',
    attributes: {
      color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
      'default-x': {
        type: 'label',
        label: 'default-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'default-y': {
        type: 'label',
        label: 'default-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
      'font-size': {
        type: 'optional',
        value: {
          type: 'choices',
          choices: [
            { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
            { type: 'float', min: -Infinity, max: Infinity },
          ],
        },
      },
      'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
      'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
      'relative-x': {
        type: 'label',
        label: 'relative-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'relative-y': {
        type: 'label',
        label: 'relative-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      text: { type: 'optional', value: { type: 'string' } },
    },
    contents: [
      {
        type: 'required',
        value: {
          type: 'label',
          label: 'degree-type-value',
          value: { type: 'choices', choices: ['add', 'alter', 'subtract'] },
        },
      },
    ],
  } as const;

  readonly schema = DegreeType.schema;

  attributes: DegreeTypeAttributes;
  contents: DegreeTypeContents;

  constructor(opts?: { attributes?: Partial<DegreeTypeAttributes>; contents?: DegreeTypeContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, DegreeType.schema);
    this.contents = opts?.contents ?? operations.zero(DegreeType.schema.contents);
  }
  getColor(): string | null {
    return this.attributes['color'];
  }
  setColor(color: string | null): DegreeType {
    this.attributes['color'] = color;
    return this;
  }
  getDefaultX(): number | null {
    return this.attributes['default-x'];
  }
  setDefaultX(defaultX: number | null): DegreeType {
    this.attributes['default-x'] = defaultX;
    return this;
  }
  getDefaultY(): number | null {
    return this.attributes['default-y'];
  }
  setDefaultY(defaultY: number | null): DegreeType {
    this.attributes['default-y'] = defaultY;
    return this;
  }
  getFontFamily(): string | null {
    return this.attributes['font-family'];
  }
  setFontFamily(fontFamily: string | null): DegreeType {
    this.attributes['font-family'] = fontFamily;
    return this;
  }
  getFontSize(): 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null {
    return this.attributes['font-size'];
  }
  setFontSize(
    fontSize: 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null
  ): DegreeType {
    this.attributes['font-size'] = fontSize;
    return this;
  }
  getFontStyle(): 'normal' | 'italic' | null {
    return this.attributes['font-style'];
  }
  setFontStyle(fontStyle: 'normal' | 'italic' | null): DegreeType {
    this.attributes['font-style'] = fontStyle;
    return this;
  }
  getFontWeight(): 'normal' | 'bold' | null {
    return this.attributes['font-weight'];
  }
  setFontWeight(fontWeight: 'normal' | 'bold' | null): DegreeType {
    this.attributes['font-weight'] = fontWeight;
    return this;
  }
  getRelativeX(): number | null {
    return this.attributes['relative-x'];
  }
  setRelativeX(relativeX: number | null): DegreeType {
    this.attributes['relative-x'] = relativeX;
    return this;
  }
  getRelativeY(): number | null {
    return this.attributes['relative-y'];
  }
  setRelativeY(relativeY: number | null): DegreeType {
    this.attributes['relative-y'] = relativeY;
    return this;
  }
  getText(): string | null {
    return this.attributes['text'];
  }
  setText(text: string | null): DegreeType {
    this.attributes['text'] = text;
    return this;
  }
  getDegreeTypeValue(): 'add' | 'alter' | 'subtract' {
    return this.contents[0];
  }
  setDegreeTypeValue(degreeTypeValue: 'add' | 'alter' | 'subtract'): DegreeType {
    this.contents[0] = degreeTypeValue;
    return this;
  }
}

export type DegreeAttributes = { 'print-object': 'yes' | 'no' | null };

export type DegreeContents = [DegreeValue, DegreeAlter, DegreeType];

export class Degree implements XMLElement<'degree', DegreeAttributes, DegreeContents> {
  static readonly schema = {
    name: 'degree',
    attributes: { 'print-object': { type: 'optional', value: { type: 'choices', choices: ['yes', 'no'] } } },
    contents: [
      { type: 'required', value: DegreeValue },
      { type: 'required', value: DegreeAlter },
      { type: 'required', value: DegreeType },
    ],
  } as const;

  readonly schema = Degree.schema;

  attributes: DegreeAttributes;
  contents: DegreeContents;

  constructor(opts?: { attributes?: Partial<DegreeAttributes>; contents?: DegreeContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Degree.schema);
    this.contents = opts?.contents ?? operations.zero(Degree.schema.contents);
  }
  getPrintObject(): 'yes' | 'no' | null {
    return this.attributes['print-object'];
  }
  setPrintObject(printObject: 'yes' | 'no' | null): Degree {
    this.attributes['print-object'] = printObject;
    return this;
  }
  getDegreeValue(): DegreeValue {
    return this.contents[0];
  }
  setDegreeValue(degreeValue: DegreeValue): Degree {
    this.contents[0] = degreeValue;
    return this;
  }
  getDegreeAlter(): DegreeAlter {
    return this.contents[1];
  }
  setDegreeAlter(degreeAlter: DegreeAlter): Degree {
    this.contents[1] = degreeAlter;
    return this;
  }
  getDegreeType(): DegreeType {
    return this.contents[2];
  }
  setDegreeType(degreeType: DegreeType): Degree {
    this.contents[2] = degreeType;
    return this;
  }
}

export type FrameStringsAttributes = Record<string, unknown>;

export type FrameStringsContents = [number];

export class FrameStrings implements XMLElement<'frame-strings', FrameStringsAttributes, FrameStringsContents> {
  static readonly schema = {
    name: 'frame-strings',
    attributes: {},
    contents: [
      {
        type: 'label',
        label: 'lines-size',
        value: { type: 'required', value: { type: 'int', min: 1, max: Infinity } },
      },
    ],
  } as const;

  readonly schema = FrameStrings.schema;

  attributes: FrameStringsAttributes;
  contents: FrameStringsContents;

  constructor(opts?: { attributes?: Partial<FrameStringsAttributes>; contents?: FrameStringsContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, FrameStrings.schema);
    this.contents = opts?.contents ?? operations.zero(FrameStrings.schema.contents);
  }

  getLinesSize(): number {
    return this.contents[0];
  }
  setLinesSize(linesSize: number): FrameStrings {
    this.contents[0] = linesSize;
    return this;
  }
}

export type FrameFretsAttributes = Record<string, unknown>;

export type FrameFretsContents = [number];

export class FrameFrets implements XMLElement<'frame-frets', FrameFretsAttributes, FrameFretsContents> {
  static readonly schema = {
    name: 'frame-frets',
    attributes: {},
    contents: [
      {
        type: 'label',
        label: 'space-size',
        value: { type: 'required', value: { type: 'int', min: 1, max: Infinity } },
      },
    ],
  } as const;

  readonly schema = FrameFrets.schema;

  attributes: FrameFretsAttributes;
  contents: FrameFretsContents;

  constructor(opts?: { attributes?: Partial<FrameFretsAttributes>; contents?: FrameFretsContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, FrameFrets.schema);
    this.contents = opts?.contents ?? operations.zero(FrameFrets.schema.contents);
  }

  getSpaceSize(): number {
    return this.contents[0];
  }
  setSpaceSize(spaceSize: number): FrameFrets {
    this.contents[0] = spaceSize;
    return this;
  }
}

export type FirstFretAttributes = { location: 'left' | 'right' | null; text: string | null };

export type FirstFretContents = [number];

export class FirstFret implements XMLElement<'first-fret', FirstFretAttributes, FirstFretContents> {
  static readonly schema = {
    name: 'first-fret',
    attributes: {
      location: { type: 'optional', value: { type: 'choices', choices: ['left', 'right'] } },
      text: { type: 'optional', value: { type: 'string' } },
    },
    contents: [
      { type: 'label', label: 'fret', value: { type: 'required', value: { type: 'int', min: 1, max: Infinity } } },
    ],
  } as const;

  readonly schema = FirstFret.schema;

  attributes: FirstFretAttributes;
  contents: FirstFretContents;

  constructor(opts?: { attributes?: Partial<FirstFretAttributes>; contents?: FirstFretContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, FirstFret.schema);
    this.contents = opts?.contents ?? operations.zero(FirstFret.schema.contents);
  }
  getLocation(): 'left' | 'right' | null {
    return this.attributes['location'];
  }
  setLocation(location: 'left' | 'right' | null): FirstFret {
    this.attributes['location'] = location;
    return this;
  }
  getText(): string | null {
    return this.attributes['text'];
  }
  setText(text: string | null): FirstFret {
    this.attributes['text'] = text;
    return this;
  }
  getFret(): number {
    return this.contents[0];
  }
  setFret(fret: number): FirstFret {
    this.contents[0] = fret;
    return this;
  }
}

export type BarreAttributes = { type: 'start' | 'stop'; color: string | null };

export type BarreContents = [];

export class Barre implements XMLElement<'barre', BarreAttributes, BarreContents> {
  static readonly schema = {
    name: 'barre',
    attributes: {
      type: { type: 'required', value: { type: 'choices', choices: ['start', 'stop'] } },
      color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
    },
    contents: [],
  } as const;

  readonly schema = Barre.schema;

  attributes: BarreAttributes;
  contents: BarreContents;

  constructor(opts?: { attributes?: Partial<BarreAttributes>; contents?: BarreContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Barre.schema);
    this.contents = opts?.contents ?? operations.zero(Barre.schema.contents);
  }
  getType(): 'start' | 'stop' {
    return this.attributes['type'];
  }
  setType(type: 'start' | 'stop'): Barre {
    this.attributes['type'] = type;
    return this;
  }
  getColor(): string | null {
    return this.attributes['color'];
  }
  setColor(color: string | null): Barre {
    this.attributes['color'] = color;
    return this;
  }
}

export type FrameNoteAttributes = Record<string, unknown>;

export type FrameNoteContents = [String, Fret, Fingering | null, Barre | null];

export class FrameNote implements XMLElement<'frame-note', FrameNoteAttributes, FrameNoteContents> {
  static readonly schema = {
    name: 'frame-note',
    attributes: {},
    contents: [
      { type: 'required', value: String },
      { type: 'required', value: Fret },
      { type: 'optional', value: Fingering },
      { type: 'optional', value: Barre },
    ],
  } as const;

  readonly schema = FrameNote.schema;

  attributes: FrameNoteAttributes;
  contents: FrameNoteContents;

  constructor(opts?: { attributes?: Partial<FrameNoteAttributes>; contents?: FrameNoteContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, FrameNote.schema);
    this.contents = opts?.contents ?? operations.zero(FrameNote.schema.contents);
  }

  getString(): String {
    return this.contents[0];
  }
  setString(string: String): FrameNote {
    this.contents[0] = string;
    return this;
  }
  getFret(): Fret {
    return this.contents[1];
  }
  setFret(fret: Fret): FrameNote {
    this.contents[1] = fret;
    return this;
  }
  getFingering(): Fingering | null {
    return this.contents[2];
  }
  setFingering(fingering: Fingering | null): FrameNote {
    this.contents[2] = fingering;
    return this;
  }
  getBarre(): Barre | null {
    return this.contents[3];
  }
  setBarre(barre: Barre | null): FrameNote {
    this.contents[3] = barre;
    return this;
  }
}

export type FrameAttributes = {
  color: string | null;
  'default-x': number | null;
  'default-y': number | null;
  halign: 'left' | 'center' | 'right' | null;
  height: number | null;
  id: string | null;
  'font-family': string | null;
  'font-size': 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null;
  'font-style': 'normal' | 'italic' | null;
  'font-weight': 'normal' | 'bold' | null;
  'relative-x': number | null;
  'relative-y': number | null;
  unplayed: string | null;
  valign: 'top' | 'middle' | 'bottom' | null;
  width: number | null;
};

export type FrameContents = [FrameStrings, FrameFrets, FirstFret | null, Array<FrameNote>];

export class Frame implements XMLElement<'frame', FrameAttributes, FrameContents> {
  static readonly schema = {
    name: 'frame',
    attributes: {
      color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
      'default-x': {
        type: 'label',
        label: 'default-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'default-y': {
        type: 'label',
        label: 'default-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      halign: { type: 'optional', value: { type: 'choices', choices: ['left', 'center', 'right'] } },
      height: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      id: { type: 'optional', value: { type: 'regex', pattern: /[A-Za-z_][A-Za-z0-9.-_]*/, zero: '_' } },
      'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
      'font-size': {
        type: 'optional',
        value: {
          type: 'choices',
          choices: [
            { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
            { type: 'float', min: -Infinity, max: Infinity },
          ],
        },
      },
      'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
      'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
      'relative-x': {
        type: 'label',
        label: 'relative-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'relative-y': {
        type: 'label',
        label: 'relative-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      unplayed: { type: 'optional', value: { type: 'string' } },
      valign: { type: 'optional', value: { type: 'choices', choices: ['top', 'middle', 'bottom'] } },
      width: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
    },
    contents: [
      { type: 'required', value: FrameStrings },
      { type: 'required', value: FrameFrets },
      { type: 'optional', value: FirstFret },
      { type: 'label', label: 'frame-notes', value: { type: 'oneOrMore', value: FrameNote } },
    ],
  } as const;

  readonly schema = Frame.schema;

  attributes: FrameAttributes;
  contents: FrameContents;

  constructor(opts?: { attributes?: Partial<FrameAttributes>; contents?: FrameContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Frame.schema);
    this.contents = opts?.contents ?? operations.zero(Frame.schema.contents);
  }
  getColor(): string | null {
    return this.attributes['color'];
  }
  setColor(color: string | null): Frame {
    this.attributes['color'] = color;
    return this;
  }
  getDefaultX(): number | null {
    return this.attributes['default-x'];
  }
  setDefaultX(defaultX: number | null): Frame {
    this.attributes['default-x'] = defaultX;
    return this;
  }
  getDefaultY(): number | null {
    return this.attributes['default-y'];
  }
  setDefaultY(defaultY: number | null): Frame {
    this.attributes['default-y'] = defaultY;
    return this;
  }
  getHalign(): 'left' | 'center' | 'right' | null {
    return this.attributes['halign'];
  }
  setHalign(halign: 'left' | 'center' | 'right' | null): Frame {
    this.attributes['halign'] = halign;
    return this;
  }
  getHeight(): number | null {
    return this.attributes['height'];
  }
  setHeight(height: number | null): Frame {
    this.attributes['height'] = height;
    return this;
  }
  getId(): string | null {
    return this.attributes['id'];
  }
  setId(id: string | null): Frame {
    this.attributes['id'] = id;
    return this;
  }
  getFontFamily(): string | null {
    return this.attributes['font-family'];
  }
  setFontFamily(fontFamily: string | null): Frame {
    this.attributes['font-family'] = fontFamily;
    return this;
  }
  getFontSize(): 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null {
    return this.attributes['font-size'];
  }
  setFontSize(
    fontSize: 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null
  ): Frame {
    this.attributes['font-size'] = fontSize;
    return this;
  }
  getFontStyle(): 'normal' | 'italic' | null {
    return this.attributes['font-style'];
  }
  setFontStyle(fontStyle: 'normal' | 'italic' | null): Frame {
    this.attributes['font-style'] = fontStyle;
    return this;
  }
  getFontWeight(): 'normal' | 'bold' | null {
    return this.attributes['font-weight'];
  }
  setFontWeight(fontWeight: 'normal' | 'bold' | null): Frame {
    this.attributes['font-weight'] = fontWeight;
    return this;
  }
  getRelativeX(): number | null {
    return this.attributes['relative-x'];
  }
  setRelativeX(relativeX: number | null): Frame {
    this.attributes['relative-x'] = relativeX;
    return this;
  }
  getRelativeY(): number | null {
    return this.attributes['relative-y'];
  }
  setRelativeY(relativeY: number | null): Frame {
    this.attributes['relative-y'] = relativeY;
    return this;
  }
  getUnplayed(): string | null {
    return this.attributes['unplayed'];
  }
  setUnplayed(unplayed: string | null): Frame {
    this.attributes['unplayed'] = unplayed;
    return this;
  }
  getValign(): 'top' | 'middle' | 'bottom' | null {
    return this.attributes['valign'];
  }
  setValign(valign: 'top' | 'middle' | 'bottom' | null): Frame {
    this.attributes['valign'] = valign;
    return this;
  }
  getWidth(): number | null {
    return this.attributes['width'];
  }
  setWidth(width: number | null): Frame {
    this.attributes['width'] = width;
    return this;
  }
  getFrameStrings(): FrameStrings {
    return this.contents[0];
  }
  setFrameStrings(frameStrings: FrameStrings): Frame {
    this.contents[0] = frameStrings;
    return this;
  }
  getFrameFrets(): FrameFrets {
    return this.contents[1];
  }
  setFrameFrets(frameFrets: FrameFrets): Frame {
    this.contents[1] = frameFrets;
    return this;
  }
  getFirstFret(): FirstFret | null {
    return this.contents[2];
  }
  setFirstFret(firstFret: FirstFret | null): Frame {
    this.contents[2] = firstFret;
    return this;
  }
  getFrameNotes(): Array<FrameNote> {
    return this.contents[3];
  }
  setFrameNotes(frameNotes: Array<FrameNote>): Frame {
    this.contents[3] = frameNotes;
    return this;
  }
}

export type HarmonyAttributes = {
  arrangement: 'horizontal' | 'vertical' | 'diagonal' | null;
  color: string | null;
  'default-x': number | null;
  'default-y': number | null;
  'font-family': string | null;
  'font-size': 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null;
  'font-style': 'normal' | 'italic' | null;
  'font-weight': 'normal' | 'bold' | null;
  id: string | null;
  placement: 'above' | 'below' | null;
  'print-frame': 'yes' | 'no' | null;
  'print-object': 'yes' | 'no' | null;
  'relative-x': number | null;
  'relative-y': number | null;
  system: 'none' | 'only-top' | 'also-top' | null;
  type: 'alternate' | 'explicit' | 'implied' | null;
};

export type HarmonyContents = [
  Array<[Root | Numeral | Function, Kind, Inversion | null, Bass | null, Array<Degree>]>,
  Frame | null,
  Offset | null,
  Footnote | null,
  Level | null,
  Staff | null
];

export class Harmony implements XMLElement<'harmony', HarmonyAttributes, HarmonyContents> {
  static readonly schema = {
    name: 'harmony',
    attributes: {
      arrangement: { type: 'optional', value: { type: 'choices', choices: ['horizontal', 'vertical', 'diagonal'] } },
      color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
      'default-x': {
        type: 'label',
        label: 'default-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'default-y': {
        type: 'label',
        label: 'default-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
      'font-size': {
        type: 'optional',
        value: {
          type: 'choices',
          choices: [
            { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
            { type: 'float', min: -Infinity, max: Infinity },
          ],
        },
      },
      'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
      'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
      id: { type: 'optional', value: { type: 'regex', pattern: /[A-Za-z_][A-Za-z0-9.-_]*/, zero: '_' } },
      placement: { type: 'optional', value: { type: 'choices', choices: ['above', 'below'] } },
      'print-frame': { type: 'optional', value: { type: 'choices', choices: ['yes', 'no'] } },
      'print-object': { type: 'optional', value: { type: 'choices', choices: ['yes', 'no'] } },
      'relative-x': {
        type: 'label',
        label: 'relative-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'relative-y': {
        type: 'label',
        label: 'relative-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      system: { type: 'optional', value: { type: 'choices', choices: ['none', 'only-top', 'also-top'] } },
      type: { type: 'optional', value: { type: 'choices', choices: ['alternate', 'explicit', 'implied'] } },
    },
    contents: [
      {
        type: 'label',
        label: 'harmony-values',
        value: {
          type: 'oneOrMore',
          value: [
            { type: 'choices', choices: [Root, Numeral, Function] },
            { type: 'required', value: Kind },
            { type: 'optional', value: Inversion },
            { type: 'optional', value: Bass },
            { type: 'zeroOrMore', value: Degree },
          ],
        },
      },
      { type: 'optional', value: Frame },
      { type: 'optional', value: Offset },
      { type: 'optional', value: Footnote },
      { type: 'optional', value: Level },
      { type: 'optional', value: Staff },
    ],
  } as const;

  readonly schema = Harmony.schema;

  attributes: HarmonyAttributes;
  contents: HarmonyContents;

  constructor(opts?: { attributes?: Partial<HarmonyAttributes>; contents?: HarmonyContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Harmony.schema);
    this.contents = opts?.contents ?? operations.zero(Harmony.schema.contents);
  }
  getArrangement(): 'horizontal' | 'vertical' | 'diagonal' | null {
    return this.attributes['arrangement'];
  }
  setArrangement(arrangement: 'horizontal' | 'vertical' | 'diagonal' | null): Harmony {
    this.attributes['arrangement'] = arrangement;
    return this;
  }
  getColor(): string | null {
    return this.attributes['color'];
  }
  setColor(color: string | null): Harmony {
    this.attributes['color'] = color;
    return this;
  }
  getDefaultX(): number | null {
    return this.attributes['default-x'];
  }
  setDefaultX(defaultX: number | null): Harmony {
    this.attributes['default-x'] = defaultX;
    return this;
  }
  getDefaultY(): number | null {
    return this.attributes['default-y'];
  }
  setDefaultY(defaultY: number | null): Harmony {
    this.attributes['default-y'] = defaultY;
    return this;
  }
  getFontFamily(): string | null {
    return this.attributes['font-family'];
  }
  setFontFamily(fontFamily: string | null): Harmony {
    this.attributes['font-family'] = fontFamily;
    return this;
  }
  getFontSize(): 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null {
    return this.attributes['font-size'];
  }
  setFontSize(
    fontSize: 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null
  ): Harmony {
    this.attributes['font-size'] = fontSize;
    return this;
  }
  getFontStyle(): 'normal' | 'italic' | null {
    return this.attributes['font-style'];
  }
  setFontStyle(fontStyle: 'normal' | 'italic' | null): Harmony {
    this.attributes['font-style'] = fontStyle;
    return this;
  }
  getFontWeight(): 'normal' | 'bold' | null {
    return this.attributes['font-weight'];
  }
  setFontWeight(fontWeight: 'normal' | 'bold' | null): Harmony {
    this.attributes['font-weight'] = fontWeight;
    return this;
  }
  getId(): string | null {
    return this.attributes['id'];
  }
  setId(id: string | null): Harmony {
    this.attributes['id'] = id;
    return this;
  }
  getPlacement(): 'above' | 'below' | null {
    return this.attributes['placement'];
  }
  setPlacement(placement: 'above' | 'below' | null): Harmony {
    this.attributes['placement'] = placement;
    return this;
  }
  getPrintFrame(): 'yes' | 'no' | null {
    return this.attributes['print-frame'];
  }
  setPrintFrame(printFrame: 'yes' | 'no' | null): Harmony {
    this.attributes['print-frame'] = printFrame;
    return this;
  }
  getPrintObject(): 'yes' | 'no' | null {
    return this.attributes['print-object'];
  }
  setPrintObject(printObject: 'yes' | 'no' | null): Harmony {
    this.attributes['print-object'] = printObject;
    return this;
  }
  getRelativeX(): number | null {
    return this.attributes['relative-x'];
  }
  setRelativeX(relativeX: number | null): Harmony {
    this.attributes['relative-x'] = relativeX;
    return this;
  }
  getRelativeY(): number | null {
    return this.attributes['relative-y'];
  }
  setRelativeY(relativeY: number | null): Harmony {
    this.attributes['relative-y'] = relativeY;
    return this;
  }
  getSystem(): 'none' | 'only-top' | 'also-top' | null {
    return this.attributes['system'];
  }
  setSystem(system: 'none' | 'only-top' | 'also-top' | null): Harmony {
    this.attributes['system'] = system;
    return this;
  }
  getType(): 'alternate' | 'explicit' | 'implied' | null {
    return this.attributes['type'];
  }
  setType(type: 'alternate' | 'explicit' | 'implied' | null): Harmony {
    this.attributes['type'] = type;
    return this;
  }
  getHarmonyValues(): Array<[Root | Numeral | Function, Kind, Inversion | null, Bass | null, Array<Degree>]> {
    return this.contents[0];
  }
  setHarmonyValues(
    harmonyValues: Array<[Root | Numeral | Function, Kind, Inversion | null, Bass | null, Array<Degree>]>
  ): Harmony {
    this.contents[0] = harmonyValues;
    return this;
  }
  getFrame(): Frame | null {
    return this.contents[1];
  }
  setFrame(frame: Frame | null): Harmony {
    this.contents[1] = frame;
    return this;
  }
  getOffset(): Offset | null {
    return this.contents[2];
  }
  setOffset(offset: Offset | null): Harmony {
    this.contents[2] = offset;
    return this;
  }
  getFootnote(): Footnote | null {
    return this.contents[3];
  }
  setFootnote(footnote: Footnote | null): Harmony {
    this.contents[3] = footnote;
    return this;
  }
  getLevel(): Level | null {
    return this.contents[4];
  }
  setLevel(level: Level | null): Harmony {
    this.contents[4] = level;
    return this;
  }
  getStaff(): Staff | null {
    return this.contents[5];
  }
  setStaff(staff: Staff | null): Harmony {
    this.contents[5] = staff;
    return this;
  }
}

export type PrefixAttributes = {
  color: string | null;
  'default-x': number | null;
  'default-y': number | null;
  'font-family': string | null;
  'font-size': 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null;
  'font-style': 'normal' | 'italic' | null;
  'font-weight': 'normal' | 'bold' | null;
  'relative-x': number | null;
  'relative-y': number | null;
};

export type PrefixContents = [string];

export class Prefix implements XMLElement<'prefix', PrefixAttributes, PrefixContents> {
  static readonly schema = {
    name: 'prefix',
    attributes: {
      color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
      'default-x': {
        type: 'label',
        label: 'default-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'default-y': {
        type: 'label',
        label: 'default-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
      'font-size': {
        type: 'optional',
        value: {
          type: 'choices',
          choices: [
            { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
            { type: 'float', min: -Infinity, max: Infinity },
          ],
        },
      },
      'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
      'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
      'relative-x': {
        type: 'label',
        label: 'relative-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'relative-y': {
        type: 'label',
        label: 'relative-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
    },
    contents: [{ type: 'required', value: { type: 'string' } }],
  } as const;

  readonly schema = Prefix.schema;

  attributes: PrefixAttributes;
  contents: PrefixContents;

  constructor(opts?: { attributes?: Partial<PrefixAttributes>; contents?: PrefixContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Prefix.schema);
    this.contents = opts?.contents ?? operations.zero(Prefix.schema.contents);
  }
  getColor(): string | null {
    return this.attributes['color'];
  }
  setColor(color: string | null): Prefix {
    this.attributes['color'] = color;
    return this;
  }
  getDefaultX(): number | null {
    return this.attributes['default-x'];
  }
  setDefaultX(defaultX: number | null): Prefix {
    this.attributes['default-x'] = defaultX;
    return this;
  }
  getDefaultY(): number | null {
    return this.attributes['default-y'];
  }
  setDefaultY(defaultY: number | null): Prefix {
    this.attributes['default-y'] = defaultY;
    return this;
  }
  getFontFamily(): string | null {
    return this.attributes['font-family'];
  }
  setFontFamily(fontFamily: string | null): Prefix {
    this.attributes['font-family'] = fontFamily;
    return this;
  }
  getFontSize(): 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null {
    return this.attributes['font-size'];
  }
  setFontSize(
    fontSize: 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null
  ): Prefix {
    this.attributes['font-size'] = fontSize;
    return this;
  }
  getFontStyle(): 'normal' | 'italic' | null {
    return this.attributes['font-style'];
  }
  setFontStyle(fontStyle: 'normal' | 'italic' | null): Prefix {
    this.attributes['font-style'] = fontStyle;
    return this;
  }
  getFontWeight(): 'normal' | 'bold' | null {
    return this.attributes['font-weight'];
  }
  setFontWeight(fontWeight: 'normal' | 'bold' | null): Prefix {
    this.attributes['font-weight'] = fontWeight;
    return this;
  }
  getRelativeX(): number | null {
    return this.attributes['relative-x'];
  }
  setRelativeX(relativeX: number | null): Prefix {
    this.attributes['relative-x'] = relativeX;
    return this;
  }
  getRelativeY(): number | null {
    return this.attributes['relative-y'];
  }
  setRelativeY(relativeY: number | null): Prefix {
    this.attributes['relative-y'] = relativeY;
    return this;
  }
  getText(): string {
    return this.contents[0];
  }
  setText(text: string): Prefix {
    this.contents[0] = text;
    return this;
  }
}

export type FigureNumberAttributes = {
  color: string | null;
  'default-x': number | null;
  'default-y': number | null;
  'font-family': string | null;
  'font-size': 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null;
  'font-style': 'normal' | 'italic' | null;
  'font-weight': 'normal' | 'bold' | null;
  'relative-x': number | null;
  'relative-y': number | null;
};

export type FigureNumberContents = [string];

export class FigureNumber implements XMLElement<'figure-number', FigureNumberAttributes, FigureNumberContents> {
  static readonly schema = {
    name: 'figure-number',
    attributes: {
      color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
      'default-x': {
        type: 'label',
        label: 'default-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'default-y': {
        type: 'label',
        label: 'default-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
      'font-size': {
        type: 'optional',
        value: {
          type: 'choices',
          choices: [
            { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
            { type: 'float', min: -Infinity, max: Infinity },
          ],
        },
      },
      'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
      'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
      'relative-x': {
        type: 'label',
        label: 'relative-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'relative-y': {
        type: 'label',
        label: 'relative-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
    },
    contents: [{ type: 'string' }],
  } as const;

  readonly schema = FigureNumber.schema;

  attributes: FigureNumberAttributes;
  contents: FigureNumberContents;

  constructor(opts?: { attributes?: Partial<FigureNumberAttributes>; contents?: FigureNumberContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, FigureNumber.schema);
    this.contents = opts?.contents ?? operations.zero(FigureNumber.schema.contents);
  }
  getColor(): string | null {
    return this.attributes['color'];
  }
  setColor(color: string | null): FigureNumber {
    this.attributes['color'] = color;
    return this;
  }
  getDefaultX(): number | null {
    return this.attributes['default-x'];
  }
  setDefaultX(defaultX: number | null): FigureNumber {
    this.attributes['default-x'] = defaultX;
    return this;
  }
  getDefaultY(): number | null {
    return this.attributes['default-y'];
  }
  setDefaultY(defaultY: number | null): FigureNumber {
    this.attributes['default-y'] = defaultY;
    return this;
  }
  getFontFamily(): string | null {
    return this.attributes['font-family'];
  }
  setFontFamily(fontFamily: string | null): FigureNumber {
    this.attributes['font-family'] = fontFamily;
    return this;
  }
  getFontSize(): 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null {
    return this.attributes['font-size'];
  }
  setFontSize(
    fontSize: 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null
  ): FigureNumber {
    this.attributes['font-size'] = fontSize;
    return this;
  }
  getFontStyle(): 'normal' | 'italic' | null {
    return this.attributes['font-style'];
  }
  setFontStyle(fontStyle: 'normal' | 'italic' | null): FigureNumber {
    this.attributes['font-style'] = fontStyle;
    return this;
  }
  getFontWeight(): 'normal' | 'bold' | null {
    return this.attributes['font-weight'];
  }
  setFontWeight(fontWeight: 'normal' | 'bold' | null): FigureNumber {
    this.attributes['font-weight'] = fontWeight;
    return this;
  }
  getRelativeX(): number | null {
    return this.attributes['relative-x'];
  }
  setRelativeX(relativeX: number | null): FigureNumber {
    this.attributes['relative-x'] = relativeX;
    return this;
  }
  getRelativeY(): number | null {
    return this.attributes['relative-y'];
  }
  setRelativeY(relativeY: number | null): FigureNumber {
    this.attributes['relative-y'] = relativeY;
    return this;
  }
  getText(): string {
    return this.contents[0];
  }
  setText(text: string): FigureNumber {
    this.contents[0] = text;
    return this;
  }
}

export type SuffixAttributes = {
  color: string | null;
  'default-x': number | null;
  'default-y': number | null;
  'font-family': string | null;
  'font-size': 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null;
  'font-style': 'normal' | 'italic' | null;
  'font-weight': 'normal' | 'bold' | null;
  'relative-x': number | null;
  'relative-y': number | null;
};

export type SuffixContents = [string];

export class Suffix implements XMLElement<'suffix', SuffixAttributes, SuffixContents> {
  static readonly schema = {
    name: 'suffix',
    attributes: {
      color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
      'default-x': {
        type: 'label',
        label: 'default-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'default-y': {
        type: 'label',
        label: 'default-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
      'font-size': {
        type: 'optional',
        value: {
          type: 'choices',
          choices: [
            { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
            { type: 'float', min: -Infinity, max: Infinity },
          ],
        },
      },
      'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
      'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
      'relative-x': {
        type: 'label',
        label: 'relative-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'relative-y': {
        type: 'label',
        label: 'relative-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
    },
    contents: [{ type: 'required', value: { type: 'string' } }],
  } as const;

  readonly schema = Suffix.schema;

  attributes: SuffixAttributes;
  contents: SuffixContents;

  constructor(opts?: { attributes?: Partial<SuffixAttributes>; contents?: SuffixContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Suffix.schema);
    this.contents = opts?.contents ?? operations.zero(Suffix.schema.contents);
  }
  getColor(): string | null {
    return this.attributes['color'];
  }
  setColor(color: string | null): Suffix {
    this.attributes['color'] = color;
    return this;
  }
  getDefaultX(): number | null {
    return this.attributes['default-x'];
  }
  setDefaultX(defaultX: number | null): Suffix {
    this.attributes['default-x'] = defaultX;
    return this;
  }
  getDefaultY(): number | null {
    return this.attributes['default-y'];
  }
  setDefaultY(defaultY: number | null): Suffix {
    this.attributes['default-y'] = defaultY;
    return this;
  }
  getFontFamily(): string | null {
    return this.attributes['font-family'];
  }
  setFontFamily(fontFamily: string | null): Suffix {
    this.attributes['font-family'] = fontFamily;
    return this;
  }
  getFontSize(): 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null {
    return this.attributes['font-size'];
  }
  setFontSize(
    fontSize: 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null
  ): Suffix {
    this.attributes['font-size'] = fontSize;
    return this;
  }
  getFontStyle(): 'normal' | 'italic' | null {
    return this.attributes['font-style'];
  }
  setFontStyle(fontStyle: 'normal' | 'italic' | null): Suffix {
    this.attributes['font-style'] = fontStyle;
    return this;
  }
  getFontWeight(): 'normal' | 'bold' | null {
    return this.attributes['font-weight'];
  }
  setFontWeight(fontWeight: 'normal' | 'bold' | null): Suffix {
    this.attributes['font-weight'] = fontWeight;
    return this;
  }
  getRelativeX(): number | null {
    return this.attributes['relative-x'];
  }
  setRelativeX(relativeX: number | null): Suffix {
    this.attributes['relative-x'] = relativeX;
    return this;
  }
  getRelativeY(): number | null {
    return this.attributes['relative-y'];
  }
  setRelativeY(relativeY: number | null): Suffix {
    this.attributes['relative-y'] = relativeY;
    return this;
  }
  getText(): string {
    return this.contents[0];
  }
  setText(text: string): Suffix {
    this.contents[0] = text;
    return this;
  }
}

export type FigureAttributes = Record<string, unknown>;

export type FigureContents = [
  Prefix | null,
  FigureNumber | null,
  Suffix | null,
  Extend | null,
  Footnote | null,
  Level | null
];

export class Figure implements XMLElement<'figure', FigureAttributes, FigureContents> {
  static readonly schema = {
    name: 'figure',
    attributes: {},
    contents: [
      { type: 'optional', value: Prefix },
      { type: 'optional', value: FigureNumber },
      { type: 'optional', value: Suffix },
      { type: 'optional', value: Extend },
      { type: 'optional', value: Footnote },
      { type: 'optional', value: Level },
    ],
  } as const;

  readonly schema = Figure.schema;

  attributes: FigureAttributes;
  contents: FigureContents;

  constructor(opts?: { attributes?: Partial<FigureAttributes>; contents?: FigureContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Figure.schema);
    this.contents = opts?.contents ?? operations.zero(Figure.schema.contents);
  }

  getPrefix(): Prefix | null {
    return this.contents[0];
  }
  setPrefix(prefix: Prefix | null): Figure {
    this.contents[0] = prefix;
    return this;
  }
  getFigureNumber(): FigureNumber | null {
    return this.contents[1];
  }
  setFigureNumber(figureNumber: FigureNumber | null): Figure {
    this.contents[1] = figureNumber;
    return this;
  }
  getSuffix(): Suffix | null {
    return this.contents[2];
  }
  setSuffix(suffix: Suffix | null): Figure {
    this.contents[2] = suffix;
    return this;
  }
  getExtend(): Extend | null {
    return this.contents[3];
  }
  setExtend(extend: Extend | null): Figure {
    this.contents[3] = extend;
    return this;
  }
  getFootnote(): Footnote | null {
    return this.contents[4];
  }
  setFootnote(footnote: Footnote | null): Figure {
    this.contents[4] = footnote;
    return this;
  }
  getLevel(): Level | null {
    return this.contents[5];
  }
  setLevel(level: Level | null): Figure {
    this.contents[5] = level;
    return this;
  }
}

export type FiguredBassAttributes = {
  color: string | null;
  'default-x': number | null;
  'default-y': number | null;
  'font-family': string | null;
  'font-size': 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null;
  'font-style': 'normal' | 'italic' | null;
  'font-weight': 'normal' | 'bold' | null;
  halign: 'left' | 'center' | 'right' | null;
  id: string | null;
  parentheses: 'yes' | 'no' | null;
  placement: 'above' | 'below' | null;
  'print-dot': 'yes' | 'no' | null;
  'print-lyric': 'yes' | 'no' | null;
  'print-object': 'yes' | 'no' | null;
  'print-spacing': 'yes' | 'no' | null;
  'relative-x': number | null;
  'relative-y': number | null;
  valign: 'top' | 'middle' | 'bottom' | 'baseline' | null;
};

export type FiguredBassContents = [Array<Figure>, Duration | null, Footnote | null, Level | null];

export class FiguredBass implements XMLElement<'figured-bass', FiguredBassAttributes, FiguredBassContents> {
  static readonly schema = {
    name: 'figured-bass',
    attributes: {
      color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
      'default-x': {
        type: 'label',
        label: 'default-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'default-y': {
        type: 'label',
        label: 'default-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
      'font-size': {
        type: 'optional',
        value: {
          type: 'choices',
          choices: [
            { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
            { type: 'float', min: -Infinity, max: Infinity },
          ],
        },
      },
      'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
      'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
      halign: { type: 'optional', value: { type: 'choices', choices: ['left', 'center', 'right'] } },
      id: { type: 'optional', value: { type: 'regex', pattern: /[A-Za-z_][A-Za-z0-9.-_]*/, zero: '_' } },
      parentheses: { type: 'optional', value: { type: 'choices', choices: ['yes', 'no'] } },
      placement: { type: 'optional', value: { type: 'choices', choices: ['above', 'below'] } },
      'print-dot': { type: 'optional', value: { type: 'choices', choices: ['yes', 'no'] } },
      'print-lyric': { type: 'optional', value: { type: 'choices', choices: ['yes', 'no'] } },
      'print-object': { type: 'optional', value: { type: 'choices', choices: ['yes', 'no'] } },
      'print-spacing': { type: 'optional', value: { type: 'choices', choices: ['yes', 'no'] } },
      'relative-x': {
        type: 'label',
        label: 'relative-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'relative-y': {
        type: 'label',
        label: 'relative-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      valign: { type: 'optional', value: { type: 'choices', choices: ['top', 'middle', 'bottom', 'baseline'] } },
    },
    contents: [
      { type: 'label', label: 'figures', value: { type: 'oneOrMore', value: Figure } },
      { type: 'optional', value: Duration },
      { type: 'optional', value: Footnote },
      { type: 'optional', value: Level },
    ],
  } as const;

  readonly schema = FiguredBass.schema;

  attributes: FiguredBassAttributes;
  contents: FiguredBassContents;

  constructor(opts?: { attributes?: Partial<FiguredBassAttributes>; contents?: FiguredBassContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, FiguredBass.schema);
    this.contents = opts?.contents ?? operations.zero(FiguredBass.schema.contents);
  }
  getColor(): string | null {
    return this.attributes['color'];
  }
  setColor(color: string | null): FiguredBass {
    this.attributes['color'] = color;
    return this;
  }
  getDefaultX(): number | null {
    return this.attributes['default-x'];
  }
  setDefaultX(defaultX: number | null): FiguredBass {
    this.attributes['default-x'] = defaultX;
    return this;
  }
  getDefaultY(): number | null {
    return this.attributes['default-y'];
  }
  setDefaultY(defaultY: number | null): FiguredBass {
    this.attributes['default-y'] = defaultY;
    return this;
  }
  getFontFamily(): string | null {
    return this.attributes['font-family'];
  }
  setFontFamily(fontFamily: string | null): FiguredBass {
    this.attributes['font-family'] = fontFamily;
    return this;
  }
  getFontSize(): 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null {
    return this.attributes['font-size'];
  }
  setFontSize(
    fontSize: 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null
  ): FiguredBass {
    this.attributes['font-size'] = fontSize;
    return this;
  }
  getFontStyle(): 'normal' | 'italic' | null {
    return this.attributes['font-style'];
  }
  setFontStyle(fontStyle: 'normal' | 'italic' | null): FiguredBass {
    this.attributes['font-style'] = fontStyle;
    return this;
  }
  getFontWeight(): 'normal' | 'bold' | null {
    return this.attributes['font-weight'];
  }
  setFontWeight(fontWeight: 'normal' | 'bold' | null): FiguredBass {
    this.attributes['font-weight'] = fontWeight;
    return this;
  }
  getHalign(): 'left' | 'center' | 'right' | null {
    return this.attributes['halign'];
  }
  setHalign(halign: 'left' | 'center' | 'right' | null): FiguredBass {
    this.attributes['halign'] = halign;
    return this;
  }
  getId(): string | null {
    return this.attributes['id'];
  }
  setId(id: string | null): FiguredBass {
    this.attributes['id'] = id;
    return this;
  }
  getParentheses(): 'yes' | 'no' | null {
    return this.attributes['parentheses'];
  }
  setParentheses(parentheses: 'yes' | 'no' | null): FiguredBass {
    this.attributes['parentheses'] = parentheses;
    return this;
  }
  getPlacement(): 'above' | 'below' | null {
    return this.attributes['placement'];
  }
  setPlacement(placement: 'above' | 'below' | null): FiguredBass {
    this.attributes['placement'] = placement;
    return this;
  }
  getPrintDot(): 'yes' | 'no' | null {
    return this.attributes['print-dot'];
  }
  setPrintDot(printDot: 'yes' | 'no' | null): FiguredBass {
    this.attributes['print-dot'] = printDot;
    return this;
  }
  getPrintLyric(): 'yes' | 'no' | null {
    return this.attributes['print-lyric'];
  }
  setPrintLyric(printLyric: 'yes' | 'no' | null): FiguredBass {
    this.attributes['print-lyric'] = printLyric;
    return this;
  }
  getPrintObject(): 'yes' | 'no' | null {
    return this.attributes['print-object'];
  }
  setPrintObject(printObject: 'yes' | 'no' | null): FiguredBass {
    this.attributes['print-object'] = printObject;
    return this;
  }
  getPrintSpacing(): 'yes' | 'no' | null {
    return this.attributes['print-spacing'];
  }
  setPrintSpacing(printSpacing: 'yes' | 'no' | null): FiguredBass {
    this.attributes['print-spacing'] = printSpacing;
    return this;
  }
  getRelativeX(): number | null {
    return this.attributes['relative-x'];
  }
  setRelativeX(relativeX: number | null): FiguredBass {
    this.attributes['relative-x'] = relativeX;
    return this;
  }
  getRelativeY(): number | null {
    return this.attributes['relative-y'];
  }
  setRelativeY(relativeY: number | null): FiguredBass {
    this.attributes['relative-y'] = relativeY;
    return this;
  }
  getValign(): 'top' | 'middle' | 'bottom' | 'baseline' | null {
    return this.attributes['valign'];
  }
  setValign(valign: 'top' | 'middle' | 'bottom' | 'baseline' | null): FiguredBass {
    this.attributes['valign'] = valign;
    return this;
  }
  getFigures(): Array<Figure> {
    return this.contents[0];
  }
  setFigures(figures: Array<Figure>): FiguredBass {
    this.contents[0] = figures;
    return this;
  }
  getDuration(): Duration | null {
    return this.contents[1];
  }
  setDuration(duration: Duration | null): FiguredBass {
    this.contents[1] = duration;
    return this;
  }
  getFootnote(): Footnote | null {
    return this.contents[2];
  }
  setFootnote(footnote: Footnote | null): FiguredBass {
    this.contents[2] = footnote;
    return this;
  }
  getLevel(): Level | null {
    return this.contents[3];
  }
  setLevel(level: Level | null): FiguredBass {
    this.contents[3] = level;
    return this;
  }
}

export type MeasureDistanceAttributes = Record<string, unknown>;

export type MeasureDistanceContents = [number];

export class MeasureDistance
  implements XMLElement<'measure-distance', MeasureDistanceAttributes, MeasureDistanceContents>
{
  static readonly schema = {
    name: 'measure-distance',
    attributes: {},
    contents: [
      {
        type: 'label',
        label: 'measure-distance-value',
        value: { type: 'required', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
    ],
  } as const;

  readonly schema = MeasureDistance.schema;

  attributes: MeasureDistanceAttributes;
  contents: MeasureDistanceContents;

  constructor(opts?: { attributes?: Partial<MeasureDistanceAttributes>; contents?: MeasureDistanceContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, MeasureDistance.schema);
    this.contents = opts?.contents ?? operations.zero(MeasureDistance.schema.contents);
  }

  getMeasureDistanceValue(): number {
    return this.contents[0];
  }
  setMeasureDistanceValue(measureDistanceValue: number): MeasureDistance {
    this.contents[0] = measureDistanceValue;
    return this;
  }
}

export type MeasureLayoutAttributes = Record<string, unknown>;

export type MeasureLayoutContents = [MeasureDistance | null];

export class MeasureLayout implements XMLElement<'measure-layout', MeasureLayoutAttributes, MeasureLayoutContents> {
  static readonly schema = {
    name: 'measure-layout',
    attributes: {},
    contents: [{ type: 'optional', value: MeasureDistance }],
  } as const;

  readonly schema = MeasureLayout.schema;

  attributes: MeasureLayoutAttributes;
  contents: MeasureLayoutContents;

  constructor(opts?: { attributes?: Partial<MeasureLayoutAttributes>; contents?: MeasureLayoutContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, MeasureLayout.schema);
    this.contents = opts?.contents ?? operations.zero(MeasureLayout.schema.contents);
  }

  getMeasureDistance(): MeasureDistance | null {
    return this.contents[0];
  }
  setMeasureDistance(measureDistance: MeasureDistance | null): MeasureLayout {
    this.contents[0] = measureDistance;
    return this;
  }
}

export type MeasureNumberingAttributes = {
  color: string | null;
  'default-x': number | null;
  'default-y': number | null;
  'font-family': string | null;
  'font-size': 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null;
  'font-style': 'normal' | 'italic' | null;
  'font-weight': 'normal' | 'bold' | null;
  halign: 'left' | 'center' | 'right' | null;
  'multiple-rest-always': 'yes' | 'no' | null;
  'multiple-rest-range': 'yes' | 'no' | null;
  'relative-x': number | null;
  'relative-y': number | null;
  staff: number | null;
  system: 'none' | 'only-top' | 'only-bottom' | 'also-top' | 'also-bottom' | null;
  valign: 'top' | 'middle' | 'bottom' | 'baseline' | null;
};

export type MeasureNumberingContents = ['none' | 'measure' | 'system'];

export class MeasureNumbering
  implements XMLElement<'measure-numbering', MeasureNumberingAttributes, MeasureNumberingContents>
{
  static readonly schema = {
    name: 'measure-numbering',
    attributes: {
      color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
      'default-x': {
        type: 'label',
        label: 'default-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'default-y': {
        type: 'label',
        label: 'default-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
      'font-size': {
        type: 'optional',
        value: {
          type: 'choices',
          choices: [
            { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
            { type: 'float', min: -Infinity, max: Infinity },
          ],
        },
      },
      'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
      'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
      halign: { type: 'optional', value: { type: 'choices', choices: ['left', 'center', 'right'] } },
      'multiple-rest-always': { type: 'optional', value: { type: 'choices', choices: ['yes', 'no'] } },
      'multiple-rest-range': { type: 'optional', value: { type: 'choices', choices: ['yes', 'no'] } },
      'relative-x': {
        type: 'label',
        label: 'relative-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'relative-y': {
        type: 'label',
        label: 'relative-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      staff: { type: 'optional', value: { type: 'int', min: 1, max: Infinity } },
      system: {
        type: 'optional',
        value: { type: 'choices', choices: ['none', 'only-top', 'only-bottom', 'also-top', 'also-bottom'] },
      },
      valign: { type: 'optional', value: { type: 'choices', choices: ['top', 'middle', 'bottom', 'baseline'] } },
    },
    contents: [
      {
        type: 'required',
        value: {
          type: 'label',
          label: 'measure-number-value',
          value: { type: 'choices', choices: ['none', 'measure', 'system'] },
        },
      },
    ],
  } as const;

  readonly schema = MeasureNumbering.schema;

  attributes: MeasureNumberingAttributes;
  contents: MeasureNumberingContents;

  constructor(opts?: { attributes?: Partial<MeasureNumberingAttributes>; contents?: MeasureNumberingContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, MeasureNumbering.schema);
    this.contents = opts?.contents ?? operations.zero(MeasureNumbering.schema.contents);
  }
  getColor(): string | null {
    return this.attributes['color'];
  }
  setColor(color: string | null): MeasureNumbering {
    this.attributes['color'] = color;
    return this;
  }
  getDefaultX(): number | null {
    return this.attributes['default-x'];
  }
  setDefaultX(defaultX: number | null): MeasureNumbering {
    this.attributes['default-x'] = defaultX;
    return this;
  }
  getDefaultY(): number | null {
    return this.attributes['default-y'];
  }
  setDefaultY(defaultY: number | null): MeasureNumbering {
    this.attributes['default-y'] = defaultY;
    return this;
  }
  getFontFamily(): string | null {
    return this.attributes['font-family'];
  }
  setFontFamily(fontFamily: string | null): MeasureNumbering {
    this.attributes['font-family'] = fontFamily;
    return this;
  }
  getFontSize(): 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null {
    return this.attributes['font-size'];
  }
  setFontSize(
    fontSize: 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null
  ): MeasureNumbering {
    this.attributes['font-size'] = fontSize;
    return this;
  }
  getFontStyle(): 'normal' | 'italic' | null {
    return this.attributes['font-style'];
  }
  setFontStyle(fontStyle: 'normal' | 'italic' | null): MeasureNumbering {
    this.attributes['font-style'] = fontStyle;
    return this;
  }
  getFontWeight(): 'normal' | 'bold' | null {
    return this.attributes['font-weight'];
  }
  setFontWeight(fontWeight: 'normal' | 'bold' | null): MeasureNumbering {
    this.attributes['font-weight'] = fontWeight;
    return this;
  }
  getHalign(): 'left' | 'center' | 'right' | null {
    return this.attributes['halign'];
  }
  setHalign(halign: 'left' | 'center' | 'right' | null): MeasureNumbering {
    this.attributes['halign'] = halign;
    return this;
  }
  getMultipleRestAlways(): 'yes' | 'no' | null {
    return this.attributes['multiple-rest-always'];
  }
  setMultipleRestAlways(multipleRestAlways: 'yes' | 'no' | null): MeasureNumbering {
    this.attributes['multiple-rest-always'] = multipleRestAlways;
    return this;
  }
  getMultipleRestRange(): 'yes' | 'no' | null {
    return this.attributes['multiple-rest-range'];
  }
  setMultipleRestRange(multipleRestRange: 'yes' | 'no' | null): MeasureNumbering {
    this.attributes['multiple-rest-range'] = multipleRestRange;
    return this;
  }
  getRelativeX(): number | null {
    return this.attributes['relative-x'];
  }
  setRelativeX(relativeX: number | null): MeasureNumbering {
    this.attributes['relative-x'] = relativeX;
    return this;
  }
  getRelativeY(): number | null {
    return this.attributes['relative-y'];
  }
  setRelativeY(relativeY: number | null): MeasureNumbering {
    this.attributes['relative-y'] = relativeY;
    return this;
  }
  getStaff(): number | null {
    return this.attributes['staff'];
  }
  setStaff(staff: number | null): MeasureNumbering {
    this.attributes['staff'] = staff;
    return this;
  }
  getSystem(): 'none' | 'only-top' | 'only-bottom' | 'also-top' | 'also-bottom' | null {
    return this.attributes['system'];
  }
  setSystem(system: 'none' | 'only-top' | 'only-bottom' | 'also-top' | 'also-bottom' | null): MeasureNumbering {
    this.attributes['system'] = system;
    return this;
  }
  getValign(): 'top' | 'middle' | 'bottom' | 'baseline' | null {
    return this.attributes['valign'];
  }
  setValign(valign: 'top' | 'middle' | 'bottom' | 'baseline' | null): MeasureNumbering {
    this.attributes['valign'] = valign;
    return this;
  }
  getMeasureNumberValue(): 'none' | 'measure' | 'system' {
    return this.contents[0];
  }
  setMeasureNumberValue(measureNumberValue: 'none' | 'measure' | 'system'): MeasureNumbering {
    this.contents[0] = measureNumberValue;
    return this;
  }
}

export type PrintAttributes = {
  'blank-page': number | null;
  id: string | null;
  'new-page': 'yes' | 'no' | null;
  'new-system': 'yes' | 'no' | null;
  'page-number': string | null;
  'staff-spacing': number | null;
};

export type PrintContents = [
  PageLayout | null,
  SystemLayout | null,
  Array<StaffLayout>,
  MeasureLayout | null,
  MeasureNumbering | null,
  PartNameDisplay | null,
  PartAbbreviationDisplay | null
];

export class Print implements XMLElement<'print', PrintAttributes, PrintContents> {
  static readonly schema = {
    name: 'print',
    attributes: {
      'blank-page': { type: 'optional', value: { type: 'int', min: 1, max: Infinity } },
      id: { type: 'optional', value: { type: 'regex', pattern: /[A-Za-z_][A-Za-z0-9.-_]*/, zero: '_' } },
      'new-page': { type: 'optional', value: { type: 'choices', choices: ['yes', 'no'] } },
      'new-system': { type: 'optional', value: { type: 'choices', choices: ['yes', 'no'] } },
      'page-number': { type: 'optional', value: { type: 'string' } },
      'staff-spacing': { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
    },
    contents: [
      { type: 'optional', value: PageLayout },
      { type: 'optional', value: SystemLayout },
      { type: 'label', label: 'staff-layouts', value: { type: 'zeroOrMore', value: StaffLayout } },
      { type: 'optional', value: MeasureLayout },
      { type: 'optional', value: MeasureNumbering },
      { type: 'optional', value: PartNameDisplay },
      { type: 'optional', value: PartAbbreviationDisplay },
    ],
  } as const;

  readonly schema = Print.schema;

  attributes: PrintAttributes;
  contents: PrintContents;

  constructor(opts?: { attributes?: Partial<PrintAttributes>; contents?: PrintContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Print.schema);
    this.contents = opts?.contents ?? operations.zero(Print.schema.contents);
  }
  getBlankPage(): number | null {
    return this.attributes['blank-page'];
  }
  setBlankPage(blankPage: number | null): Print {
    this.attributes['blank-page'] = blankPage;
    return this;
  }
  getId(): string | null {
    return this.attributes['id'];
  }
  setId(id: string | null): Print {
    this.attributes['id'] = id;
    return this;
  }
  getNewPage(): 'yes' | 'no' | null {
    return this.attributes['new-page'];
  }
  setNewPage(newPage: 'yes' | 'no' | null): Print {
    this.attributes['new-page'] = newPage;
    return this;
  }
  getNewSystem(): 'yes' | 'no' | null {
    return this.attributes['new-system'];
  }
  setNewSystem(newSystem: 'yes' | 'no' | null): Print {
    this.attributes['new-system'] = newSystem;
    return this;
  }
  getPageNumber(): string | null {
    return this.attributes['page-number'];
  }
  setPageNumber(pageNumber: string | null): Print {
    this.attributes['page-number'] = pageNumber;
    return this;
  }
  getStaffSpacing(): number | null {
    return this.attributes['staff-spacing'];
  }
  setStaffSpacing(staffSpacing: number | null): Print {
    this.attributes['staff-spacing'] = staffSpacing;
    return this;
  }
  getPageLayout(): PageLayout | null {
    return this.contents[0];
  }
  setPageLayout(pageLayout: PageLayout | null): Print {
    this.contents[0] = pageLayout;
    return this;
  }
  getSystemLayout(): SystemLayout | null {
    return this.contents[1];
  }
  setSystemLayout(systemLayout: SystemLayout | null): Print {
    this.contents[1] = systemLayout;
    return this;
  }
  getStaffLayouts(): Array<StaffLayout> {
    return this.contents[2];
  }
  setStaffLayouts(staffLayouts: Array<StaffLayout>): Print {
    this.contents[2] = staffLayouts;
    return this;
  }
  getMeasureLayout(): MeasureLayout | null {
    return this.contents[3];
  }
  setMeasureLayout(measureLayout: MeasureLayout | null): Print {
    this.contents[3] = measureLayout;
    return this;
  }
  getMeasureNumbering(): MeasureNumbering | null {
    return this.contents[4];
  }
  setMeasureNumbering(measureNumbering: MeasureNumbering | null): Print {
    this.contents[4] = measureNumbering;
    return this;
  }
  getPartNameDisplay(): PartNameDisplay | null {
    return this.contents[5];
  }
  setPartNameDisplay(partNameDisplay: PartNameDisplay | null): Print {
    this.contents[5] = partNameDisplay;
    return this;
  }
  getPartAbbreviationDisplay(): PartAbbreviationDisplay | null {
    return this.contents[6];
  }
  setPartAbbreviationDisplay(partAbbreviationDisplay: PartAbbreviationDisplay | null): Print {
    this.contents[6] = partAbbreviationDisplay;
    return this;
  }
}

export type BarStyleAttributes = { color: string | null };

export type BarStyleContents = [
  | 'none'
  | 'dashed'
  | 'dotted'
  | 'heavy'
  | 'heavy-heavy'
  | 'heavy-light'
  | 'light-heavy'
  | 'light-light'
  | 'regular'
  | 'short'
  | 'tick'
];

export class BarStyle implements XMLElement<'bar-style', BarStyleAttributes, BarStyleContents> {
  static readonly schema = {
    name: 'bar-style',
    attributes: {
      color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
    },
    contents: [
      {
        type: 'required',
        value: {
          type: 'label',
          label: 'bar-style',
          value: {
            type: 'choices',
            choices: [
              'none',
              'dashed',
              'dotted',
              'heavy',
              'heavy-heavy',
              'heavy-light',
              'light-heavy',
              'light-light',
              'regular',
              'short',
              'tick',
            ],
          },
        },
      },
    ],
  } as const;

  readonly schema = BarStyle.schema;

  attributes: BarStyleAttributes;
  contents: BarStyleContents;

  constructor(opts?: { attributes?: Partial<BarStyleAttributes>; contents?: BarStyleContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, BarStyle.schema);
    this.contents = opts?.contents ?? operations.zero(BarStyle.schema.contents);
  }
  getColor(): string | null {
    return this.attributes['color'];
  }
  setColor(color: string | null): BarStyle {
    this.attributes['color'] = color;
    return this;
  }
  getBarStyle():
    | 'none'
    | 'dashed'
    | 'dotted'
    | 'heavy'
    | 'heavy-heavy'
    | 'heavy-light'
    | 'light-heavy'
    | 'light-light'
    | 'regular'
    | 'short'
    | 'tick' {
    return this.contents[0];
  }
  setBarStyle(
    barStyle:
      | 'none'
      | 'dashed'
      | 'dotted'
      | 'heavy'
      | 'heavy-heavy'
      | 'heavy-light'
      | 'light-heavy'
      | 'light-light'
      | 'regular'
      | 'short'
      | 'tick'
  ): BarStyle {
    this.contents[0] = barStyle;
    return this;
  }
}

export type EndingAttributes = {
  number: string;
  type: 'start' | 'stop' | 'discontinue';
  color: string | null;
  'default-x': number | null;
  'default-y': number | null;
  'end-length': number | null;
  'font-family': string | null;
  'font-size': 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null;
  'font-style': 'normal' | 'italic' | null;
  'font-weight': 'normal' | 'bold' | null;
  'print-object': 'yes' | 'no' | null;
  'relative-x': number | null;
  'relative-y': number | null;
  system: 'none' | 'only-top' | 'also-top' | null;
  'text-x': number | null;
  'text-y': number | null;
};

export type EndingContents = [string];

export class Ending implements XMLElement<'ending', EndingAttributes, EndingContents> {
  static readonly schema = {
    name: 'ending',
    attributes: {
      number: {
        type: 'required',
        value: { type: 'regex', pattern: /([ ]*)|([1-9][0-9]*(, ?[1-9][0-9]*)*)/, zero: '' },
      },
      type: { type: 'required', value: { type: 'choices', choices: ['start', 'stop', 'discontinue'] } },
      color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
      'default-x': {
        type: 'label',
        label: 'default-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'default-y': {
        type: 'label',
        label: 'default-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'end-length': { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
      'font-size': {
        type: 'optional',
        value: {
          type: 'choices',
          choices: [
            { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
            { type: 'float', min: -Infinity, max: Infinity },
          ],
        },
      },
      'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
      'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
      'print-object': { type: 'optional', value: { type: 'choices', choices: ['yes', 'no'] } },
      'relative-x': {
        type: 'label',
        label: 'relative-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'relative-y': {
        type: 'label',
        label: 'relative-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      system: { type: 'optional', value: { type: 'choices', choices: ['none', 'only-top', 'also-top'] } },
      'text-x': { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      'text-y': { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
    },
    contents: [{ type: 'required', value: { type: 'string' } }],
  } as const;

  readonly schema = Ending.schema;

  attributes: EndingAttributes;
  contents: EndingContents;

  constructor(opts?: { attributes?: Partial<EndingAttributes>; contents?: EndingContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Ending.schema);
    this.contents = opts?.contents ?? operations.zero(Ending.schema.contents);
  }
  getNumber(): string {
    return this.attributes['number'];
  }
  setNumber(number: string): Ending {
    this.attributes['number'] = number;
    return this;
  }
  getType(): 'start' | 'stop' | 'discontinue' {
    return this.attributes['type'];
  }
  setType(type: 'start' | 'stop' | 'discontinue'): Ending {
    this.attributes['type'] = type;
    return this;
  }
  getColor(): string | null {
    return this.attributes['color'];
  }
  setColor(color: string | null): Ending {
    this.attributes['color'] = color;
    return this;
  }
  getDefaultX(): number | null {
    return this.attributes['default-x'];
  }
  setDefaultX(defaultX: number | null): Ending {
    this.attributes['default-x'] = defaultX;
    return this;
  }
  getDefaultY(): number | null {
    return this.attributes['default-y'];
  }
  setDefaultY(defaultY: number | null): Ending {
    this.attributes['default-y'] = defaultY;
    return this;
  }
  getEndLength(): number | null {
    return this.attributes['end-length'];
  }
  setEndLength(endLength: number | null): Ending {
    this.attributes['end-length'] = endLength;
    return this;
  }
  getFontFamily(): string | null {
    return this.attributes['font-family'];
  }
  setFontFamily(fontFamily: string | null): Ending {
    this.attributes['font-family'] = fontFamily;
    return this;
  }
  getFontSize(): 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null {
    return this.attributes['font-size'];
  }
  setFontSize(
    fontSize: 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null
  ): Ending {
    this.attributes['font-size'] = fontSize;
    return this;
  }
  getFontStyle(): 'normal' | 'italic' | null {
    return this.attributes['font-style'];
  }
  setFontStyle(fontStyle: 'normal' | 'italic' | null): Ending {
    this.attributes['font-style'] = fontStyle;
    return this;
  }
  getFontWeight(): 'normal' | 'bold' | null {
    return this.attributes['font-weight'];
  }
  setFontWeight(fontWeight: 'normal' | 'bold' | null): Ending {
    this.attributes['font-weight'] = fontWeight;
    return this;
  }
  getPrintObject(): 'yes' | 'no' | null {
    return this.attributes['print-object'];
  }
  setPrintObject(printObject: 'yes' | 'no' | null): Ending {
    this.attributes['print-object'] = printObject;
    return this;
  }
  getRelativeX(): number | null {
    return this.attributes['relative-x'];
  }
  setRelativeX(relativeX: number | null): Ending {
    this.attributes['relative-x'] = relativeX;
    return this;
  }
  getRelativeY(): number | null {
    return this.attributes['relative-y'];
  }
  setRelativeY(relativeY: number | null): Ending {
    this.attributes['relative-y'] = relativeY;
    return this;
  }
  getSystem(): 'none' | 'only-top' | 'also-top' | null {
    return this.attributes['system'];
  }
  setSystem(system: 'none' | 'only-top' | 'also-top' | null): Ending {
    this.attributes['system'] = system;
    return this;
  }
  getTextX(): number | null {
    return this.attributes['text-x'];
  }
  setTextX(textX: number | null): Ending {
    this.attributes['text-x'] = textX;
    return this;
  }
  getTextY(): number | null {
    return this.attributes['text-y'];
  }
  setTextY(textY: number | null): Ending {
    this.attributes['text-y'] = textY;
    return this;
  }
  getText(): string {
    return this.contents[0];
  }
  setText(text: string): Ending {
    this.contents[0] = text;
    return this;
  }
}

export type RepeatAttributes = {
  direction: 'backward' | 'forward';
  'after-jump': 'yes' | 'no' | null;
  times: number | null;
  winged: 'none' | 'straight' | 'curved' | 'double-straight' | 'double-curved' | null;
};

export type RepeatContents = [];

export class Repeat implements XMLElement<'repeat', RepeatAttributes, RepeatContents> {
  static readonly schema = {
    name: 'repeat',
    attributes: {
      direction: { type: 'required', value: { type: 'choices', choices: ['backward', 'forward'] } },
      'after-jump': { type: 'optional', value: { type: 'choices', choices: ['yes', 'no'] } },
      times: { type: 'optional', value: { type: 'int', min: 0, max: Infinity } },
      winged: {
        type: 'optional',
        value: { type: 'choices', choices: ['none', 'straight', 'curved', 'double-straight', 'double-curved'] },
      },
    },
    contents: [],
  } as const;

  readonly schema = Repeat.schema;

  attributes: RepeatAttributes;
  contents: RepeatContents;

  constructor(opts?: { attributes?: Partial<RepeatAttributes>; contents?: RepeatContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Repeat.schema);
    this.contents = opts?.contents ?? operations.zero(Repeat.schema.contents);
  }
  getDirection(): 'backward' | 'forward' {
    return this.attributes['direction'];
  }
  setDirection(direction: 'backward' | 'forward'): Repeat {
    this.attributes['direction'] = direction;
    return this;
  }
  getAfterJump(): 'yes' | 'no' | null {
    return this.attributes['after-jump'];
  }
  setAfterJump(afterJump: 'yes' | 'no' | null): Repeat {
    this.attributes['after-jump'] = afterJump;
    return this;
  }
  getTimes(): number | null {
    return this.attributes['times'];
  }
  setTimes(times: number | null): Repeat {
    this.attributes['times'] = times;
    return this;
  }
  getWinged(): 'none' | 'straight' | 'curved' | 'double-straight' | 'double-curved' | null {
    return this.attributes['winged'];
  }
  setWinged(winged: 'none' | 'straight' | 'curved' | 'double-straight' | 'double-curved' | null): Repeat {
    this.attributes['winged'] = winged;
    return this;
  }
}

export type BarlineAttributes = {
  coda: string | null;
  divisions: number | null;
  id: string | null;
  location: 'right' | 'left' | 'middle' | null;
  segno: string | null;
};

export type BarlineContents = [
  BarStyle | null,
  Footnote | null,
  Level | null,
  WavyLine | null,
  Segno | null,
  Coda | null,
  [] | [Fermata] | [Fermata, Fermata],
  Ending | null,
  Repeat | null
];

export class Barline implements XMLElement<'barline', BarlineAttributes, BarlineContents> {
  static readonly schema = {
    name: 'barline',
    attributes: {
      coda: { type: 'label', label: 'coda-token', value: { type: 'optional', value: { type: 'string' } } },
      divisions: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      id: { type: 'optional', value: { type: 'regex', pattern: /[A-Za-z_][A-Za-z0-9.-_]*/, zero: '_' } },
      location: { type: 'optional', value: { type: 'choices', choices: ['right', 'left', 'middle'] } },
      segno: { type: 'label', label: 'segno-token', value: { type: 'optional', value: { type: 'string' } } },
    },
    contents: [
      { type: 'optional', value: BarStyle },
      { type: 'optional', value: Footnote },
      { type: 'optional', value: Level },
      { type: 'optional', value: WavyLine },
      { type: 'optional', value: Segno },
      { type: 'optional', value: Coda },
      { type: 'label', label: 'fermatas', value: { type: 'choices', choices: [[], [Fermata], [Fermata, Fermata]] } },
      { type: 'optional', value: Ending },
      { type: 'optional', value: Repeat },
    ],
  } as const;

  readonly schema = Barline.schema;

  attributes: BarlineAttributes;
  contents: BarlineContents;

  constructor(opts?: { attributes?: Partial<BarlineAttributes>; contents?: BarlineContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Barline.schema);
    this.contents = opts?.contents ?? operations.zero(Barline.schema.contents);
  }
  getCodaToken(): string | null {
    return this.attributes['coda'];
  }
  setCodaToken(codaToken: string | null): Barline {
    this.attributes['coda'] = codaToken;
    return this;
  }
  getDivisions(): number | null {
    return this.attributes['divisions'];
  }
  setDivisions(divisions: number | null): Barline {
    this.attributes['divisions'] = divisions;
    return this;
  }
  getId(): string | null {
    return this.attributes['id'];
  }
  setId(id: string | null): Barline {
    this.attributes['id'] = id;
    return this;
  }
  getLocation(): 'right' | 'left' | 'middle' | null {
    return this.attributes['location'];
  }
  setLocation(location: 'right' | 'left' | 'middle' | null): Barline {
    this.attributes['location'] = location;
    return this;
  }
  getSegnoToken(): string | null {
    return this.attributes['segno'];
  }
  setSegnoToken(segnoToken: string | null): Barline {
    this.attributes['segno'] = segnoToken;
    return this;
  }
  getBarStyle(): BarStyle | null {
    return this.contents[0];
  }
  setBarStyle(barStyle: BarStyle | null): Barline {
    this.contents[0] = barStyle;
    return this;
  }
  getFootnote(): Footnote | null {
    return this.contents[1];
  }
  setFootnote(footnote: Footnote | null): Barline {
    this.contents[1] = footnote;
    return this;
  }
  getLevel(): Level | null {
    return this.contents[2];
  }
  setLevel(level: Level | null): Barline {
    this.contents[2] = level;
    return this;
  }
  getWavyLine(): WavyLine | null {
    return this.contents[3];
  }
  setWavyLine(wavyLine: WavyLine | null): Barline {
    this.contents[3] = wavyLine;
    return this;
  }
  getSegno(): Segno | null {
    return this.contents[4];
  }
  setSegno(segno: Segno | null): Barline {
    this.contents[4] = segno;
    return this;
  }
  getCoda(): Coda | null {
    return this.contents[5];
  }
  setCoda(coda: Coda | null): Barline {
    this.contents[5] = coda;
    return this;
  }
  getFermatas(): [] | [Fermata] | [Fermata, Fermata] {
    return this.contents[6];
  }
  setFermatas(fermatas: [] | [Fermata] | [Fermata, Fermata]): Barline {
    this.contents[6] = fermatas;
    return this;
  }
  getEnding(): Ending | null {
    return this.contents[7];
  }
  setEnding(ending: Ending | null): Barline {
    this.contents[7] = ending;
    return this;
  }
  getRepeat(): Repeat | null {
    return this.contents[8];
  }
  setRepeat(repeat: Repeat | null): Barline {
    this.contents[8] = repeat;
    return this;
  }
}

export type FeatureAttributes = { type: string | null };

export type FeatureContents = [string];

export class Feature implements XMLElement<'feature', FeatureAttributes, FeatureContents> {
  static readonly schema = {
    name: 'feature',
    attributes: { type: { type: 'optional', value: { type: 'string' } } },
    contents: [{ type: 'required', value: { type: 'string' } }],
  } as const;

  readonly schema = Feature.schema;

  attributes: FeatureAttributes;
  contents: FeatureContents;

  constructor(opts?: { attributes?: Partial<FeatureAttributes>; contents?: FeatureContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Feature.schema);
    this.contents = opts?.contents ?? operations.zero(Feature.schema.contents);
  }
  getType(): string | null {
    return this.attributes['type'];
  }
  setType(type: string | null): Feature {
    this.attributes['type'] = type;
    return this;
  }
  getText(): string {
    return this.contents[0];
  }
  setText(text: string): Feature {
    this.contents[0] = text;
    return this;
  }
}

export type GroupingAttributes = {
  type: 'start' | 'stop' | 'single';
  id: string | null;
  'member-of': string | null;
  number: string | null;
};

export type GroupingContents = [Array<Feature>];

export class Grouping implements XMLElement<'grouping', GroupingAttributes, GroupingContents> {
  static readonly schema = {
    name: 'grouping',
    attributes: {
      type: { type: 'required', value: { type: 'choices', choices: ['start', 'stop', 'single'] } },
      id: { type: 'optional', value: { type: 'regex', pattern: /[A-Za-z_][A-Za-z0-9.-_]*/, zero: '_' } },
      'member-of': { type: 'optional', value: { type: 'string' } },
      number: { type: 'optional', value: { type: 'string' } },
    },
    contents: [{ type: 'label', label: 'features', value: { type: 'zeroOrMore', value: Feature } }],
  } as const;

  readonly schema = Grouping.schema;

  attributes: GroupingAttributes;
  contents: GroupingContents;

  constructor(opts?: { attributes?: Partial<GroupingAttributes>; contents?: GroupingContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Grouping.schema);
    this.contents = opts?.contents ?? operations.zero(Grouping.schema.contents);
  }
  getType(): 'start' | 'stop' | 'single' {
    return this.attributes['type'];
  }
  setType(type: 'start' | 'stop' | 'single'): Grouping {
    this.attributes['type'] = type;
    return this;
  }
  getId(): string | null {
    return this.attributes['id'];
  }
  setId(id: string | null): Grouping {
    this.attributes['id'] = id;
    return this;
  }
  getMemberOf(): string | null {
    return this.attributes['member-of'];
  }
  setMemberOf(memberOf: string | null): Grouping {
    this.attributes['member-of'] = memberOf;
    return this;
  }
  getNumber(): string | null {
    return this.attributes['number'];
  }
  setNumber(number: string | null): Grouping {
    this.attributes['number'] = number;
    return this;
  }
  getFeatures(): Array<Feature> {
    return this.contents[0];
  }
  setFeatures(features: Array<Feature>): Grouping {
    this.contents[0] = features;
    return this;
  }
}

export type MeasurePartwiseAttributes = {
  number: string;
  id: string | null;
  implicit: 'yes' | 'no' | null;
  'non-controller': 'yes' | 'no' | null;
  text: Exclude<'yes' | string, ''> | null;
  width: number | null;
};

export type MeasurePartwiseContents = [
  Array<
    | Note
    | Backup
    | Forward
    | Direction
    | Attributes
    | Harmony
    | FiguredBass
    | Print
    | Sound
    | Listening
    | Barline
    | Grouping
    | Link
    | Bookmark
  >
];

export class MeasurePartwise implements XMLElement<'measure', MeasurePartwiseAttributes, MeasurePartwiseContents> {
  static readonly schema = {
    name: 'measure',
    attributes: {
      number: { type: 'required', value: { type: 'string' } },
      id: { type: 'optional', value: { type: 'regex', pattern: /[A-Za-z_][A-Za-z0-9.-_]*/, zero: '_' } },
      implicit: { type: 'optional', value: { type: 'choices', choices: ['yes', 'no'] } },
      'non-controller': { type: 'optional', value: { type: 'choices', choices: ['yes', 'no'] } },
      text: {
        type: 'optional',
        value: {
          type: 'not',
          include: { type: 'choices', choices: ['yes', { type: 'string' }] },
          exclude: { type: 'constant', value: '' },
        },
      },
      width: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
    },
    contents: [
      {
        type: 'label',
        label: 'measure-values',
        value: {
          type: 'zeroOrMore',
          value: {
            type: 'choices',
            choices: [
              Note,
              Backup,
              Forward,
              Direction,
              Attributes,
              Harmony,
              FiguredBass,
              Print,
              Sound,
              Listening,
              Barline,
              Grouping,
              Link,
              Bookmark,
            ],
          },
        },
      },
    ],
  } as const;

  readonly schema = MeasurePartwise.schema;

  attributes: MeasurePartwiseAttributes;
  contents: MeasurePartwiseContents;

  constructor(opts?: { attributes?: Partial<MeasurePartwiseAttributes>; contents?: MeasurePartwiseContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, MeasurePartwise.schema);
    this.contents = opts?.contents ?? operations.zero(MeasurePartwise.schema.contents);
  }
  getNumber(): string {
    return this.attributes['number'];
  }
  setNumber(number: string): MeasurePartwise {
    this.attributes['number'] = number;
    return this;
  }
  getId(): string | null {
    return this.attributes['id'];
  }
  setId(id: string | null): MeasurePartwise {
    this.attributes['id'] = id;
    return this;
  }
  getImplicit(): 'yes' | 'no' | null {
    return this.attributes['implicit'];
  }
  setImplicit(implicit: 'yes' | 'no' | null): MeasurePartwise {
    this.attributes['implicit'] = implicit;
    return this;
  }
  getNonController(): 'yes' | 'no' | null {
    return this.attributes['non-controller'];
  }
  setNonController(nonController: 'yes' | 'no' | null): MeasurePartwise {
    this.attributes['non-controller'] = nonController;
    return this;
  }
  getText(): Exclude<'yes' | string, ''> | null {
    return this.attributes['text'];
  }
  setText(text: Exclude<'yes' | string, ''> | null): MeasurePartwise {
    this.attributes['text'] = text;
    return this;
  }
  getWidth(): number | null {
    return this.attributes['width'];
  }
  setWidth(width: number | null): MeasurePartwise {
    this.attributes['width'] = width;
    return this;
  }
  getMeasureValues(): Array<
    | Note
    | Backup
    | Forward
    | Direction
    | Attributes
    | Harmony
    | FiguredBass
    | Print
    | Sound
    | Listening
    | Barline
    | Grouping
    | Link
    | Bookmark
  > {
    return this.contents[0];
  }
  setMeasureValues(
    measureValues: Array<
      | Note
      | Backup
      | Forward
      | Direction
      | Attributes
      | Harmony
      | FiguredBass
      | Print
      | Sound
      | Listening
      | Barline
      | Grouping
      | Link
      | Bookmark
    >
  ): MeasurePartwise {
    this.contents[0] = measureValues;
    return this;
  }
}

export type PartPartwiseAttributes = { id: string };

export type PartPartwiseContents = [Array<MeasurePartwise>];

export class PartPartwise implements XMLElement<'part', PartPartwiseAttributes, PartPartwiseContents> {
  static readonly schema = {
    name: 'part',
    attributes: { id: { type: 'regex', pattern: /[A-Za-z_][A-Za-z0-9.-_]*/, zero: '_' } },
    contents: [{ type: 'label', label: 'measures', value: { type: 'oneOrMore', value: MeasurePartwise } }],
  } as const;

  readonly schema = PartPartwise.schema;

  attributes: PartPartwiseAttributes;
  contents: PartPartwiseContents;

  constructor(opts?: { attributes?: Partial<PartPartwiseAttributes>; contents?: PartPartwiseContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, PartPartwise.schema);
    this.contents = opts?.contents ?? operations.zero(PartPartwise.schema.contents);
  }
  getId(): string {
    return this.attributes['id'];
  }
  setId(id: string): PartPartwise {
    this.attributes['id'] = id;
    return this;
  }
  getMeasures(): Array<MeasurePartwise> {
    return this.contents[0];
  }
  setMeasures(measures: Array<MeasurePartwise>): PartPartwise {
    this.contents[0] = measures;
    return this;
  }
}

export type ScorePartwiseAttributes = { version: '4.0' };

export type ScorePartwiseContents = [
  Work | null,
  MovementNumber | null,
  MovementTitle | null,
  Identification | null,
  Defaults | null,
  Array<Credit>,
  PartList,
  Array<PartPartwise>
];

export class ScorePartwise implements XMLElement<'score-partwise', ScorePartwiseAttributes, ScorePartwiseContents> {
  static readonly schema = {
    name: 'score-partwise',
    attributes: { version: { type: 'constant', value: '4.0' } },
    contents: [
      { type: 'optional', value: Work },
      { type: 'optional', value: MovementNumber },
      { type: 'optional', value: MovementTitle },
      { type: 'optional', value: Identification },
      { type: 'optional', value: Defaults },
      { type: 'label', label: 'credits', value: { type: 'zeroOrMore', value: Credit } },
      { type: 'required', value: PartList },
      { type: 'label', label: 'parts', value: { type: 'oneOrMore', value: PartPartwise } },
    ],
  } as const;

  readonly schema = ScorePartwise.schema;

  attributes: ScorePartwiseAttributes;
  contents: ScorePartwiseContents;

  constructor(opts?: { attributes?: Partial<ScorePartwiseAttributes>; contents?: ScorePartwiseContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, ScorePartwise.schema);
    this.contents = opts?.contents ?? operations.zero(ScorePartwise.schema.contents);
  }
  getVersion(): '4.0' {
    return this.attributes['version'];
  }
  setVersion(version: '4.0'): ScorePartwise {
    this.attributes['version'] = version;
    return this;
  }
  getWork(): Work | null {
    return this.contents[0];
  }
  setWork(work: Work | null): ScorePartwise {
    this.contents[0] = work;
    return this;
  }
  getMovementNumber(): MovementNumber | null {
    return this.contents[1];
  }
  setMovementNumber(movementNumber: MovementNumber | null): ScorePartwise {
    this.contents[1] = movementNumber;
    return this;
  }
  getMovementTitle(): MovementTitle | null {
    return this.contents[2];
  }
  setMovementTitle(movementTitle: MovementTitle | null): ScorePartwise {
    this.contents[2] = movementTitle;
    return this;
  }
  getIdentification(): Identification | null {
    return this.contents[3];
  }
  setIdentification(identification: Identification | null): ScorePartwise {
    this.contents[3] = identification;
    return this;
  }
  getDefaults(): Defaults | null {
    return this.contents[4];
  }
  setDefaults(defaults: Defaults | null): ScorePartwise {
    this.contents[4] = defaults;
    return this;
  }
  getCredits(): Array<Credit> {
    return this.contents[5];
  }
  setCredits(credits: Array<Credit>): ScorePartwise {
    this.contents[5] = credits;
    return this;
  }
  getPartList(): PartList {
    return this.contents[6];
  }
  setPartList(partList: PartList): ScorePartwise {
    this.contents[6] = partList;
    return this;
  }
  getParts(): Array<PartPartwise> {
    return this.contents[7];
  }
  setParts(parts: Array<PartPartwise>): ScorePartwise {
    this.contents[7] = parts;
    return this;
  }
}

export type PartTimewiseAttributes = { id: string };

export type PartTimewiseContents = [
  Array<
    | Note
    | Backup
    | Forward
    | Direction
    | Attributes
    | Harmony
    | FiguredBass
    | Print
    | Sound
    | Listening
    | Barline
    | Grouping
    | Link
    | Bookmark
  >
];

export class PartTimewise implements XMLElement<'part', PartTimewiseAttributes, PartTimewiseContents> {
  static readonly schema = {
    name: 'part',
    attributes: { id: { type: 'regex', pattern: /[A-Za-z_][A-Za-z0-9.-_]*/, zero: '_' } },
    contents: [
      {
        type: 'label',
        label: 'part-timewise-values',
        value: {
          type: 'zeroOrMore',
          value: {
            type: 'choices',
            choices: [
              Note,
              Backup,
              Forward,
              Direction,
              Attributes,
              Harmony,
              FiguredBass,
              Print,
              Sound,
              Listening,
              Barline,
              Grouping,
              Link,
              Bookmark,
            ],
          },
        },
      },
    ],
  } as const;

  readonly schema = PartTimewise.schema;

  attributes: PartTimewiseAttributes;
  contents: PartTimewiseContents;

  constructor(opts?: { attributes?: Partial<PartTimewiseAttributes>; contents?: PartTimewiseContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, PartTimewise.schema);
    this.contents = opts?.contents ?? operations.zero(PartTimewise.schema.contents);
  }
  getId(): string {
    return this.attributes['id'];
  }
  setId(id: string): PartTimewise {
    this.attributes['id'] = id;
    return this;
  }
  getPartTimewiseValues(): Array<
    | Note
    | Backup
    | Forward
    | Direction
    | Attributes
    | Harmony
    | FiguredBass
    | Print
    | Sound
    | Listening
    | Barline
    | Grouping
    | Link
    | Bookmark
  > {
    return this.contents[0];
  }
  setPartTimewiseValues(
    partTimewiseValues: Array<
      | Note
      | Backup
      | Forward
      | Direction
      | Attributes
      | Harmony
      | FiguredBass
      | Print
      | Sound
      | Listening
      | Barline
      | Grouping
      | Link
      | Bookmark
    >
  ): PartTimewise {
    this.contents[0] = partTimewiseValues;
    return this;
  }
}

export type MeasureTimewiseAttributes = {
  number: string;
  id: string | null;
  implicit: 'yes' | 'no' | null;
  'non-controller': 'yes' | 'no' | null;
  text: Exclude<'yes' | string, ''> | null;
  width: number | null;
};

export type MeasureTimewiseContents = [Array<PartTimewise>];

export class MeasureTimewise implements XMLElement<'measure', MeasureTimewiseAttributes, MeasureTimewiseContents> {
  static readonly schema = {
    name: 'measure',
    attributes: {
      number: { type: 'required', value: { type: 'string' } },
      id: { type: 'optional', value: { type: 'regex', pattern: /[A-Za-z_][A-Za-z0-9.-_]*/, zero: '_' } },
      implicit: { type: 'optional', value: { type: 'choices', choices: ['yes', 'no'] } },
      'non-controller': { type: 'optional', value: { type: 'choices', choices: ['yes', 'no'] } },
      text: {
        type: 'optional',
        value: {
          type: 'not',
          include: { type: 'choices', choices: ['yes', { type: 'string' }] },
          exclude: { type: 'constant', value: '' },
        },
      },
      width: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
    },
    contents: [{ type: 'label', label: 'parts', value: { type: 'oneOrMore', value: PartTimewise } }],
  } as const;

  readonly schema = MeasureTimewise.schema;

  attributes: MeasureTimewiseAttributes;
  contents: MeasureTimewiseContents;

  constructor(opts?: { attributes?: Partial<MeasureTimewiseAttributes>; contents?: MeasureTimewiseContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, MeasureTimewise.schema);
    this.contents = opts?.contents ?? operations.zero(MeasureTimewise.schema.contents);
  }
  getNumber(): string {
    return this.attributes['number'];
  }
  setNumber(number: string): MeasureTimewise {
    this.attributes['number'] = number;
    return this;
  }
  getId(): string | null {
    return this.attributes['id'];
  }
  setId(id: string | null): MeasureTimewise {
    this.attributes['id'] = id;
    return this;
  }
  getImplicit(): 'yes' | 'no' | null {
    return this.attributes['implicit'];
  }
  setImplicit(implicit: 'yes' | 'no' | null): MeasureTimewise {
    this.attributes['implicit'] = implicit;
    return this;
  }
  getNonController(): 'yes' | 'no' | null {
    return this.attributes['non-controller'];
  }
  setNonController(nonController: 'yes' | 'no' | null): MeasureTimewise {
    this.attributes['non-controller'] = nonController;
    return this;
  }
  getText(): Exclude<'yes' | string, ''> | null {
    return this.attributes['text'];
  }
  setText(text: Exclude<'yes' | string, ''> | null): MeasureTimewise {
    this.attributes['text'] = text;
    return this;
  }
  getWidth(): number | null {
    return this.attributes['width'];
  }
  setWidth(width: number | null): MeasureTimewise {
    this.attributes['width'] = width;
    return this;
  }
  getParts(): Array<PartTimewise> {
    return this.contents[0];
  }
  setParts(parts: Array<PartTimewise>): MeasureTimewise {
    this.contents[0] = parts;
    return this;
  }
}

export type ScoreTimewiseAttributes = { version: '4.0' };

export type ScoreTimewiseContents = [
  Work | null,
  MovementNumber | null,
  MovementTitle | null,
  Identification | null,
  Defaults | null,
  Array<Credit>,
  PartList,
  Array<MeasureTimewise>
];

export class ScoreTimewise implements XMLElement<'score-timewise', ScoreTimewiseAttributes, ScoreTimewiseContents> {
  static readonly schema = {
    name: 'score-timewise',
    attributes: { version: { type: 'constant', value: '4.0' } },
    contents: [
      { type: 'optional', value: Work },
      { type: 'optional', value: MovementNumber },
      { type: 'optional', value: MovementTitle },
      { type: 'optional', value: Identification },
      { type: 'optional', value: Defaults },
      { type: 'label', label: 'credits', value: { type: 'zeroOrMore', value: Credit } },
      { type: 'required', value: PartList },
      { type: 'label', label: 'measures', value: { type: 'oneOrMore', value: MeasureTimewise } },
    ],
  } as const;

  readonly schema = ScoreTimewise.schema;

  attributes: ScoreTimewiseAttributes;
  contents: ScoreTimewiseContents;

  constructor(opts?: { attributes?: Partial<ScoreTimewiseAttributes>; contents?: ScoreTimewiseContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, ScoreTimewise.schema);
    this.contents = opts?.contents ?? operations.zero(ScoreTimewise.schema.contents);
  }
  getVersion(): '4.0' {
    return this.attributes['version'];
  }
  setVersion(version: '4.0'): ScoreTimewise {
    this.attributes['version'] = version;
    return this;
  }
  getWork(): Work | null {
    return this.contents[0];
  }
  setWork(work: Work | null): ScoreTimewise {
    this.contents[0] = work;
    return this;
  }
  getMovementNumber(): MovementNumber | null {
    return this.contents[1];
  }
  setMovementNumber(movementNumber: MovementNumber | null): ScoreTimewise {
    this.contents[1] = movementNumber;
    return this;
  }
  getMovementTitle(): MovementTitle | null {
    return this.contents[2];
  }
  setMovementTitle(movementTitle: MovementTitle | null): ScoreTimewise {
    this.contents[2] = movementTitle;
    return this;
  }
  getIdentification(): Identification | null {
    return this.contents[3];
  }
  setIdentification(identification: Identification | null): ScoreTimewise {
    this.contents[3] = identification;
    return this;
  }
  getDefaults(): Defaults | null {
    return this.contents[4];
  }
  setDefaults(defaults: Defaults | null): ScoreTimewise {
    this.contents[4] = defaults;
    return this;
  }
  getCredits(): Array<Credit> {
    return this.contents[5];
  }
  setCredits(credits: Array<Credit>): ScoreTimewise {
    this.contents[5] = credits;
    return this;
  }
  getPartList(): PartList {
    return this.contents[6];
  }
  setPartList(partList: PartList): ScoreTimewise {
    this.contents[6] = partList;
    return this;
  }
  getMeasures(): Array<MeasureTimewise> {
    return this.contents[7];
  }
  setMeasures(measures: Array<MeasureTimewise>): ScoreTimewise {
    this.contents[7] = measures;
    return this;
  }
}
